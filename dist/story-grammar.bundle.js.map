{"version":3,"file":"story-grammar.bundle.js","mappings":"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","sources":["webpack://StoryGrammar/webpack/universalModuleDefinition","webpack://StoryGrammar/./src/EnglishModifiers.ts","webpack://StoryGrammar/./src/Parser.ts","webpack://StoryGrammar/./src/ParserCore.ts","webpack://StoryGrammar/./src/analysis/ComplexityAnalyzer.ts","webpack://StoryGrammar/./src/analysis/ProbabilityAnalyzer.ts","webpack://StoryGrammar/./src/core/ErrorHandler.ts","webpack://StoryGrammar/./src/core/VariableExpander.ts","webpack://StoryGrammar/./src/index.ts","webpack://StoryGrammar/./src/modifiers/english/ArticleModifier.ts","webpack://StoryGrammar/./src/modifiers/english/CapitalizationModifier.ts","webpack://StoryGrammar/./src/modifiers/english/OrdinalModifier.ts","webpack://StoryGrammar/./src/modifiers/english/PluralizationModifier.ts","webpack://StoryGrammar/./src/modifiers/english/PossessiveModifier.ts","webpack://StoryGrammar/./src/modifiers/english/PunctuationCleanupModifier.ts","webpack://StoryGrammar/./src/modifiers/english/VerbAgreementModifier.ts","webpack://StoryGrammar/./src/modifiers/english/index.ts","webpack://StoryGrammar/./src/modifiers/index.ts","webpack://StoryGrammar/./src/rules/AdvancedRuleManagers.ts","webpack://StoryGrammar/./src/rules/BaseRuleManager.ts","webpack://StoryGrammar/./src/rules/RuleManager.ts","webpack://StoryGrammar/./src/utils/SeededRandom.ts","webpack://StoryGrammar/./src/validation/GrammarValidator.ts","webpack://StoryGrammar/webpack/bootstrap","webpack://StoryGrammar/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StoryGrammar\"] = factory();\n\telse\n\t\troot[\"StoryGrammar\"] = factory();\n})(this, () => {\nreturn ","/**\n * English language modifiers for the Story Grammar Parser\n * Re-exports from the modular structure for backward compatibility\n */\n\n// Re-export individual modifiers from the modular structure\nexport { ArticleModifier as EnglishArticleModifier } from './modifiers/english/ArticleModifier.js';\nexport { PluralizationModifier as EnglishPluralizationModifier } from './modifiers/english/PluralizationModifier.js';\nexport { OrdinalModifier as EnglishOrdinalModifier } from './modifiers/english/OrdinalModifier.js';\nexport { CapitalizationModifier as EnglishCapitalizationModifier } from './modifiers/english/CapitalizationModifier.js';\n\n// Comprehensive modifiers with enhanced functionality\nimport { Modifier } from './types.js';\n\n/**\n * English possessive modifier\n * Handles English possessive forms ('s and s')\n */\nexport const EnglishPossessiveModifier: Modifier = {\n  name: 'englishPossessives',\n  condition: (text: string) => {\n    // Look for possessive patterns: word + possessive marker\n    return /\\b\\w+\\s+possessive\\b/i.test(text) || /\\b\\w+'s?\\s+\\w/.test(text);\n  },\n  transform: (text: string) => {\n    // Handle explicit possessive marker\n    text = text.replace(/\\b(\\w+)\\s+possessive\\b/gi, (match, word) => {\n      return word.endsWith('s') ? word + \"'\" : word + \"'s\";\n    });\n    \n    // Fix double possessives (word's's -> word's)\n    text = text.replace(/(\\w+)'s's/g, \"$1's\");\n    \n    return text;\n  },\n  priority: 6\n};\n\n/**\n * Punctuation cleanup modifier\n * Fixes common punctuation issues like double spaces and spacing around punctuation\n */\nexport const PunctuationCleanupModifier: Modifier = {\n  name: 'punctuationCleanup',\n  condition: (text: string) => {\n    // Look for punctuation spacing issues\n    return /\\s{2,}/.test(text) || /\\s[.!?,:;]/.test(text) || /[.!?,:;]\\S/.test(text);\n  },\n  transform: (text: string) => {\n    // Fix multiple spaces\n    text = text.replace(/\\s{2,}/g, ' ');\n    \n    // Fix space before punctuation\n    text = text.replace(/\\s([.!?,:;])/g, '$1');\n    \n    // Add space after punctuation if missing (except at end)\n    text = text.replace(/([.!?,:;])([A-Za-z])/g, '$1 $2');\n    \n    // Trim leading/trailing whitespace\n    text = text.trim();\n    \n    return text;\n  },\n  priority: 1\n};\n\nexport const EnglishVerbAgreementModifier: Modifier = {\n  name: 'englishVerbAgreement',\n  condition: (text: string) => {\n    // Look for agreement issues including has/have\n    return /\\b(he|she|it)\\s+are\\b/i.test(text) || \n           /\\b(they|many|several|few|all|both)\\s+is\\b/i.test(text) ||\n           /\\b(he|she|it)\\s+have\\b/i.test(text) ||\n           /\\b(they|many|several|few|all|both)\\s+has\\b/i.test(text);\n  },\n  transform: (text: string) => {\n    // Fix is/are agreement for singular subjects\n    text = text.replace(/\\b(he|she|it)\\s+are\\b/gi, '$1 is');\n    \n    // Fix is/are agreement for plural subjects and quantifiers\n    text = text.replace(/\\b(they|many|several|few|all|both)\\s+is\\b/gi, '$1 are');\n    \n    // Fix has/have agreement for singular subjects\n    text = text.replace(/\\b(he|she|it)\\s+have\\b/gi, '$1 has');\n    \n    // Fix has/have agreement for plural subjects and quantifiers\n    text = text.replace(/\\b(they|many|several|few|all|both)\\s+has\\b/gi, '$1 have');\n    \n    return text;\n  },\n  priority: 5\n};\n\n// Import the modifiers to create convenience arrays\nimport { ArticleModifier } from './modifiers/english/ArticleModifier.js';\nimport { PluralizationModifier } from './modifiers/english/PluralizationModifier.js';\nimport { OrdinalModifier } from './modifiers/english/OrdinalModifier.js';\nimport { CapitalizationModifier } from './modifiers/english/CapitalizationModifier.js';\n\n/**\n * Collection of all English modifiers for convenience\n */\nexport const AllEnglishModifiers = [\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier,\n  CapitalizationModifier,\n  EnglishPossessiveModifier,\n  EnglishVerbAgreementModifier,\n  PunctuationCleanupModifier\n];\n\n/**\n * Basic English modifiers (articles, pluralization, ordinals)\n */\nexport const BasicEnglishModifiers = [\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier\n];","/**\n * Parser for combinatorial grammar with variable expansion\n * \n * This file re-exports the core Parser class and all types for backward compatibility.\n * The actual implementation has been moved to separate files for better modularity.\n */\n\n// Re-export all types and interfaces\nexport * from './types.js';\n\n// Re-export the core Parser class\nexport { Parser } from './ParserCore.js';","/**\n * Simplified Parser class that coordinates between all the specialized modules\n */\nimport {\n  Grammar,\n  Modifier,\n  ModifierContext,\n  FunctionRule,\n  ConditionalRule,\n  SequentialRule,\n  RangeRule,\n  TemplateRule,\n  ParseOptions,\n  ParseResult,\n  ValidationResult,  \n  ParseTimingResult,\n  ParserStats,\n  ParserConfig,\n  OptimizationReport,\n  RuleAnalysis,\n  ErrorContext,\n  ComplexityResult,\n  TotalComplexityResult,\n  ProbabilityAnalysis,\n  ProbabilityResult\n} from './types.js';\n\n// Import all the specialized modules\nimport { SeededRandom } from './utils/SeededRandom.js';\nimport { RuleManager } from './rules/RuleManager.js';\nimport { VariableExpander } from './core/VariableExpander.js';\nimport { ComplexityAnalyzer } from './analysis/ComplexityAnalyzer.js';\nimport { ProbabilityAnalyzer } from './analysis/ProbabilityAnalyzer.js';\nimport { GrammarValidator } from './validation/GrammarValidator.js';\nimport { ErrorHandler } from './core/ErrorHandler.js';\n\nexport class Parser {\n  // Core modules\n  private random: SeededRandom;\n  private ruleManager: RuleManager;\n  private variableExpander: VariableExpander;\n  private complexityAnalyzer: ComplexityAnalyzer;\n  private probabilityAnalyzer: ProbabilityAnalyzer;\n  private validator: GrammarValidator;\n  private errorHandler: ErrorHandler;\n  \n  // Modifiers\n  private modifiers: Map<string, Modifier> = new Map();\n\n  constructor() {\n    // Initialize all modules\n    this.random = new SeededRandom();\n    this.ruleManager = new RuleManager();\n    this.variableExpander = new VariableExpander(this.ruleManager, this.random);\n    this.complexityAnalyzer = new ComplexityAnalyzer(this.ruleManager, this.variableExpander);\n    this.probabilityAnalyzer = new ProbabilityAnalyzer(this.ruleManager, this.variableExpander);\n    this.validator = new GrammarValidator(this.ruleManager, this.variableExpander);\n    this.errorHandler = new ErrorHandler(this.ruleManager, this.validator);\n  }\n\n  // ==================== RULE MANAGEMENT ====================\n\n  /**\n   * Add a static rule to the grammar\n   */\n  public addRule(key: string, values: string[]): void {\n    this.ruleManager.addRule(key, values);\n  }\n\n  /**\n   * Add multiple rules to the grammar\n   */\n  public addRules(rules: Grammar): void {\n    this.ruleManager.addRules(rules);\n  }\n\n  /**\n   * Add a function rule to the grammar\n   */\n  public addFunctionRule(key: string, fn: FunctionRule): void {\n    this.ruleManager.addFunctionRule(key, fn);\n  }\n\n  /**\n   * Add a weighted rule for probability-controlled random selection\n   */\n  public addWeightedRule(key: string, values: string[], weights: number[]): void {\n    this.ruleManager.addWeightedRule(key, values, weights);\n  }\n\n  /**\n   * Add a context-aware conditional rule for dynamic value selection\n   */\n  public addConditionalRule(key: string, rule: ConditionalRule): void {\n    this.ruleManager.addConditionalRule(key, rule);\n  }\n\n  /**\n   * Add a sequential rule for ordered value progression\n   */\n  public addSequentialRule(key: string, values: string[], options: { cycle: boolean } = { cycle: true }): void {\n    this.ruleManager.addSequentialRule(key, values, options);\n  }\n\n  /**\n   * Add a numeric range rule for generating values within specified bounds\n   */\n  public addRangeRule(key: string, config: { min: number; max: number; step?: number; type: 'integer' | 'float' }): void {\n    this.ruleManager.addRangeRule(key, config);\n  }\n\n  /**\n   * Add a template rule for structured text generation with embedded variables\n   */\n  public addTemplateRule(key: string, rule: TemplateRule): void {\n    this.ruleManager.addTemplateRule(key, rule);\n  }\n\n  // Rule checking and removal methods\n  public hasRule(key: string): boolean { return this.ruleManager.hasRule(key); }\n  public removeRule(key: string): boolean { return this.ruleManager.removeRule(key); }\n  public clear(): void { this.ruleManager.clear(); }\n\n  // Specific rule type checks\n  public hasFunctionRule(key: string): boolean { return this.ruleManager.hasFunctionRule(key); }\n  public hasWeightedRule(key: string): boolean { return this.ruleManager.hasWeightedRule(key); }\n  public hasConditionalRule(key: string): boolean { return this.ruleManager.hasConditionalRule(key); }\n  public hasSequentialRule(key: string): boolean { return this.ruleManager.hasSequentialRule(key); }\n  public hasRangeRule(key: string): boolean { return this.ruleManager.hasRangeRule(key); }\n  public hasTemplateRule(key: string): boolean { return this.ruleManager.hasTemplateRule(key); }\n\n  // Specific rule type removal\n  public removeFunctionRule(key: string): boolean { return this.ruleManager.removeFunctionRule(key); }\n  public removeWeightedRule(key: string): boolean { return this.ruleManager.removeWeightedRule(key); }\n  public removeConditionalRule(key: string): boolean { return this.ruleManager.removeConditionalRule(key); }\n  public removeSequentialRule(key: string): boolean { return this.ruleManager.removeSequentialRule(key); }\n  public removeRangeRule(key: string): boolean { return this.ruleManager.removeRangeRule(key); }\n  public removeTemplateRule(key: string): boolean { return this.ruleManager.removeTemplateRule(key); }\n\n  // Clear specific rule types\n  public clearFunctionRules(): void { this.ruleManager.clearFunctionRules(); }\n  public clearWeightedRules(): void { this.ruleManager.clearWeightedRules(); }\n  public clearConditionalRules(): void { this.ruleManager.clearConditionalRules(); }\n  public clearSequentialRules(): void { this.ruleManager.clearSequentialRules(); }\n  public clearRangeRules(): void { this.ruleManager.clearRangeRules(); }\n  public clearTemplateRules(): void { this.ruleManager.clearTemplateRules(); }\n\n  // Special operations\n  public resetSequentialRule(key: string): boolean { return this.ruleManager.resetSequentialRule(key); }\n  public getGrammar(): Grammar { return this.ruleManager.getGrammar(); }\n\n  // ==================== MODIFIER MANAGEMENT ====================\n\n  /**\n   * Add a modifier to the grammar\n   */\n  public addModifier(modifier: Modifier): void {\n    if (!modifier || typeof modifier !== 'object') {\n      throw new Error('Modifier must be an object');\n    }\n    if (!modifier.name || typeof modifier.name !== 'string') {\n      throw new Error('Modifier must have a name');\n    }\n    if (typeof modifier.condition !== 'function') {\n      throw new Error('Modifier must have a condition function');\n    }\n    if (typeof modifier.transform !== 'function') {\n      throw new Error('Modifier must have a transform function');\n    }\n    \n    this.modifiers.set(modifier.name, {\n      ...modifier,\n      priority: modifier.priority ?? 0\n    });\n  }\n\n  /**\n   * Remove a modifier from the grammar\n   */\n  public removeModifier(name: string): boolean {\n    return this.modifiers.delete(name);\n  }\n\n  /**\n   * Check if a modifier exists\n   */\n  public hasModifier(name: string): boolean {\n    return this.modifiers.has(name);\n  }\n\n  /**\n   * Get all modifiers sorted by priority\n   */\n  public getModifiers(): Modifier[] {\n    return Array.from(this.modifiers.values()).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n  }\n\n  /**\n   * Load a modifier into the parser\n   */\n  public loadModifier(modifier: Modifier): void {\n    this.addModifier(modifier);\n  }\n\n  /**\n   * Load multiple modifiers into the parser\n   */\n  public loadModifiers(modifiers: Modifier[]): void {\n    for (const modifier of modifiers) {\n      this.addModifier(modifier);\n    }\n  }\n\n  /**\n   * Clear all modifiers\n   */\n  public clearModifiers(): void {\n    this.modifiers.clear();\n  }\n\n  /**\n   * Clear all rules and modifiers\n   */\n  public clearAll(): void {\n    this.clear();\n    this.clearModifiers();\n  }\n\n  // ==================== PARSING ====================\n\n  /**\n   * Parse and expand variables in text using the configured grammar rules\n   * \n   * This is the core parsing method that processes text containing %variable% placeholders,\n   * replacing them with generated values according to the defined grammar rules.\n   * \n   * @param text - Input text containing %variable% placeholders to expand\n   * @param preserveContext - If true, maintains variable values from previous parse calls\n   * @returns Fully expanded text with all variables replaced and modifiers applied\n   */\n  public parse(text: string, preserveContext: boolean = false): string {\n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    \n    const expanded = this.variableExpander.expandVariables(text, preserveContext);\n    return this.applyModifiers(expanded, { originalText: text });\n  }\n\n  /**\n   * Parse text with performance timing\n   */\n  public parseWithTiming(text: string, preserveContext: boolean = false): ParseTimingResult {\n    const startTime = Date.now();\n    \n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    \n    const expansionStart = Date.now();\n    const expanded = this.variableExpander.expandVariables(text, preserveContext);\n    const expansionEnd = Date.now();\n    \n    const modifierStart = Date.now();\n    const result = this.applyModifiers(expanded, { originalText: text });\n    const modifierEnd = Date.now();\n    \n    const totalEnd = Date.now();\n    \n    return {\n      result,\n      timing: {\n        totalMs: totalEnd - startTime,\n        expansionMs: expansionEnd - expansionStart,\n        modifierMs: modifierEnd - modifierStart\n      }\n    };\n  }\n\n  /**\n   * Parse text with comprehensive error handling and retry logic\n   */\n  public safeParse(text: string, options: ParseOptions = {}): ParseResult {\n    const {\n      preserveContext = false,\n      validateFirst = true,\n      maxAttempts = 3\n    } = options;\n\n    let attempts = 0;\n\n    while (attempts < maxAttempts) {\n      attempts++;\n\n      try {\n        // Validate grammar first if requested\n        if (validateFirst && attempts === 1) {\n          const validation = this.validate();\n          if (!validation.isValid) {\n            let error = 'Validation failed';\n            if (validation.missingRules.length > 0) {\n              error = `Validation failed - missing rules: ${validation.missingRules.join(', ')}`;\n            }\n            return {\n              success: false,\n              error,\n              attempts,\n              validation\n            };\n          }\n        }\n\n        const result = this.parse(text, preserveContext);\n        return {\n          success: true,\n          result,\n          attempts\n        };\n\n      } catch (error) {\n        if (attempts >= maxAttempts) {\n          return {\n            success: false,\n            error: this.errorHandler.getHelpfulError(error as Error, { text }),\n            attempts\n          };\n        }\n\n        // For recursion errors, try reducing max depth\n        if (this.errorHandler['isRecursionError'](error as Error)) {\n          const currentDepth = this.variableExpander.getMaxDepth();\n          this.variableExpander.setMaxDepth(Math.max(10, Math.floor(currentDepth * 0.7)));\n        }\n      }\n    }\n\n    return {\n      success: false,\n      error: 'Maximum attempts exceeded',\n      attempts\n    };\n  }\n\n  /**\n   * Apply all applicable modifiers to text\n   * @private\n   */\n  private applyModifiers(text: string, context?: ModifierContext): string {\n    let modifiedText = text;\n    \n    // Get modifiers sorted by priority (higher priority first)\n    const sortedModifiers = this.getModifiers();\n    \n    for (const modifier of sortedModifiers) {\n      if (modifier.condition(modifiedText, context)) {\n        modifiedText = modifier.transform(modifiedText, context);\n      }\n    }\n    \n    return modifiedText;\n  }\n\n  // ==================== BATCH PROCESSING ====================\n\n  /**\n   * Efficiently process multiple texts with optimized context management\n   */\n  public parseBatch(texts: string[], preserveContext: boolean = true): string[] {\n    if (!Array.isArray(texts)) {\n      throw new Error('Texts must be an array');\n    }\n\n    const results: string[] = [];\n    \n    for (let i = 0; i < texts.length; i++) {\n      const shouldPreserve = preserveContext && i > 0;\n      results.push(this.parse(texts[i], shouldPreserve));\n    }\n    \n    return results;\n  }\n\n  /**\n   * Generate multiple unique variations of text for testing and content creation\n   */\n  public generateVariations(text: string, count: number, seed?: number): string[] {\n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    if (!Number.isInteger(count) || count <= 0) {\n      throw new Error('Count must be a positive integer');\n    }\n\n    const variations: string[] = [];\n    const originalSeed = this.random.getSeed();\n\n    try {\n      for (let i = 0; i < count; i++) {\n        if (seed !== undefined) {\n          this.random.setSeed(seed + i);\n        }\n        variations.push(this.parse(text, false));\n      }\n\n      return variations;\n    } finally {\n      // Restore original seed state\n      if (originalSeed !== null) {\n        this.random.setSeed(originalSeed);\n      } else {\n        this.random.clearSeed();\n      }\n    }\n  }\n\n  // ==================== CONFIGURATION ====================\n\n  /**\n   * Set maximum recursion depth for variable expansion\n   */\n  public setMaxDepth(depth: number): void {\n    this.variableExpander.setMaxDepth(depth);\n  }\n\n  /**\n   * Get the current maximum recursion depth\n   */\n  public getMaxDepth(): number {\n    return this.variableExpander.getMaxDepth();\n  }\n\n  /**\n   * Configure deterministic random number generation for reproducible results\n   */\n  public setRandomSeed(seed: number): void {\n    this.random.setSeed(seed);\n  }\n\n  /**\n   * Clear the random seed and return to using Math.random()\n   */\n  public clearRandomSeed(): void {\n    this.random.clearSeed();\n  }\n\n  /**\n   * Get the current random seed, if any\n   */\n  public getRandomSeed(): number | null {\n    return this.random.getSeed();\n  }\n\n  /**\n   * Clear all reference values and reset context\n   */\n  public clearReferences(): void {\n    this.variableExpander.clearReferences();\n  }\n\n  /**\n   * Get the current context of generated values\n   */\n  public getContext(): { [key: string]: string } {\n    return this.variableExpander.getContext();\n  }\n\n  // ==================== ANALYSIS ====================\n\n  /**\n   * Calculate the complexity (number of possible outcomes) for a specific rule\n   */\n  public calculateRuleComplexity(ruleKey: string, visited: Set<string> = new Set(), maxDepth: number = 50): ComplexityResult {\n    return this.complexityAnalyzer.calculateRuleComplexity(ruleKey, visited, maxDepth);\n  }\n\n  /**\n   * Calculate total complexity across all rules in the grammar\n   */\n  public calculateTotalComplexity(maxDepth: number = 50): TotalComplexityResult {\n    return this.complexityAnalyzer.calculateTotalComplexity(maxDepth);\n  }\n\n  /**\n   * Calculate probability analysis for a specific rule\n   */\n  public calculateProbabilities(ruleKey: string, maxDepth: number = 50, maxOutcomes: number = 1000): ProbabilityAnalysis {\n    return this.probabilityAnalyzer.calculateProbabilities(ruleKey, maxDepth, maxOutcomes);\n  }\n\n  /**\n   * Get the most probable outcome for a rule\n   */\n  public getMostProbableOutcome(ruleKey: string, maxDepth: number = 50, maxOutcomes: number = 1000): ProbabilityResult | null {\n    return this.probabilityAnalyzer.getMostProbableOutcome(ruleKey, maxDepth, maxOutcomes);\n  }\n\n  /**\n   * Get the least probable outcome for a rule\n   */\n  public getLeastProbableOutcome(ruleKey: string, maxDepth: number = 50, maxOutcomes: number = 1000): ProbabilityResult | null {\n    return this.probabilityAnalyzer.getLeastProbableOutcome(ruleKey, maxDepth, maxOutcomes);\n  }\n\n  // ==================== VALIDATION ====================\n\n  /**\n   * Perform comprehensive grammar validation to detect potential issues\n   */\n  public validate(): ValidationResult {\n    return this.validator.validate();\n  }\n\n  /**\n   * Get all variable names found in a text string\n   */\n  public findVariables(text: string): string[] {\n    return this.variableExpander.findVariables(text);\n  }\n\n  /**\n   * Generate helpful error messages with contextual suggestions\n   */\n  public getHelpfulError(error: Error, context?: ErrorContext): string {\n    return this.errorHandler.getHelpfulError(error, context);\n  }\n\n  // ==================== STATISTICS AND UTILITIES ====================\n\n  /**\n   * Get comprehensive performance statistics and configuration metrics\n   */\n  public getStats(): ParserStats {\n    const ruleStats = this.ruleManager.getStats();\n    \n    return {\n      totalRules: ruleStats.total,\n      rulesByType: {\n        static: ruleStats.static,\n        function: ruleStats.function,\n        weighted: ruleStats.weighted,\n        conditional: ruleStats.conditional,\n        sequential: ruleStats.sequential,\n        range: ruleStats.range,\n        template: ruleStats.template\n      },\n      totalModifiers: this.modifiers.size,\n      maxDepth: this.getMaxDepth(),\n      hasRandomSeed: this.random.getSeed() !== null\n    };\n  }\n\n  /**\n   * Create a lightweight copy of the parser for parallel processing or experimentation\n   */\n  public clone(): Parser {\n    const cloned = new Parser();\n    \n    // Copy static rules\n    const grammar = this.getGrammar();\n    cloned.addRules(grammar);\n    \n    // Copy settings\n    cloned.setMaxDepth(this.getMaxDepth());\n    const seed = this.getRandomSeed();\n    if (seed !== null) {\n      cloned.setRandomSeed(seed);\n    }\n    \n    // Copy modifiers\n    const modifiers = this.getModifiers();\n    cloned.loadModifiers(modifiers);\n    \n    return cloned;\n  }\n\n  // ==================== PLACEHOLDER METHODS ====================\n  // These methods are included for compatibility but may not be fully implemented\n\n  /**\n   * Export the parser configuration as JSON\n   */\n  public exportConfig(): ParserConfig {\n    // Placeholder implementation\n    return {\n      grammar: this.getGrammar(),\n      modifiers: this.getModifiers().map(m => m.name),\n      settings: {\n        maxDepth: this.getMaxDepth(),\n        randomSeed: this.getRandomSeed()\n      }\n    };\n  }\n\n  /**\n   * Optimize the parser for better performance\n   */\n  public optimize(): OptimizationReport {\n    const validation = this.validate();\n    const warnings = [...validation.warnings];\n    const suggestions = [];\n    \n    // Add optimization-specific warnings and suggestions\n    if (this.variableExpander.getMaxDepth() > 20) {\n      suggestions.push('Consider reducing max depth for better performance.');\n    }\n    \n    // Check modifier count\n    if (this.modifiers.size >= 15) {\n      warnings.push(`Many modifiers (${this.modifiers.size}). High-priority modifiers run first.`);\n    }\n    \n    suggestions.push(...validation.missingRules.concat(validation.circularReferences));\n    \n    return {\n      warnings,\n      suggestions,\n      optimized: false // Always false for now since we don't actually optimize\n    };\n  }\n\n  /**\n   * Analyze grammar complexity, performance characteristics, and usage patterns\n   */\n  public analyzeRules(ruleName?: string): RuleAnalysis {\n    if (ruleName) {\n      const complexity = this.calculateRuleComplexity(ruleName);\n      return {\n        totalComplexity: complexity.complexity,\n        averageDepth: complexity.depth,\n        mostComplex: [complexity.ruleName],\n        suggestions: complexity.warnings,\n        ruleDetails: {\n          name: complexity.ruleName,\n          type: complexity.ruleType,\n          complexity: complexity.complexity,\n          variables: complexity.variables,\n          depth: complexity.depth\n        }\n      };\n    } else {\n      const totalComplexity = this.calculateTotalComplexity();\n      const suggestions = [...totalComplexity.warnings];\n      \n      // Add analysis-based suggestions\n      const totalRules = Object.keys(this.ruleManager.getGrammar()).length;\n      if (totalRules > 50) {\n        suggestions.push('Large number of rules - consider organizing into groups');\n      }\n      \n      if (totalComplexity.totalComplexity > 100) {\n        suggestions.push('High total complexity - consider simplifying rules');\n      }\n      \n      return {\n        totalComplexity: totalComplexity.totalComplexity,\n        averageDepth: totalComplexity.averageComplexity,\n        mostComplex: totalComplexity.mostComplexRules.map(r => r.ruleName),\n        suggestions\n      };\n    }\n  }\n}","/**\n * Complexity analysis for grammar rules\n */\nimport { \n  ComplexityResult, \n  TotalComplexityResult \n} from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { VariableExpander } from '../core/VariableExpander.js';\n\nexport class ComplexityAnalyzer {\n  constructor(\n    private ruleManager: RuleManager,\n    private variableExpander: VariableExpander\n  ) {}\n\n  /**\n   * Calculate the complexity (number of possible outcomes) for a specific rule\n   * \n   * This method analyzes a single rule and calculates how many different possible\n   * values it can generate, taking into account nested variables and rule dependencies.\n   * \n   * @param ruleKey - The name of the rule to analyze\n   * @param visited - Internal set to track visited rules (prevents infinite recursion)\n   * @param maxDepth - Maximum recursion depth to prevent stack overflow (default: 50)\n   * \n   * @returns ComplexityResult containing detailed analysis of the rule's complexity\n   * \n   * @throws {Error} If the rule does not exist\n   */\n  public calculateRuleComplexity(\n    ruleKey: string, \n    visited: Set<string> = new Set(), \n    maxDepth: number = 50\n  ): ComplexityResult {\n    const warnings: string[] = [];\n    const variables: Set<string> = new Set();\n    let ruleType = 'unknown';\n    let complexity = 1;\n    let isFinite = true;\n    \n    // Check if rule exists\n    if (!this.ruleManager.hasRule(ruleKey)) {\n      throw new Error(`Rule '${ruleKey}' does not exist`);\n    }\n    \n    // Check for circular references\n    if (visited.has(ruleKey)) {\n      warnings.push(`Circular reference detected for rule '${ruleKey}'`);\n      return {\n        ruleName: ruleKey,\n        complexity: 1,\n        ruleType: 'circular',\n        isFinite: true,\n        variables: [],\n        depth: visited.size,\n        warnings\n      };\n    }\n    \n    // Check maximum depth\n    if (visited.size >= maxDepth) {\n      warnings.push(`Maximum depth (${maxDepth}) reached, complexity may be underestimated`);\n      return {\n        ruleName: ruleKey,\n        complexity: 1,\n        ruleType: 'max-depth',\n        isFinite: true,\n        variables: [],\n        depth: visited.size,\n        warnings\n      };\n    }\n    \n    const newVisited = new Set(visited);\n    newVisited.add(ruleKey);\n    \n    // Determine rule type and calculate complexity\n    const type = this.ruleManager.getRuleType(ruleKey);\n    ruleType = type || 'unknown';\n    \n    switch (type) {\n      case 'static':\n        complexity = this.calculateStaticRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'weighted':\n        complexity = this.calculateWeightedRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'function':\n        complexity = Number.POSITIVE_INFINITY;\n        isFinite = false;\n        warnings.push(`Function rule '${ruleKey}' has infinite complexity (cannot be calculated)`);\n        break;\n      case 'conditional':\n        complexity = this.calculateConditionalRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'sequential':\n        complexity = this.calculateSequentialRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'range':\n        complexity = this.calculateRangeRuleComplexity(ruleKey);\n        break;\n      case 'template':\n        complexity = this.calculateTemplateRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      default:\n        warnings.push(`Unknown rule type for '${ruleKey}'`);\n        complexity = 1;\n    }\n    \n    return {\n      ruleName: ruleKey,\n      complexity,\n      ruleType,\n      isFinite,\n      variables: Array.from(variables),\n      depth: visited.size,\n      warnings\n    };\n  }\n\n  /**\n   * Calculate total complexity across all rules in the grammar\n   */\n  public calculateTotalComplexity(maxDepth: number = 50): TotalComplexityResult {\n    const allRuleKeys = this.ruleManager.getAllKeys();\n    const complexityByRule: ComplexityResult[] = [];\n    const warnings: string[] = [];\n    const circularReferences: string[] = [];\n    let totalComplexity = 0;\n    let isFinite = true;\n\n    // Calculate complexity for each rule\n    for (const ruleKey of allRuleKeys) {\n      try {\n        const result = this.calculateRuleComplexity(ruleKey, new Set(), maxDepth);\n        complexityByRule.push(result);\n        \n        if (!result.isFinite) {\n          isFinite = false;\n        } else {\n          totalComplexity += result.complexity;\n        }\n        \n        warnings.push(...result.warnings);\n        \n        if (result.warnings.some(w => w.includes('Circular reference'))) {\n          circularReferences.push(ruleKey);\n        }\n      } catch (error) {\n        warnings.push(`Error calculating complexity for rule '${ruleKey}': ${error}`);\n        complexityByRule.push({\n          ruleName: ruleKey,\n          complexity: 1,\n          ruleType: 'error',\n          isFinite: true,\n          variables: [],\n          depth: 0,\n          warnings: [`Error: ${error}`]\n        });\n      }\n    }\n\n    // Remove duplicate warnings\n    const uniqueWarnings = Array.from(new Set(warnings));\n    const uniqueCircularRefs = Array.from(new Set(circularReferences));\n\n    // Sort rules by complexity (descending)\n    const sortedByComplexity = [...complexityByRule]\n      .filter(r => r.isFinite)\n      .sort((a, b) => b.complexity - a.complexity);\n\n    // Get top 5 most complex rules\n    const mostComplexRules = sortedByComplexity.slice(0, 5);\n\n    // Calculate average complexity (only finite rules)\n    const finiteRules = complexityByRule.filter(r => r.isFinite);\n    const averageComplexity = finiteRules.length > 0 \n      ? finiteRules.reduce((sum, r) => sum + r.complexity, 0) / finiteRules.length \n      : 0;\n\n    return {\n      totalComplexity: isFinite ? totalComplexity : Number.POSITIVE_INFINITY,\n      isFinite,\n      ruleCount: allRuleKeys.length,\n      complexityByRule,\n      averageComplexity,\n      mostComplexRules,\n      warnings: uniqueWarnings,\n      circularReferences: uniqueCircularRefs\n    };\n  }\n\n  /**\n   * Calculate complexity for static grammar rules\n   */\n  private calculateStaticRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getGrammar()[ruleKey];\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const value of rule) {\n      const valueVariables = this.variableExpander.findVariables(value);\n      \n      if (valueVariables.length === 0) {\n        // Literal string\n        totalComplexity += 1;\n      } else {\n        // Calculate complexity by multiplying all variable complexities\n        let valueComplexity = 1;\n        for (const variable of valueVariables) {\n          variables.add(variable);\n          if (visited.has(variable)) {\n            // Circular reference detected during recursion\n            warnings.push(`Circular reference detected for rule '${variable}'`);\n            valueComplexity *= 1; // Treat as single possibility to avoid infinite recursion\n          } else if (visited.size >= maxDepth) {\n            // Max depth reached during recursion\n            warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n            valueComplexity *= 1; // Treat as single possibility\n          } else if (this.ruleManager.hasRule(variable)) {\n            const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n            if (!varResult.isFinite) {\n              return Number.POSITIVE_INFINITY;\n            }\n            valueComplexity *= varResult.complexity;\n            warnings.push(...varResult.warnings);\n          } else {\n            warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n            valueComplexity *= 1; // Treat as single possibility\n          }\n        }\n        totalComplexity += valueComplexity;\n      }\n    }\n    \n    return totalComplexity;\n  }\n\n  /**\n   * Calculate complexity for weighted rules\n   */\n  private calculateWeightedRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getWeightedRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const value of rule.values) {\n      const valueVariables = this.variableExpander.findVariables(value);\n      \n      if (valueVariables.length === 0) {\n        totalComplexity += 1;\n      } else {\n        let valueComplexity = 1;\n        for (const variable of valueVariables) {\n          variables.add(variable);\n          if (visited.has(variable)) {\n            warnings.push(`Circular reference detected for rule '${variable}'`);\n            valueComplexity *= 1;\n          } else if (visited.size >= maxDepth) {\n            warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n            valueComplexity *= 1;\n          } else if (this.ruleManager.hasRule(variable)) {\n            const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n            if (!varResult.isFinite) {\n              return Number.POSITIVE_INFINITY;\n            }\n            valueComplexity *= varResult.complexity;\n            warnings.push(...varResult.warnings);\n          } else {\n            warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n            valueComplexity *= 1;\n          }\n        }\n        totalComplexity += valueComplexity;\n      }\n    }\n    \n    return totalComplexity;\n  }\n\n    /**\n   * Calculate complexity for conditional rules\n   */\n  private calculateConditionalRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getConditionalRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const condition of rule.conditions) {\n      let conditionComplexity = 0;\n      \n      // Process values in 'then' or 'default' array\n      const values = condition.then || condition.default || [];\n      \n      for (const value of values) {\n        const valueVariables = this.variableExpander.findVariables(value);\n        \n        if (valueVariables.length === 0) {\n          conditionComplexity += 1;\n        } else {\n          let valueComplexity = 1;\n          for (const variable of valueVariables) {\n            variables.add(variable);\n            if (visited.has(variable)) {\n              warnings.push(`Circular reference detected for rule '${variable}'`);\n              valueComplexity *= 1;\n            } else if (visited.size >= maxDepth) {\n              warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n              valueComplexity *= 1;\n            } else if (this.ruleManager.hasRule(variable)) {\n              const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n              if (!varResult.isFinite) {\n                return Number.POSITIVE_INFINITY;\n              }\n              valueComplexity *= varResult.complexity;\n              warnings.push(...varResult.warnings);\n            } else {\n              warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n              valueComplexity *= 1;\n            }\n          }\n          conditionComplexity += valueComplexity;\n        }\n      }\n      \n      totalComplexity += conditionComplexity;\n    }\n    \n    return totalComplexity;\n  }\n\n    /**\n   * Calculate complexity for sequential rules\n   */\n  private calculateSequentialRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getSequentialRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const value of rule.values) {\n      const valueVariables = this.variableExpander.findVariables(value);\n      \n      if (valueVariables.length === 0) {\n        totalComplexity += 1;\n      } else {\n        let valueComplexity = 1;\n        for (const variable of valueVariables) {\n          variables.add(variable);\n          if (visited.has(variable)) {\n            warnings.push(`Circular reference detected for rule '${variable}'`);\n            valueComplexity *= 1;\n          } else if (visited.size >= maxDepth) {\n            warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n            valueComplexity *= 1;\n          } else if (this.ruleManager.hasRule(variable)) {\n            const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n            if (!varResult.isFinite) {\n              return Number.POSITIVE_INFINITY;\n            }\n            valueComplexity *= varResult.complexity;\n            warnings.push(...varResult.warnings);\n          } else {\n            warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n            valueComplexity *= 1;\n          }\n        }\n        totalComplexity += valueComplexity;\n      }\n    }\n    \n    return totalComplexity;\n  }\n\n  /**\n   * Calculate complexity for range rules\n   */\n  private calculateRangeRuleComplexity(ruleKey: string): number {\n    const rule = this.ruleManager.getRangeRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    // For range rules, complexity is the number of possible values\n    const step = rule.step || 1;\n    const possibleValues = Math.floor((rule.max - rule.min) / step) + 1;\n    \n    return possibleValues;\n  }\n\n  /**\n   * Calculate complexity for template rules\n   */\n  private calculateTemplateRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getTemplateRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 1;\n    \n    // Find all variables in the template\n    const templateVariables = this.variableExpander.findVariables(rule.template);\n    \n    for (const variable of templateVariables) {\n      variables.add(variable);\n      \n      // Check if this variable has values defined in the template rule\n      if (rule.variables[variable]) {\n        const values = rule.variables[variable];\n        let variableComplexity = 0;\n        \n        for (const value of values) {\n          const valueVariables = this.variableExpander.findVariables(value);\n          \n          if (valueVariables.length === 0) {\n            variableComplexity += 1;\n          } else {\n            let valueComplexity = 1;\n            for (const nestedVariable of valueVariables) {\n              variables.add(nestedVariable);\n              if (visited.has(nestedVariable)) {\n                warnings.push(`Circular reference detected for rule '${nestedVariable}'`);\n                valueComplexity *= 1;\n              } else if (visited.size >= maxDepth) {\n                warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${nestedVariable}', complexity may be underestimated`);\n                valueComplexity *= 1;\n              } else if (this.ruleManager.hasRule(nestedVariable)) {\n                const varResult = this.calculateRuleComplexity(nestedVariable, visited, maxDepth);\n                if (!varResult.isFinite) {\n                  return Number.POSITIVE_INFINITY;\n                }\n                valueComplexity *= varResult.complexity;\n                warnings.push(...varResult.warnings);\n              } else {\n                warnings.push(`Missing rule '${nestedVariable}' referenced in '${ruleKey}'`);\n                valueComplexity *= 1;\n              }\n            }\n            variableComplexity += valueComplexity;\n          }\n        }\n        \n        totalComplexity *= variableComplexity;\n      } else if (this.ruleManager.hasRule(variable)) {\n        // Variable references another rule\n        if (visited.has(variable)) {\n          warnings.push(`Circular reference detected for rule '${variable}'`);\n          totalComplexity *= 1;\n        } else if (visited.size >= maxDepth) {\n          warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n          totalComplexity *= 1;\n        } else {\n          const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n          if (!varResult.isFinite) {\n            return Number.POSITIVE_INFINITY;\n          }\n          totalComplexity *= varResult.complexity;\n          warnings.push(...varResult.warnings);\n        }\n      } else {\n        warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n        totalComplexity *= 1;\n      }\n    }\n    \n    return totalComplexity;\n  }\n}","/**\n * Probability analysis for grammar rules\n */\nimport { \n  ProbabilityAnalysis, \n  ProbabilityResult,\n  ProbabilityNode\n} from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { VariableExpander } from '../core/VariableExpander.js';\n\nexport class ProbabilityAnalyzer {\n  constructor(\n    private ruleManager: RuleManager,\n    private variableExpander: VariableExpander\n  ) {}\n\n  /**\n   * Create a proper ProbabilityResult object\n   * @private\n   */\n  private createProbabilityResult(\n    outcome: string, \n    probability: number, \n    variables: string[] = [],\n    probabilityTree: ProbabilityResult['probabilityTree'] = []\n  ): ProbabilityResult {\n    return { outcome, probability, variables, probabilityTree };\n  }\n\n  /**\n   * Calculate probability analysis for a specific rule\n   * \n   * This method analyzes all possible outcomes of a rule and calculates the probability\n   * of each outcome occurring. It considers weighted rules, nested variables, and\n   * rule dependencies to provide accurate probability distributions.\n   * \n   * @param ruleKey - The name of the rule to analyze\n   * @param maxDepth - Maximum recursion depth to prevent stack overflow (default: 50)\n   * @param maxOutcomes - Maximum number of outcomes to calculate (default: 1000)\n   * \n   * @returns ProbabilityAnalysis with detailed probability information\n   * \n   * @throws {Error} If the rule does not exist\n   */\n  public calculateProbabilities(\n    ruleKey: string, \n    maxDepth: number = 50, \n    maxOutcomes: number = 1000\n  ): ProbabilityAnalysis {\n    if (!this.ruleManager.hasRule(ruleKey)) {\n      throw new Error(`Rule '${ruleKey}' does not exist`);\n    }\n\n    const warnings: string[] = [];\n    const outcomes = this.calculateRuleProbabilities(ruleKey, new Set(), maxDepth, maxOutcomes, warnings);\n    \n    if (outcomes.length === 0) {\n      return {\n        ruleName: ruleKey,\n        outcomes: [],\n        totalOutcomes: 0,\n        mostProbable: [],\n        leastProbable: [],\n        averageProbability: 0,\n        entropy: 0,\n        isFinite: true,\n        warnings\n      };\n    }\n\n    // Sort by probability (descending)\n    const sortedOutcomes = outcomes.sort((a, b) => b.probability - a.probability);\n    \n    // Calculate entropy: H = -Σ(p * log2(p))\n    const entropy = outcomes.reduce((sum, outcome) => {\n      if (outcome.probability > 0) {\n        return sum - (outcome.probability * Math.log2(outcome.probability));\n      }\n      return sum;\n    }, 0);\n\n    // Get top 10 most and least probable\n    const mostProbable = sortedOutcomes.slice(0, 10);\n    const leastProbable = sortedOutcomes.slice(-10).reverse();\n    \n    // Calculate average probability\n    const averageProbability = outcomes.length > 0 \n      ? outcomes.reduce((sum, o) => sum + o.probability, 0) / outcomes.length \n      : 0;\n\n    return {\n      ruleName: ruleKey,\n      outcomes: sortedOutcomes,\n      totalOutcomes: outcomes.length,\n      mostProbable,\n      leastProbable,\n      averageProbability,\n      entropy,\n      isFinite: true,\n      warnings\n    };\n  }\n\n  /**\n   * Get the most probable outcome for a rule\n   */\n  public getMostProbableOutcome(\n    ruleKey: string, \n    maxDepth: number = 50, \n    maxOutcomes: number = 1000\n  ): ProbabilityResult | null {\n    const analysis = this.calculateProbabilities(ruleKey, maxDepth, maxOutcomes);\n    return analysis.mostProbable[0] || null;\n  }\n\n  /**\n   * Get the least probable outcome for a rule\n   */\n  public getLeastProbableOutcome(\n    ruleKey: string, \n    maxDepth: number = 50, \n    maxOutcomes: number = 1000\n  ): ProbabilityResult | null {\n    const analysis = this.calculateProbabilities(ruleKey, maxDepth, maxOutcomes);\n    return analysis.leastProbable[0] || null;\n  }\n\n  /**\n   * Calculate probabilities for a specific rule (recursive helper)\n   * @private\n   */\n  private calculateRuleProbabilities(\n    ruleKey: string,\n    visited: Set<string>,\n    maxDepth: number,\n    maxOutcomes: number,\n    warnings: string[]\n  ): ProbabilityResult[] {\n    // Check for circular references and depth limits\n    if (visited.has(ruleKey)) {\n      warnings.push(`Circular reference detected for rule '${ruleKey}'`);\n      return [this.createProbabilityResult(ruleKey, 1.0)];\n    }\n    \n    if (visited.size >= maxDepth) {\n      warnings.push(`Maximum depth (${maxDepth}) reached for rule '${ruleKey}'`);\n      return [this.createProbabilityResult(ruleKey, 1.0)];\n    }\n\n    const newVisited = new Set(visited);\n    newVisited.add(ruleKey);\n\n    const ruleType = this.ruleManager.getRuleType(ruleKey);\n    \n    switch (ruleType) {\n      case 'static':\n        return this.calculateStaticRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'weighted':\n        return this.calculateWeightedRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'range':\n        return this.calculateRangeRuleProbabilities(ruleKey);\n      case 'template':\n        return this.calculateTemplateRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'sequential':\n        return this.calculateSequentialRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'conditional':\n        return this.calculateConditionalRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'function':\n        warnings.push(`Function rule '${ruleKey}' has dynamic outcomes - cannot calculate exact probabilities`);\n        return [this.createProbabilityResult(`[function:${ruleKey}]`, 1.0)];\n      default:\n        warnings.push(`Unknown rule type for '${ruleKey}'`);\n        return [this.createProbabilityResult(ruleKey, 1.0)];\n    }\n  }\n\n  /**\n   * Calculate probabilities for static rules\n   * @private\n   */\n  private calculateStaticRuleProbabilities(\n    ruleKey: string,\n    visited: Set<string>,\n    maxDepth: number,\n    maxOutcomes: number,\n    warnings: string[]\n  ): ProbabilityResult[] {\n    const rule = this.ruleManager.getGrammar()[ruleKey];\n    if (!rule || rule.length === 0) {\n      return [];\n    }\n\n    const outcomes: ProbabilityResult[] = [];\n    const baseProb = 1.0 / rule.length; // Equal probability for each value\n\n    for (const value of rule) {\n      const variables = this.variableExpander.findVariables(value);\n      \n      if (variables.length === 0) {\n        // Simple literal value\n        outcomes.push(this.createProbabilityResult(value, baseProb));\n      } else {\n        // Expand variables with probabilities\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          value, variables, baseProb, visited, maxDepth, maxOutcomes, warnings\n        );\n        outcomes.push(...expandedOutcomes);\n      }\n\n      if (outcomes.length >= maxOutcomes) {\n        warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n        break;\n      }\n    }\n\n    return outcomes;\n  }\n\n  // Placeholder methods for other rule types\n  private calculateWeightedRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getWeightedRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const totalWeight = rule.weights.reduce((sum: number, weight: number) => sum + weight, 0);\n    \n    for (let i = 0; i < rule.values.length; i++) {\n      const value = rule.values[i];\n      const weight = rule.weights[i];\n      const probability = weight / totalWeight;\n      \n      const variables = this.variableExpander.findVariables(value);\n      \n      if (variables.length === 0) {\n        outcomes.push(this.createProbabilityResult(value, probability));\n      } else {\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          value, variables, probability, visited, maxDepth, maxOutcomes, warnings\n        );\n        outcomes.push(...expandedOutcomes);\n      }\n      \n      if (outcomes.length >= maxOutcomes) {\n        warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n        break;\n      }\n    }\n    \n    return outcomes;\n  }\n\n  private calculateRangeRuleProbabilities(ruleKey: string): ProbabilityResult[] {\n    const rule = this.ruleManager.getRangeRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const step = rule.step || 1;\n    const possibleValues = Math.floor((rule.max - rule.min) / step) + 1;\n    const probability = 1.0 / possibleValues;\n    \n    for (let value = rule.min; value <= rule.max; value += step) {\n      const outcome = rule.type === 'integer' ? value.toString() : value.toFixed(2);\n      outcomes.push(this.createProbabilityResult(outcome, probability));\n    }\n    \n    return outcomes;\n  }\n\n  private calculateTemplateRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getTemplateRuleData(ruleKey);\n    if (!rule) return [];\n    \n    // Start with the template\n    let currentOutcomes = [{ value: rule.template, probability: 1.0 }];\n    \n    // Expand each variable in the template\n    for (const [varName, values] of Object.entries(rule.variables) as [string, string[]][]) {\n      const newOutcomes: { value: string; probability: number }[] = [];\n      const valueProbability = 1.0 / values.length;\n      \n      for (const currentOutcome of currentOutcomes) {\n        for (const value of values) {\n          // Replace the variable in the template\n          const expandedValue = currentOutcome.value.replace(\n            new RegExp(`%${varName}%`, 'g'), \n            value\n          );\n          \n          // Check if this value has nested variables\n          const nestedVariables = this.variableExpander.findVariables(value);\n          if (nestedVariables.length > 0) {\n            // Recursively expand nested variables\n            const nestedOutcomes = this.expandVariablesWithProbabilities(\n              expandedValue, nestedVariables, currentOutcome.probability * valueProbability,\n              visited, maxDepth, maxOutcomes, warnings\n            );\n            for (const nestedOutcome of nestedOutcomes) {\n              newOutcomes.push({\n                value: nestedOutcome.outcome,\n                probability: nestedOutcome.probability\n              });\n            }\n          } else {\n            newOutcomes.push({\n              value: expandedValue,\n              probability: currentOutcome.probability * valueProbability\n            });\n          }\n          \n          if (newOutcomes.length >= maxOutcomes) {\n            warnings.push(`Maximum outcomes (${maxOutcomes}) reached for template rule '${ruleKey}'`);\n            break;\n          }\n        }\n        if (newOutcomes.length >= maxOutcomes) break;\n      }\n      \n      currentOutcomes = newOutcomes;\n      if (currentOutcomes.length >= maxOutcomes) break;\n    }\n    \n    // Handle any remaining variables that aren't in the local variables object\n    const remainingVariables = this.variableExpander.findVariables(currentOutcomes[0]?.value || '');\n    if (remainingVariables.length > 0) {\n      const finalOutcomes: { value: string; probability: number }[] = [];\n      \n      for (const outcome of currentOutcomes) {\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          outcome.value, remainingVariables, outcome.probability,\n          visited, maxDepth, maxOutcomes, warnings\n        );\n        for (const expanded of expandedOutcomes) {\n          finalOutcomes.push({\n            value: expanded.outcome,\n            probability: expanded.probability\n          });\n        }\n        \n        if (finalOutcomes.length >= maxOutcomes) break;\n      }\n      \n      currentOutcomes = finalOutcomes;\n    }\n    \n    // Convert to ProbabilityResult format\n    return currentOutcomes.map(outcome => \n      this.createProbabilityResult(outcome.value, outcome.probability)\n    );\n  }\n\n  private calculateSequentialRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getSequentialRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const baseProb = 1.0 / rule.values.length;\n    \n    for (const value of rule.values) {\n      const variables = this.variableExpander.findVariables(value);\n      \n      if (variables.length === 0) {\n        outcomes.push(this.createProbabilityResult(value, baseProb));\n      } else {\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          value, variables, baseProb, visited, maxDepth, maxOutcomes, warnings\n        );\n        outcomes.push(...expandedOutcomes);\n      }\n      \n      if (outcomes.length >= maxOutcomes) {\n        warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n        break;\n      }\n    }\n    \n    return outcomes;\n  }\n\n  private calculateConditionalRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getConditionalRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const conditionProbability = 1.0 / rule.conditions.length; // Equal probability for each condition\n    \n    for (const condition of rule.conditions) {\n      const values = condition.then || condition.default || [];\n      const valueProbability = conditionProbability / values.length;\n      \n      for (const value of values) {\n        const variables = this.variableExpander.findVariables(value);\n        \n        if (variables.length === 0) {\n          outcomes.push(this.createProbabilityResult(value, valueProbability));\n        } else {\n          const expandedOutcomes = this.expandVariablesWithProbabilities(\n            value, variables, valueProbability, visited, maxDepth, maxOutcomes, warnings\n          );\n          outcomes.push(...expandedOutcomes);\n        }\n        \n        if (outcomes.length >= maxOutcomes) {\n          warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n          break;\n        }\n      }\n      \n      if (outcomes.length >= maxOutcomes) break;\n    }\n    \n    return outcomes;\n  }\n\n  /**\n   * Expand variables in a value with probability calculations\n   * @private\n   */\n  private expandVariablesWithProbabilities(\n    value: string,\n    variables: string[],\n    baseProbability: number,\n    visited: Set<string>,\n    maxDepth: number,\n    maxOutcomes: number,\n    warnings: string[]\n  ): ProbabilityResult[] {\n    if (variables.length === 0) {\n      return [this.createProbabilityResult(value, baseProbability)];\n    }\n    \n    // Start with the original value and expand one variable at a time\n    let currentOutcomes: Array<{ \n      value: string; \n      probability: number; \n      probabilityTree?: ProbabilityNode[] \n    }> = [{ value, probability: baseProbability }];\n    \n    for (const variable of variables) {\n      const newOutcomes: Array<{ \n        value: string; \n        probability: number; \n        probabilityTree?: ProbabilityNode[] \n      }> = [];\n      \n      // Handle special cases\n      if (visited.has(variable)) {\n        warnings.push(`Circular reference detected for rule '${variable}'`);\n        // Replace with circular marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[circular:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      if (visited.size >= maxDepth) {\n        warnings.push(`Maximum depth (${maxDepth}) reached for rule '${variable}'`);\n        // Replace with max-depth marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[max-depth:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      if (!this.ruleManager.hasRule(variable)) {\n        warnings.push(`Missing rule '${variable}' referenced in expansion`);\n        // Replace with missing marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[missing:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      // Get probabilities for this variable\n      const ruleType = this.ruleManager.getRuleType(variable);\n      if (ruleType === 'function') {\n        warnings.push(`Function rule '${variable}' has dynamic outcomes - cannot calculate exact probabilities`);\n        // Replace with function marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[function:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      // Recursively get probabilities for this variable\n      const variableProbabilities = this.calculateRuleProbabilities(\n        variable, new Set(visited), maxDepth, maxOutcomes, warnings\n      );\n      \n      // Expand each current outcome with each variable possibility\n      for (const currentOutcome of currentOutcomes) {\n        for (const varOutcome of variableProbabilities) {\n          const expandedValue = currentOutcome.value.replace(\n            new RegExp(`%${variable}%`, 'g'), \n            varOutcome.outcome\n          );\n          const combinedProbability = currentOutcome.probability * varOutcome.probability;\n          \n          // Create probability tree node for this variable expansion\n          const probabilityNode = {\n            ruleName: variable,\n            value: varOutcome.outcome,\n            probability: varOutcome.probability,\n            children: varOutcome.probabilityTree || []\n          };\n          \n          newOutcomes.push({\n            value: expandedValue,\n            probability: combinedProbability,\n            probabilityTree: [probabilityNode]\n          });\n          \n          if (newOutcomes.length >= maxOutcomes) {\n            warnings.push(`Maximum outcomes (${maxOutcomes}) reached during expansion`);\n            break;\n          }\n        }\n        if (newOutcomes.length >= maxOutcomes) break;\n      }\n      \n      currentOutcomes = newOutcomes;\n      if (currentOutcomes.length >= maxOutcomes) break;\n    }\n    \n    // Convert to ProbabilityResult format\n    return currentOutcomes.map(outcome => \n      this.createProbabilityResult(\n        outcome.value, \n        outcome.probability, \n        variables,\n        outcome.probabilityTree || []\n      )\n    );\n  }\n}","/**\n * Error handling and helpful error message generation\n */\nimport { ErrorContext } from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { GrammarValidator } from '../validation/GrammarValidator.js';\n\nexport class ErrorHandler {\n  constructor(\n    private ruleManager: RuleManager,\n    private validator: GrammarValidator\n  ) {}\n\n  /**\n   * Generate helpful error messages with contextual suggestions and debugging information\n   * \n   * This method analyzes parsing errors and provides intelligent suggestions for resolving\n   * common issues. It examines the error type, parsing context, and grammar state to offer\n   * specific, actionable advice for fixing problems.\n   * \n   * @param error - The error object that was thrown during parsing\n   * @param context - Optional additional context for better error analysis\n   * @returns Enhanced error message with suggestions, validation info, and debugging tips\n   */\n  public getHelpfulError(error: Error, context?: ErrorContext): string {\n    const lines: string[] = [];\n    \n    // Start with the original error message\n    lines.push(error.message);\n    lines.push('');\n    \n    // Analyze error type and provide specific suggestions\n    if (this.isRecursionError(error)) {\n      lines.push('Suggestions:');\n      lines.push('• Check for circular references in your grammar rules');\n      lines.push('• Use validate() method to detect circular dependencies');\n      lines.push('• Consider increasing maxDepth if your grammar is legitimately deep');\n      lines.push('• Try reducing the maxDepth with setMaxDepth()');\n      lines.push('• Use @variable syntax to reference previously generated values');\n      \n      // Add rule-specific context if available\n      if (context?.ruleName) {\n        lines.push('');\n        lines.push(`Rule name: ${context.ruleName}`);\n        lines.push(`The rule '${context.ruleName}' may be causing infinite recursion`);\n      }\n    } else if (this.isFunctionRuleError(error)) {\n      lines.push('Suggestions:');\n      lines.push('• Function rules must return string arrays');\n      lines.push('• Check that your function rule returns an array of strings');\n      lines.push('• Check your function rule implementation');\n      lines.push('• Ensure function doesn\\'t throw exceptions');\n      lines.push('• Add error handling within your function rule');\n      lines.push('• Test function rule independently before adding to parser');\n    } else if (this.isWeightError(error)) {\n      lines.push('Suggestions:');\n      lines.push('• Ensure all weights are positive numbers');\n      lines.push('• Verify that weights sum to exactly 1.0');\n      lines.push('• Ensure all weights in weighted rules add up to exactly 1.0');\n      lines.push('• Check that values and weights arrays have the same length');\n      lines.push('• Use helper: weights = [0.5, 0.3, 0.2] for three items');\n    } else if (this.isMissingRuleError(error)) {\n      lines.push('Suggestions:');\n      lines.push('• Check that all referenced rules are defined');\n      lines.push('• Use validate() method to find missing rules');\n      \n      // Try to identify missing rules\n      if (context?.text) {\n        const missingRules = this.validator.validateText(context.text);\n        if (missingRules.length > 0) {\n          lines.push(`• Missing rules detected: ${missingRules.join(', ')}`);\n        }\n      }\n    } else {\n      // General suggestions for unknown errors\n      lines.push('Suggestions:');\n      lines.push('• Run validate() method to check for grammar issues');\n      lines.push('• Check that all referenced rules exist');\n      lines.push('• Ensure rule values are properly formatted');\n      lines.push('• Review recent changes to grammar rules');\n    }\n    \n    lines.push('');\n    \n    // Add validation information if available\n    const validation = this.validator.validate();\n    if (!validation.isValid) {\n      lines.push('Validation Issues:');\n      \n      if (validation.missingRules.length > 0) {\n        lines.push(`• Missing rules: ${validation.missingRules.join(', ')}`);\n      }\n      \n      if (validation.circularReferences.length > 0) {\n        lines.push(`• Circular references: ${validation.circularReferences.join(', ')}`);\n      }\n      \n      if (validation.emptyRules.length > 0) {\n        lines.push(`• Empty rules: ${validation.emptyRules.join(', ')}`);\n      }\n      \n      lines.push('');\n    }\n    \n    // Add context information if provided\n    if (context) {\n      if (context.text) {\n        lines.push(`Text being parsed: \"${context.text}\"`);\n      }\n      \n      if (context.ruleName) {\n        lines.push(`Rule name: ${context.ruleName}`);\n        const ruleType = this.ruleManager.getRuleType(context.ruleName);\n        if (ruleType) {\n          lines.push(`Rule type: ${ruleType}`);\n        }\n      }\n    }\n    \n    return lines.join('\\n');\n  }\n\n  /**\n   * Check if error is related to recursion depth\n   * @private\n   */\n  private isRecursionError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('recursion') || \n           message.includes('circular') || \n           message.includes('depth') ||\n           message.includes('maximum call stack');\n  }\n\n  /**\n   * Check if error is related to function rules\n   * @private\n   */\n  private isFunctionRuleError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('function rule') || \n           message.includes('function') && message.includes('failed') ||\n           message.includes('function must return');\n  }\n\n  /**\n   * Check if error is related to weighted rule weights\n   * @private\n   */\n  private isWeightError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('weight') || \n           message.includes('sum to 1') ||\n           message.includes('probability');\n  }\n\n  /**\n   * Check if error is related to missing rules\n   * @private\n   */\n  private isMissingRuleError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('rule') && message.includes('not found') ||\n           message.includes('rule') && message.includes('does not exist') ||\n           message.includes('missing rule') ||\n           message.includes('undefined rule');\n  }\n\n  /**\n   * Create a standardized error for missing rules\n   */\n  public createMissingRuleError(ruleName: string): Error {\n    return new Error(`Rule '${ruleName}' does not exist. Use addRule() to define it first.`);\n  }\n\n  /**\n   * Create a standardized error for circular references\n   */\n  public createCircularReferenceError(ruleName: string): Error {\n    return new Error(`Circular reference detected in rule '${ruleName}'. This creates infinite recursion.`);\n  }\n\n  /**\n   * Create a standardized error for function rule failures\n   */\n  public createFunctionRuleError(ruleName: string, originalError: Error): Error {\n    return new Error(`Function rule '${ruleName}' failed: ${originalError.message}`);\n  }\n\n  /**\n   * Create a standardized error for weight validation\n   */\n  public createWeightValidationError(message: string): Error {\n    return new Error(`Weight validation failed: ${message}`);\n  }\n\n  /**\n   * Create a standardized error for recursion depth\n   */\n  public createRecursionDepthError(maxDepth: number): Error {\n    return new Error(`Maximum recursion depth of ${maxDepth} exceeded. This may indicate circular references in your grammar rules.`);\n  }\n}","/**\n * Variable expansion engine for processing %variable% placeholders\n */\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\n\nexport class VariableExpander {\n  private variablePattern = /%([^%]+)%/g;\n  private referenceValues: Map<string, string> = new Map();\n  private currentContext: { [key: string]: string } = {};\n  private maxDepth: number = 100;\n\n  constructor(\n    private ruleManager: RuleManager,\n    private random: SeededRandom\n  ) {}\n\n  /**\n   * Set maximum recursion depth\n   */\n  public setMaxDepth(depth: number): void {\n    if (typeof depth !== 'number' || depth < 1) {\n      throw new Error('Max depth must be at least 1');\n    }\n    this.maxDepth = depth;\n  }\n\n  /**\n   * Get maximum recursion depth\n   */\n  public getMaxDepth(): number {\n    return this.maxDepth;\n  }\n\n  /**\n   * Clear context and reference values\n   */\n  public clearContext(): void {\n    this.currentContext = {};\n    this.referenceValues.clear();\n  }\n\n  /**\n   * Get current context\n   */\n  public getContext(): { [key: string]: string } {\n    return { ...this.currentContext };\n  }\n\n  /**\n   * Clear reference values and context\n   */\n  public clearReferences(): void {\n    this.referenceValues.clear();\n    this.currentContext = {};\n  }\n\n  /**\n   * Expand variables in text with recursive processing\n   * @param text - Text containing %variable% placeholders\n   * @param preserveContext - Whether to maintain context from previous expansions\n   * @returns Fully expanded text\n   */\n  public expandVariables(text: string, preserveContext: boolean = false): string {\n    if (!preserveContext) {\n      this.clearContext();\n    }\n    \n    return this.expandVariablesRecursive(text, 0);\n  }\n\n  /**\n   * Recursively expand variables with depth protection\n   * @private\n   */\n  private expandVariablesRecursive(text: string, depth: number): string {\n    if (depth >= this.maxDepth) {\n      throw new Error(`Maximum recursion depth of ${this.maxDepth} exceeded. This may indicate circular references in your grammar rules.`);\n    }\n\n    // Reset the regex lastIndex to ensure proper matching\n    this.variablePattern.lastIndex = 0;\n\n    return text.replace(this.variablePattern, (match, key) => {\n      // Handle reference variables (@variable syntax)\n      if (key.startsWith('@')) {\n        const refKey = key.substring(1);\n        const refValue = this.referenceValues.get(refKey);\n        if (refValue !== undefined) {\n          return refValue;\n        }\n        // If reference doesn't exist, fall through to generate new value\n        key = refKey;\n      }\n\n      // Try to generate value from rule manager\n      const value = this.ruleManager.generateValue(key, this.currentContext, this.random);\n      \n      if (value === null) {\n        // Rule not found - return original placeholder\n        return match;\n      }\n\n      // Store in context and references\n      this.currentContext[key] = value;\n      this.referenceValues.set(key, value);\n\n      // Recursively expand the generated value\n      return this.expandVariablesRecursive(value, depth + 1);\n    });\n  }\n\n  /**\n   * Find all variable names in text\n   * @param text - Text to analyze\n   * @returns Array of unique variable names\n   */\n  public findVariables(text: string): string[] {\n    const variables = new Set<string>();\n    const regex = new RegExp(this.variablePattern.source, 'g');\n    let match;\n    \n    while ((match = regex.exec(text)) !== null) {\n      variables.add(match[1]);\n    }\n    \n    return Array.from(variables);\n  }\n\n  /**\n   * Validate that all variables in text have corresponding rules\n   * @param text - Text to validate\n   * @returns Array of missing variable names\n   */\n  public findMissingVariables(text: string): string[] {\n    const variables = this.findVariables(text);\n    const missing: string[] = [];\n    \n    for (const variable of variables) {\n      // Skip reference variables\n      if (variable.startsWith('@')) {\n        continue;\n      }\n      \n      if (!this.ruleManager.hasRule(variable)) {\n        missing.push(variable);\n      }\n    }\n    \n    return missing;\n  }\n\n  /**\n   * Check for circular references in grammar rules\n   * @param startRule - Rule to start checking from\n   * @param visited - Set of already visited rules\n   * @returns Array of circular reference chains found\n   */\n  public findCircularReferences(startRule?: string, visited: Set<string> = new Set()): string[] {\n    const circular: string[] = [];\n    \n    if (startRule) {\n      this.checkRuleForCircularReferences(startRule, visited, circular);\n    } else {\n      // Check all rules\n      const allKeys = this.ruleManager.getAllKeys();\n      for (const key of allKeys) {\n        this.checkRuleForCircularReferences(key, new Set(), circular);\n      }\n    }\n    \n    return circular;\n  }\n\n  /**\n   * Check a specific rule for circular references\n   * @private\n   */\n  private checkRuleForCircularReferences(\n    ruleName: string, \n    visited: Set<string>, \n    circular: string[]\n  ): void {\n    if (visited.has(ruleName)) {\n      circular.push(ruleName);\n      return;\n    }\n    \n    visited.add(ruleName);\n    \n    // Get a sample value from the rule to check its variables  \n    const sampleValue = this.ruleManager.generateValue(ruleName, {}, this.random);\n    if (sampleValue) {\n      const variables = this.findVariables(sampleValue);\n      for (const variable of variables) {\n        if (!variable.startsWith('@') && this.ruleManager.hasRule(variable)) {\n          this.checkRuleForCircularReferences(variable, new Set(visited), circular);\n        }\n      }\n    }\n    \n    visited.delete(ruleName);\n  }\n}","/**\n * Story Grammar - A combinatorial grammar for narrative-based projects\n */\n\n// Core Parser and all types\nexport { Parser } from './Parser.js';\n\n// Export all types and interfaces\nexport * from './types.js';\n\n// New Modifiers namespace\nexport * as Modifiers from './modifiers/index.js';\n\n// English modifiers (backward compatibility) - use comprehensive implementation\nexport {\n  EnglishArticleModifier,\n  EnglishPluralizationModifier,\n  EnglishOrdinalModifier,\n  EnglishCapitalizationModifier,\n  EnglishPossessiveModifier,\n  EnglishVerbAgreementModifier,\n  PunctuationCleanupModifier,\n  AllEnglishModifiers,\n  BasicEnglishModifiers\n} from './EnglishModifiers.js';\n\n// Re-export for backward compatibility\nexport { Parser as StoryGrammar } from './Parser.js';","/**\n * English article modifier (a/an correction)\n * Converts \"a\" to \"an\" before vowel sounds\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const ArticleModifier: Modifier = {\n  name: 'englishArticles',\n  condition: (text: string) => {\n    return /\\ba\\s+[aeiouAEIOU]/.test(text);\n  },\n  transform: (text: string) => {\n    // More precise regex to handle vowel sounds at word boundaries\n    return text.replace(/\\ba(\\s+)([aeiouAEIOU][a-z]*)/gi, 'an$1$2');\n  },\n  priority: 10\n};","/**\n * English capitalization modifier\n * Capitalizes words after sentence-ending punctuation\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const CapitalizationModifier: Modifier = {\n  name: 'englishCapitalization',\n  condition: (text: string) => {\n    // Look for lowercase letters after sentence endings\n    return /[.!?]\\s+[a-z]/.test(text);\n  },\n  transform: (text: string) => {\n    // Capitalize first letter of sentences\n    return text.replace(/([.!?]\\s+)([a-z])/g, (match, punctuation, letter) => {\n      return punctuation + letter.toUpperCase();\n    });\n  },\n  priority: 7\n};","/**\n * English ordinal modifier\n * Converts cardinal numbers to ordinal format (1 -> 1st, 2 -> 2nd, etc.)\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const OrdinalModifier: Modifier = {\n  name: 'englishOrdinals',\n  condition: (text: string) => {\n    // Look for standalone numbers (digits)\n    return /\\b\\d+\\b/.test(text);\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(\\d+)\\b/g, (match, num) => {\n      const number = parseInt(num, 10);\n      \n      // Get the last digit and last two digits\n      const lastDigit = number % 10;\n      const lastTwoDigits = number % 100;\n      \n      // Exception: numbers ending in 11, 12, 13 use 'th'\n      if (lastTwoDigits === 11 || lastTwoDigits === 12 || lastTwoDigits === 13) {\n        return num + 'th';\n      }\n      \n      // Apply ordinal rules based on last digit\n      switch (lastDigit) {\n        case 1:\n          return num + 'st';\n        case 2:\n          return num + 'nd';\n        case 3:\n          return num + 'rd';\n        default:\n          return num + 'th';\n      }\n    });\n  },\n  priority: 8\n};","/**\n * English pluralization modifier\n * Handles comprehensive pluralization patterns including irregular forms\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const PluralizationModifier: Modifier = {\n  name: 'englishPluralization',\n  condition: (text: string) => {\n    // Look for plural indicators: numbers > 1, \"many\", \"several\", \"multiple\", etc.\n    return /\\b(many|several|multiple|some|few|all|both|various|numerous|[2-9]\\d*|\\d*[02-9])\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(zero|no)\\s+[a-zA-Z]+/i.test(text); // Zero/no also takes plural\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(many|several|multiple|some|few|all|both|various|numerous|zero|no|[2-9]\\d*|\\d*[02-9]|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+([a-zA-Z]+)\\b/gi, \n      (match, quantifier, noun) => {\n        const pluralNoun = pluralize(noun);\n        return `${quantifier} ${pluralNoun}`;\n      }\n    );\n  },\n  priority: 4\n};\n\n/**\n * Convert a singular noun to its plural form\n * @param noun - The singular noun to pluralize\n * @returns The plural form of the noun\n */\nfunction pluralize(noun: string): string {\n  const lowerNoun = noun.toLowerCase();\n  \n  // Irregular plurals mapping\n  const irregularPlurals: { [key: string]: string } = {\n    'addendum': 'addenda',\n    'aircraft': 'aircraft',\n    'alumna': 'alumnae',\n    'alumnus': 'alumni',\n    'analysis': 'analyses',\n    'antenna': 'antennae',\n    'antithesis': 'antitheses',\n    'apex': 'apices',\n    'appendix': 'appendices',\n    'axis': 'axes',\n    'bacillus': 'bacilli',\n    'bacterium': 'bacteria',\n    'basis': 'bases',\n    'beau': 'beaux',\n    'bison': 'bison',\n    'bureau': 'bureaux',\n    'cactus': 'cacti',\n    'château': 'châteaux',\n    'child': 'children',\n    'codex': 'codices',\n    'concerto': 'concerti',\n    'corpus': 'corpora',\n    'crisis': 'crises',\n    'criterion': 'criteria',\n    'curriculum': 'curricula',\n    'datum': 'data',\n    'deer': 'deer',\n    'diagnosis': 'diagnoses',\n    'die': 'dice',\n    'dwarf': 'dwarves',\n    'ellipsis': 'ellipses',\n    'erratum': 'errata',\n    'fez': 'fezzes',\n    'fish': 'fish',\n    'focus': 'foci',\n    'foot': 'feet',\n    'formula': 'formulae',\n    'fungus': 'fungi',\n    'genus': 'genera',\n    'goose': 'geese',\n    'graffito': 'graffiti',\n    'grouse': 'grouse',\n    'half': 'halves',\n    'hoof': 'hooves',\n    'hypothesis': 'hypotheses',\n    'index': 'indices',\n    'larva': 'larvae',\n    'libretto': 'libretti',\n    'loaf': 'loaves',\n    'locus': 'loci',\n    'louse': 'lice',\n    'man': 'men',\n    'matrix': 'matrices',\n    'medium': 'media',\n    'memorandum': 'memoranda',\n    'minutia': 'minutiae',\n    'moose': 'moose',\n    'mouse': 'mice',\n    'nebula': 'nebulae',\n    'nucleus': 'nuclei',\n    'oasis': 'oases',\n    'offspring': 'offspring',\n    'opus': 'opera',\n    'ovum': 'ova',\n    'ox': 'oxen',\n    'parenthesis': 'parentheses',\n    'person': 'people',\n    'phenomenon': 'phenomena',\n    'phylum': 'phyla',\n    'quiz': 'quizzes',\n    'radius': 'radii',\n    'referendum': 'referenda',\n    'salmon': 'salmon',\n    'scarf': 'scarves',\n    'self': 'selves',\n    'series': 'series',\n    'sheep': 'sheep',\n    'shrimp': 'shrimp',\n    'species': 'species',\n    'stimulus': 'stimuli',\n    'stratum': 'strata',\n    'swine': 'swine',\n    'syllabus': 'syllabi',\n    'symposium': 'symposia',\n    'synopsis': 'synopses',\n    'tableau': 'tableaux',\n    'thesis': 'theses',\n    'thief': 'thieves',\n    'tooth': 'teeth',\n    'trout': 'trout',\n    'tuna': 'tuna',\n    'vertebra': 'vertebrae',\n    'vertex': 'vertices',\n    'vita': 'vitae',\n    'vortex': 'vortices',\n    'wharf': 'wharves',\n    'wife': 'wives',\n    'wolf': 'wolves',\n    'woman': 'women'\n  };\n  \n  // Check for irregular plurals first\n  if (irregularPlurals[lowerNoun]) {\n    const irregularPlural = irregularPlurals[lowerNoun];\n    // Preserve original case pattern\n    return preserveCase(noun, irregularPlural);\n  }\n  \n  // Apply regular pluralization rules in order of specificity\n  \n  // 1. Words ending in -s, -ss, -sh, -ch, -x, -z: add -es\n  if (/[sxz]$/.test(lowerNoun) || /[sc]h$/.test(lowerNoun)) {\n    return noun + 'es';\n  }\n  \n  // 2. Words ending in consonant + y: change y to ies\n  if (/[bcdfghjklmnpqrstvwxz]y$/i.test(lowerNoun)) {\n    return noun.slice(0, -1) + 'ies';\n  }\n  \n  // 3. Words ending in vowel + y: just add -s\n  if (/[aeiou]y$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 4. Words ending in -f or -fe: change to -ves (with exceptions)\n  if (/fe?$/i.test(lowerNoun)) {\n    // Exceptions that just add -s\n    const fExceptions = ['belief', 'chief', 'cliff', 'proof', 'roof', 'safe', 'chef', 'handkerchief'];\n    if (fExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun.replace(/fe?$/i, 'ves');\n  }\n  \n  // 5. Words ending in consonant + o: add -es (with common exceptions)\n  if (/[bcdfghjklmnpqrstvwxz]o$/i.test(lowerNoun)) {\n    // Common exceptions that just add -s\n    const oExceptions = [\n      'photo', 'piano', 'halo', 'disco', 'studio', 'radio', 'video', \n      'auto', 'memo', 'pro', 'casino', 'patio', 'portfolio', 'logo',\n      'commando', 'solo', 'soprano', 'alto', 'kimono'\n    ];\n    if (oExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun + 'es';\n  }\n  \n  // 6. Words ending in vowel + o: just add -s\n  if (/[aeiou]o$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 7. Default case: add -s\n  return noun + 's';\n}\n\n/**\n * Preserve the case pattern of the original word in the plural form\n * @param original - The original word with its case pattern\n * @param plural - The lowercase plural form\n * @returns The plural with preserved case pattern\n */\nfunction preserveCase(original: string, plural: string): string {\n  // If original is all uppercase, make plural all uppercase\n  if (original === original.toUpperCase()) {\n    return plural.toUpperCase();\n  }\n  \n  // If original starts with uppercase, capitalize the plural\n  if (original[0] === original[0].toUpperCase()) {\n    return plural.charAt(0).toUpperCase() + plural.slice(1);\n  }\n  \n  // Otherwise, return lowercase plural\n  return plural;\n}","/**\n * English possessive modifier\n * Adds possessive apostrophes to words ending with \"POSSESSIVE\"\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const PossessiveModifier: Modifier = {\n  name: 'englishPossessive',\n  condition: (text: string) => text.includes('POSSESSIVE'),\n  transform: (text: string) => {\n    return text.replace(/(\\w+)POSSESSIVE/g, (match, word) => {\n      if (word.endsWith('s')) {\n        return word + \"'\";\n      } else {\n        return word + \"'s\";\n      }\n    });\n  },\n  priority: 6\n};","/**\n * Punctuation cleanup modifier\n * Fixes common punctuation issues like double spaces and spacing around punctuation\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const PunctuationCleanupModifier: Modifier = {\n  name: 'englishPunctuationCleanup',\n  condition: (text: string) => {\n    // Look for spacing issues around punctuation\n    return /\\s+[,.!?;:]|\\s{2,}/.test(text);\n  },\n  transform: (text: string) => {\n    // Fix spacing before punctuation\n    text = text.replace(/\\s+([,.!?;:])/g, '$1');\n    \n    // Fix multiple spaces\n    text = text.replace(/\\s{2,}/g, ' ');\n    \n    // Ensure space after sentence-ending punctuation\n    text = text.replace(/([.!?])([A-Z])/g, '$1 $2');\n    \n    return text;\n  },\n  priority: 9\n};","/**\n * English verb agreement modifier\n * Handles basic subject-verb agreement for common verbs\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const VerbAgreementModifier: Modifier = {\n  name: 'englishVerbAgreement',\n  condition: (text: string) => {\n    // Look for patterns that need verb agreement\n    return /\\b(he|she|it|\\w+(?:ing|ed))\\s+are\\b/i.test(text) ||\n           /\\b(they|we|you|\\w+s)\\s+is\\b/i.test(text);\n  },\n  transform: (text: string) => {\n    // Fix singular subjects with \"are\"\n    text = text.replace(/\\b(he|she|it)\\s+are\\b/gi, '$1 is');\n    \n    // Fix plural subjects with \"is\" (basic heuristic)\n    text = text.replace(/\\b(they|we|you)\\s+is\\b/gi, '$1 are');\n    \n    return text;\n  },\n  priority: 5\n};","/**\n * English Modifiers Namespace\n * Collection of text modifiers for English language processing\n */\n\nexport { ArticleModifier } from './ArticleModifier.js';\nexport { PluralizationModifier } from './PluralizationModifier.js';\nexport { OrdinalModifier } from './OrdinalModifier.js';\nexport { CapitalizationModifier } from './CapitalizationModifier.js';\nexport { PossessiveModifier } from './PossessiveModifier.js';\nexport { VerbAgreementModifier } from './VerbAgreementModifier.js';\nexport { PunctuationCleanupModifier } from './PunctuationCleanupModifier.js';\n\n// Convenience export of all English modifiers as an array\nimport { ArticleModifier } from './ArticleModifier.js';\nimport { PluralizationModifier } from './PluralizationModifier.js';\nimport { OrdinalModifier } from './OrdinalModifier.js';\nimport { CapitalizationModifier } from './CapitalizationModifier.js';\nimport { PossessiveModifier } from './PossessiveModifier.js';\nimport { VerbAgreementModifier } from './VerbAgreementModifier.js';\nimport { PunctuationCleanupModifier } from './PunctuationCleanupModifier.js';\n\nexport const AllEnglishModifiers = [\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier,\n  CapitalizationModifier,\n  PossessiveModifier,\n  VerbAgreementModifier,\n  PunctuationCleanupModifier\n];\n\nexport const BasicEnglishModifiers = [\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier\n];","/**\n * Modifiers Namespace\n * Organized collection of text modifiers by language\n */\n\n// English modifiers namespace\nexport * as English from './english/index.js';\n\n// Re-export individual English modifiers for convenience\nexport {\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier,\n  CapitalizationModifier,\n  PossessiveModifier,\n  VerbAgreementModifier,\n  PunctuationCleanupModifier,\n  AllEnglishModifiers\n} from './english/index.js';","/**\n * Advanced rule managers for conditional, sequential, range, and template rules\n */\nimport { \n  ConditionalRule, \n  SequentialRule, \n  RangeRule, \n  TemplateRule \n} from '../types.js';\nimport { BaseRuleManager } from './BaseRuleManager.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\n\n/**\n * Manager for conditional rules that select values based on context\n */\nexport class ConditionalRuleManager extends BaseRuleManager<ConditionalRule> {\n  /**\n   * Add a conditional rule\n   * @param key - Rule identifier\n   * @param rule - Conditional rule configuration\n   */\n  public addRule(key: string, rule: ConditionalRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (!rule || !Array.isArray(rule.conditions)) {\n      throw new Error('Conditional rule must have a conditions array');\n    }\n    if (rule.conditions.length === 0) {\n      throw new Error('Conditions array cannot be empty');\n    }\n\n    // Validate conditions\n    let hasDefault = false;\n    for (const condition of rule.conditions) {\n      if ('default' in condition) {\n        if (hasDefault) {\n          throw new Error('Only one default condition is allowed');\n        }\n        hasDefault = true;\n        if (!Array.isArray(condition.default) || condition.default.length === 0) {\n          throw new Error('Default condition must have an array of values');\n        }\n      } else if ('if' in condition && 'then' in condition) {\n        if (typeof condition.if !== 'function') {\n          throw new Error('Condition \"if\" must be a function');\n        }\n        if (!Array.isArray(condition.then) || condition.then.length === 0) {\n          throw new Error('Condition \"then\" must be an array of values');\n        }\n      } else {\n        throw new Error('Each condition must have either \"if/then\" or \"default\"');\n      }\n    }\n\n    this.rules.set(key, {\n      conditions: rule.conditions.map(c => ({ ...c }))\n    });\n  }\n\n  /**\n   * Generate a value from a conditional rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context\n   * @param random - Random number generator\n   * @returns Context-appropriate value or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    for (const condition of rule.conditions) {\n      if ('default' in condition && condition.default) {\n        return random.randomChoice(condition.default);\n      } else if (condition.if && condition.if(context)) {\n        return random.randomChoice(condition.then);\n      }\n    }\n    \n    throw new Error('No matching condition found and no default provided');\n  }\n}\n\n/**\n * Manager for sequential rules that cycle through values in order\n */\nexport class SequentialRuleManager extends BaseRuleManager<SequentialRule> {\n  /**\n   * Add a sequential rule\n   * @param key - Rule identifier\n   * @param values - Array of values to cycle through\n   * @param options - Configuration options\n   */\n  public addRule(key: string, values: string[], options: { cycle: boolean } = { cycle: true }): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!Array.isArray(values) || values.length === 0) {\n      throw new Error('Values must be a non-empty array');\n    }\n\n    this.rules.set(key, {\n      values: [...values],\n      index: 0,\n      cycle: options.cycle\n    });\n  }\n\n  /**\n   * Generate a value from a sequential rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for sequential rules)\n   * @param random - Random number generator (unused for sequential rules)\n   * @returns Next value in sequence or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _context: { [key: string]: string }, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    if (rule.index >= rule.values.length) {\n      if (rule.cycle) {\n        rule.index = 0;\n      } else {\n        return rule.values[rule.values.length - 1];\n      }\n    }\n    \n    const value = rule.values[rule.index];\n    rule.index++;\n    return value;\n  }\n\n  /**\n   * Reset a sequential rule to start from the beginning\n   * @param key - Rule identifier\n   * @returns True if rule was reset, false if it doesn't exist\n   */\n  public resetRule(key: string): boolean {\n    const rule = this.rules.get(key);\n    if (rule) {\n      rule.index = 0;\n      return true;\n    }\n    return false;\n  }\n}\n\n/**\n * Manager for range rules that generate numeric values\n */\nexport class RangeRuleManager extends BaseRuleManager<RangeRule> {\n  /**\n   * Add a range rule\n   * @param key - Rule identifier\n   * @param config - Range configuration\n   */\n  public addRule(key: string, config: { min: number; max: number; step?: number; type: 'integer' | 'float' }): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (typeof config.min !== 'number' || typeof config.max !== 'number') {\n      throw new Error('Min and max must be numbers');\n    }\n    if (config.min >= config.max) {\n      throw new Error('Min must be less than max');\n    }\n    if (config.step !== undefined && (typeof config.step !== 'number' || config.step <= 0)) {\n      throw new Error('Step must be a positive number');\n    }\n    if (!['integer', 'float'].includes(config.type)) {\n      throw new Error('Type must be \"integer\" or \"float\"');\n    }\n\n    this.rules.set(key, {\n      min: config.min,\n      max: config.max,\n      step: config.step,\n      type: config.type\n    });\n  }\n\n  /**\n   * Generate a value from a range rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for range rules)\n   * @param random - Random number generator\n   * @returns Generated numeric value as string or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    _context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    const { min, max, step, type } = rule;\n    \n    if (step !== undefined) {\n      // Generate stepped values\n      const steps = Math.floor((max - min) / step);\n      const randomStep = random.randomInt(0, steps + 1);\n      const value = min + (randomStep * step);\n      return type === 'integer' ? Math.floor(value).toString() : value.toString();\n    } else {\n      // Generate continuous values\n      const randomValue = min + (random.random() * (max - min));\n      return type === 'integer' ? Math.floor(randomValue).toString() : randomValue.toString();\n    }\n  }\n}\n\n/**\n * Manager for template rules with embedded variables\n */\nexport class TemplateRuleManager extends BaseRuleManager<TemplateRule> {\n  /**\n   * Add a template rule\n   * @param key - Rule identifier\n   * @param rule - Template rule configuration\n   */\n  public addRule(key: string, rule: TemplateRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!rule.template || typeof rule.template !== 'string') {\n      throw new Error('Template must be a non-empty string');\n    }\n    if (!rule.variables || typeof rule.variables !== 'object') {\n      throw new Error('Variables must be an object');\n    }\n\n    // Validate that all variables in template exist in variables object\n    const templateVars = this.findVariables(rule.template);\n    for (const variable of templateVars) {\n      if (!(variable in rule.variables)) {\n        throw new Error(`Template variable '${variable}' not found in variables object`);\n      }\n      if (!Array.isArray(rule.variables[variable]) || rule.variables[variable].length === 0) {\n        throw new Error(`Variable '${variable}' must be an array`);\n      }\n    }\n\n    this.rules.set(key, {\n      template: rule.template,\n      variables: { ...rule.variables }\n    });\n  }\n\n  /**\n   * Generate a value from a template rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context\n   * @param random - Random number generator\n   * @returns Generated template value or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    _context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    // Expand template using its own variables\n    let result = rule.template;\n    const templateVars = this.findVariables(result);\n    \n    for (const variable of templateVars) {\n      const values = rule.variables[variable];\n      if (values && values.length > 0) {\n        const value = random.randomChoice(values);\n        result = result.replace(new RegExp(`%${variable}%`, 'g'), value);\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Find all variables in a text string\n   * @param text - Text to analyze\n   * @returns Array of unique variable names\n   */\n  private findVariables(text: string): string[] {\n    const variablePattern = /%([^%]+)%/g;\n    const variables = new Set<string>();\n    let match;\n    while ((match = variablePattern.exec(text)) !== null) {\n      variables.add(match[1]);\n    }\n    return Array.from(variables);\n  }\n}","/**\n * Base class for managing different types of grammar rules\n */\nimport {\n  Grammar,\n  FunctionRule,\n  WeightedRule\n} from '../types.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\n\nexport abstract class BaseRuleManager<T> {\n  protected rules: Map<string, T> = new Map();\n\n  /**\n   * Add a rule to the manager\n   * @param key - Rule identifier\n   * @param ...args - Rule configuration arguments (varies by implementation)\n   */\n  public abstract addRule(key: string, ...args: unknown[]): void;\n\n  /**\n   * Remove a rule from the manager\n   * @param key - Rule identifier\n   * @returns True if rule was removed\n   */\n  public removeRule(key: string): boolean {\n    return this.rules.delete(key);\n  }\n\n  /**\n   * Check if a rule exists\n   * @param key - Rule identifier\n   * @returns True if rule exists\n   */\n  public hasRule(key: string): boolean {\n    return this.rules.has(key);\n  }\n\n  /**\n   * Get a rule by key\n   * @param key - Rule identifier\n   * @returns Rule or undefined\n   */\n  public getRule(key: string): T | undefined {\n    return this.rules.get(key);\n  }\n\n  /**\n   * Clear all rules\n   */\n  public clear(): void {\n    this.rules.clear();\n  }\n\n  /**\n   * Get all rule keys\n   * @returns Array of rule keys\n   */\n  public getKeys(): string[] {\n    return Array.from(this.rules.keys());\n  }\n\n  /**\n   * Get the number of rules\n   * @returns Number of rules\n   */\n  public size(): number {\n    return this.rules.size;\n  }\n\n  /**\n   * Get rule data for analysis (protected method for analyzers)\n   * @param key - Rule identifier\n   * @returns Rule data or undefined\n   */\n  public getRuleData(key: string): T | undefined {\n    return this.rules.get(key);\n  }\n\n  /**\n   * Generate a value from the rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context\n   * @param random - Random number generator\n   * @returns Generated value or null if rule doesn't exist\n   */\n  public abstract generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null;\n}\n\n/**\n * Manager for static grammar rules\n */\nexport class StaticRuleManager extends BaseRuleManager<string[]> {\n  /**\n   * Add a static rule\n   * @param key - Rule identifier\n   * @param values - Array of possible values\n   */\n  public addRule(key: string, values: string[]): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (!Array.isArray(values)) {\n      throw new Error('Rule values must be an array');\n    }\n    this.rules.set(key, [...values]); // Create a copy to avoid external mutation\n  }\n\n  /**\n   * Add multiple static rules\n   * @param grammar - Object containing key-value pairs of rules\n   */\n  public addRules(grammar: Grammar): void {\n    for (const [key, values] of Object.entries(grammar)) {\n      this.addRule(key, values);\n    }\n  }\n\n  /**\n   * Generate a value from a static rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for static rules)\n   * @param random - Random number generator\n   * @returns Random value from rule or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n    if (rule.length === 0) {\n      return '';\n    }\n    return random.randomChoice(rule);\n  }\n\n  /**\n   * Get all static rules as a Grammar object\n   * @returns Copy of all static rules\n   */\n  public getGrammar(): Grammar {\n    const grammar: Grammar = {};\n    for (const [key, values] of this.rules.entries()) {\n      grammar[key] = [...values];\n    }\n    return grammar;\n  }\n}\n\n/**\n * Manager for function-based rules\n */\nexport class FunctionRuleManager extends BaseRuleManager<FunctionRule> {\n  /**\n   * Add a function rule\n   * @param key - Rule identifier\n   * @param fn - Function that returns an array of possible values\n   */\n  public addRule(key: string, fn: FunctionRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (typeof fn !== 'function') {\n      throw new Error('Rule function must be a function');\n    }\n    this.rules.set(key, fn);\n  }\n\n  /**\n   * Generate a value from a function rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for function rules)\n   * @param random - Random number generator\n   * @returns Random value from function result or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n    \n    try {\n      const values = rule();\n      if (!Array.isArray(values)) {\n        throw new Error(`Function rule '${key}' must return an array`);\n      }\n      if (values.length === 0) {\n        return null; // This will cause the variable to remain unchanged\n      }\n      return random.randomChoice(values);\n    } catch (error) {\n      throw new Error(`Error executing function rule '${key}': ${(error as Error).message}`);\n    }\n  }\n}\n\n/**\n * Manager for weighted rules\n */\nexport class WeightedRuleManager extends BaseRuleManager<WeightedRule> {\n  /**\n   * Add a weighted rule\n   * @param key - Rule identifier\n   * @param values - Array of possible values\n   * @param weights - Array of probability weights (must sum to 1.0)\n   */\n  public addRule(key: string, values: string[], weights: number[]): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (!Array.isArray(values)) {\n      throw new Error('Rule values must be an array');\n    }\n    if (!Array.isArray(weights)) {\n      throw new Error('Rule weights must be an array');\n    }\n    if (values.length !== weights.length) {\n      throw new Error('Values and weights arrays must have the same length');\n    }\n    if (values.length === 0) {\n      throw new Error('Values array cannot be empty');\n    }\n    \n    // Validate weights\n    for (const weight of weights) {\n      if (typeof weight !== 'number' || weight < 0) {\n        throw new Error('All weights must be non-negative numbers');\n      }\n    }\n    \n    const weightSum = weights.reduce((sum, weight) => sum + weight, 0);\n    if (Math.abs(weightSum - 1.0) > 0.0001) {\n      throw new Error(`Weights must sum to 1.0, got ${weightSum}`);\n    }\n    \n    // Calculate cumulative weights for efficient sampling\n    const cumulativeWeights: number[] = [];\n    let cumSum = 0;\n    for (const weight of weights) {\n      cumSum += weight;\n      cumulativeWeights.push(cumSum);\n    }\n    \n    this.rules.set(key, {\n      values: [...values],\n      weights: [...weights],\n      cumulativeWeights\n    });\n  }\n\n  /**\n   * Generate a value from a weighted rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for weighted rules)\n   * @param random - Random number generator\n   * @returns Weighted random value or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n    \n    return random.weightedChoice(rule.values, rule.cumulativeWeights);\n  }\n}","/**\n * Unified rule manager that coordinates all rule types\n */\nimport { \n  Grammar, \n  FunctionRule, \n  ConditionalRule, \n  TemplateRule,\n  WeightedRule,\n  SequentialRule,\n  RangeRule\n} from '../types.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\nimport { \n  StaticRuleManager, \n  FunctionRuleManager, \n  WeightedRuleManager \n} from './BaseRuleManager.js';\nimport { \n  ConditionalRuleManager, \n  SequentialRuleManager, \n  RangeRuleManager, \n  TemplateRuleManager \n} from './AdvancedRuleManagers.js';\n\n/**\n * Unified manager for all rule types with priority-based resolution\n */\nexport class RuleManager {\n  private staticRules = new StaticRuleManager();\n  private functionRules = new FunctionRuleManager();\n  private weightedRules = new WeightedRuleManager();\n  private conditionalRules = new ConditionalRuleManager();\n  private sequentialRules = new SequentialRuleManager();\n  private rangeRules = new RangeRuleManager();\n  private templateRules = new TemplateRuleManager();\n\n  // Rule resolution priority (first match wins)\n  private readonly ruleManagers = [\n    { name: 'function', manager: this.functionRules },\n    { name: 'conditional', manager: this.conditionalRules },\n    { name: 'sequential', manager: this.sequentialRules },\n    { name: 'range', manager: this.rangeRules },\n    { name: 'template', manager: this.templateRules },\n    { name: 'weighted', manager: this.weightedRules },\n    { name: 'static', manager: this.staticRules }\n  ];\n\n  /**\n   * Add static rules\n   */\n  public addRule(key: string, values: string[]): void {\n    this.staticRules.addRule(key, values);\n  }\n\n  public addRules(grammar: Grammar): void {\n    this.staticRules.addRules(grammar);\n  }\n\n  /**\n   * Add function rule\n   */\n  public addFunctionRule(key: string, fn: FunctionRule): void {\n    this.functionRules.addRule(key, fn);\n  }\n\n  /**\n   * Add weighted rule\n   */\n  public addWeightedRule(key: string, values: string[], weights: number[]): void {\n    this.weightedRules.addRule(key, values, weights);\n  }\n\n  /**\n   * Add conditional rule\n   */\n  public addConditionalRule(key: string, rule: ConditionalRule): void {\n    this.conditionalRules.addRule(key, rule);\n  }\n\n  /**\n   * Add sequential rule\n   */\n  public addSequentialRule(key: string, values: string[], options?: { cycle: boolean }): void {\n    this.sequentialRules.addRule(key, values, options);\n  }\n\n  /**\n   * Add range rule\n   */\n  public addRangeRule(key: string, config: { min: number; max: number; step?: number; type: 'integer' | 'float' }): void {\n    this.rangeRules.addRule(key, config);\n  }\n\n  /**\n   * Add template rule\n   */\n  public addTemplateRule(key: string, rule: TemplateRule): void {\n    this.templateRules.addRule(key, rule);\n  }\n\n  /**\n   * Check if a rule exists (any type)\n   */\n  public hasRule(key: string): boolean {\n    return this.ruleManagers.some(({ manager }) => manager.hasRule(key));\n  }\n\n  /**\n   * Remove a rule (from all managers)\n   */\n  public removeRule(key: string): boolean {\n    let removed = false;\n    for (const { manager } of this.ruleManagers) {\n      if (manager.removeRule(key)) {\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  /**\n   * Generate a value from any rule type\n   * Uses priority order: function → conditional → sequential → range → template → weighted → static\n   */\n  public generateValue(key: string, context: { [key: string]: string }, random: SeededRandom): string | null {\n    for (const { manager } of this.ruleManagers) {\n      if (manager.hasRule(key)) {\n        return manager.generateValue(key, context, random);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get rule type for a given key\n   */\n  public getRuleType(key: string): string | null {\n    for (const { name, manager } of this.ruleManagers) {\n      if (manager.hasRule(key)) {\n        return name;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Clear all rules\n   */\n  public clear(): void {\n    for (const { manager } of this.ruleManagers) {\n      manager.clear();\n    }\n  }\n\n  /**\n   * Clear specific rule types\n   */\n  public clearStaticRules(): void { this.staticRules.clear(); }\n  public clearFunctionRules(): void { this.functionRules.clear(); }\n  public clearWeightedRules(): void { this.weightedRules.clear(); }\n  public clearConditionalRules(): void { this.conditionalRules.clear(); }\n  public clearSequentialRules(): void { this.sequentialRules.clear(); }\n  public clearRangeRules(): void { this.rangeRules.clear(); }\n  public clearTemplateRules(): void { this.templateRules.clear(); }\n\n  /**\n   * Get statistics about rules\n   */\n  public getStats(): { [key: string]: number } {\n    return {\n      static: this.staticRules.size(),\n      function: this.functionRules.size(),\n      weighted: this.weightedRules.size(),\n      conditional: this.conditionalRules.size(),\n      sequential: this.sequentialRules.size(),\n      range: this.rangeRules.size(),\n      template: this.templateRules.size(),\n      total: this.ruleManagers.reduce((sum, { manager }) => sum + manager.size(), 0)\n    };\n  }\n\n  /**\n   * Get all rule keys\n   */\n  public getAllKeys(): string[] {\n    const keys = new Set<string>();\n    for (const { manager } of this.ruleManagers) {\n      for (const key of manager.getKeys()) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys);\n  }\n\n  /**\n   * Reset sequential rule\n   */\n  public resetSequentialRule(key: string): boolean {\n    return this.sequentialRules.resetRule(key);\n  }\n\n  /**\n   * Get static grammar\n   */\n  public getGrammar(): Grammar {\n    return this.staticRules.getGrammar();\n  }\n\n  /**\n   * Get rule data for analysis purposes\n   */\n  public getWeightedRuleData(key: string): WeightedRule | undefined {\n    return this.weightedRules.getRuleData(key);\n  }\n\n  public getConditionalRuleData(key: string): ConditionalRule | undefined {\n    return this.conditionalRules.getRuleData(key);\n  }\n\n  public getSequentialRuleData(key: string): SequentialRule | undefined {\n    return this.sequentialRules.getRuleData(key);\n  }\n\n  public getRangeRuleData(key: string): RangeRule | undefined {\n    return this.rangeRules.getRuleData(key);\n  }\n\n  public getTemplateRuleData(key: string): TemplateRule | undefined {\n    return this.templateRules.getRuleData(key);\n  }\n\n  /**\n   * Check specific rule types\n   */\n  public hasFunctionRule(key: string): boolean { return this.functionRules.hasRule(key); }\n  public hasWeightedRule(key: string): boolean { return this.weightedRules.hasRule(key); }\n  public hasConditionalRule(key: string): boolean { return this.conditionalRules.hasRule(key); }\n  public hasSequentialRule(key: string): boolean { return this.sequentialRules.hasRule(key); }\n  public hasRangeRule(key: string): boolean { return this.rangeRules.hasRule(key); }\n  public hasTemplateRule(key: string): boolean { return this.templateRules.hasRule(key); }\n\n  /**\n   * Remove specific rule types\n   */\n  public removeFunctionRule(key: string): boolean { return this.functionRules.removeRule(key); }\n  public removeWeightedRule(key: string): boolean { return this.weightedRules.removeRule(key); }\n  public removeConditionalRule(key: string): boolean { return this.conditionalRules.removeRule(key); }\n  public removeSequentialRule(key: string): boolean { return this.sequentialRules.removeRule(key); }\n  public removeRangeRule(key: string): boolean { return this.rangeRules.removeRule(key); }\n  public removeTemplateRule(key: string): boolean { return this.templateRules.removeRule(key); }\n}","/**\n * Seeded random number generator using Linear Congruential Generator (LCG)\n * Provides deterministic pseudo-random numbers for reproducible text generation\n */\nexport class SeededRandom {\n  private seed: number | null = null;\n  private currentSeed: number = 0;\n\n  /**\n   * Set a seed for deterministic random generation\n   * @param seed - Integer seed value\n   */\n  public setSeed(seed: number): void {\n    if (!Number.isInteger(seed)) {\n      throw new Error('Seed must be an integer');\n    }\n    this.seed = Math.abs(seed) >>> 0; // Convert to 32-bit unsigned integer\n    this.currentSeed = this.seed;\n  }\n\n  /**\n   * Clear the seed and return to using Math.random()\n   */\n  public clearSeed(): void {\n    this.seed = null;\n    this.currentSeed = 0;\n  }\n\n  /**\n   * Get the current seed value\n   * @returns Current seed or null if using Math.random()\n   */\n  public getSeed(): number | null {\n    return this.seed;\n  }\n\n  /**\n   * Generate a random number between 0 and 1\n   * Uses LCG when seed is set, Math.random() otherwise\n   * @returns Random number between 0 and 1\n   */\n  public random(): number {\n    if (this.seed === null) {\n      return Math.random();\n    }\n    \n    // Linear Congruential Generator (LCG)\n    // Using parameters from Numerical Recipes: a=1664525, c=1013904223, m=2^32\n    this.currentSeed = (this.currentSeed * 1664525 + 1013904223) >>> 0;\n    return this.currentSeed / 0x100000000; // Convert to 0-1 range\n  }\n\n  /**\n   * Get a random integer between min (inclusive) and max (exclusive)\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random integer\n   */\n  public randomInt(min: number, max: number): number {\n    return Math.floor(this.random() * (max - min)) + min;\n  }\n\n  /**\n   * Get a random element from an array\n   * @param array - Array to choose from\n   * @returns Random element from array\n   */\n  public randomChoice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    const index = this.randomInt(0, array.length);\n    return array[index];\n  }\n\n  /**\n   * Get a weighted random element from arrays of values and weights\n   * @param values - Array of values\n   * @param cumulativeWeights - Array of cumulative weights\n   * @returns Weighted random value\n   */\n  public weightedChoice<T>(values: T[], cumulativeWeights: number[]): T {\n    if (values.length !== cumulativeWeights.length) {\n      throw new Error('Values and weights arrays must have same length');\n    }\n    if (values.length === 0) {\n      throw new Error('Cannot choose from empty arrays');\n    }\n\n    const random = this.random();\n    \n    // Find the first cumulative weight that is greater than our random number\n    for (let i = 0; i < cumulativeWeights.length; i++) {\n      if (random <= cumulativeWeights[i]) {\n        return values[i];\n      }\n    }\n    \n    // Fallback to last value (should not happen with proper weights)\n    return values[values.length - 1];\n  }\n}","/**\n * Grammar validation functionality\n */\nimport { ValidationResult } from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { VariableExpander } from '../core/VariableExpander.js';\n\nexport class GrammarValidator {\n  constructor(\n    private ruleManager: RuleManager,\n    private variableExpander: VariableExpander\n  ) {}\n\n  /**\n   * Perform comprehensive grammar validation to detect potential issues\n   * \n   * This method analyzes the entire grammar structure to identify problems that could\n   * cause parsing failures or unexpected behavior. It checks for missing references,\n   * circular dependencies, empty rules, and provides warnings for potential issues.\n   * \n   * @returns Comprehensive validation results object\n   */\n  public validate(): ValidationResult {\n    const missingRules: string[] = [];\n    const circularReferences: string[] = [];\n    const emptyRules: string[] = [];\n    const unreachableRules: string[] = [];\n    const warnings: string[] = [];\n\n    const allRules = this.ruleManager.getAllKeys();\n    const referencedRules = new Set<string>();\n\n    // Check each rule for issues\n    for (const ruleKey of allRules) {\n      // Check if rule is empty\n      if (this.isRuleEmpty(ruleKey)) {\n        emptyRules.push(ruleKey);\n      }\n\n      // Find all variables referenced by this rule and check if they exist\n      const referencedVariables = this.findRuleReferences(ruleKey);\n      for (const variable of referencedVariables) {\n        referencedRules.add(variable);\n        if (!this.ruleManager.hasRule(variable)) {\n          if (!missingRules.includes(variable)) {\n            missingRules.push(variable);\n          }\n        }\n      }\n    }\n\n    // Find unreachable rules (rules that exist but are never referenced)\n    for (const ruleKey of allRules) {\n      if (!referencedRules.has(ruleKey) && !this.isRootRule(ruleKey)) {\n        unreachableRules.push(ruleKey);\n      }\n    }\n\n    // Check for circular references\n    const circularRefs = this.variableExpander.findCircularReferences();\n    circularReferences.push(...circularRefs);\n\n    // Generate warnings\n    if (emptyRules.length > 0) {\n      warnings.push(`Found ${emptyRules.length} empty rules that may cause issues`);\n    }\n    if (unreachableRules.length > 5) {\n      warnings.push(`Found ${unreachableRules.length} unreachable rules - consider cleanup`);\n    }\n    if (allRules.length > 100) {\n      warnings.push(`Large grammar with ${allRules.length} rules - consider organizing into groups`);\n    }\n\n    const isValid = missingRules.length === 0 && \n                   circularReferences.length === 0 && \n                   emptyRules.length === 0;\n\n    return {\n      isValid,\n      missingRules,\n      circularReferences,\n      emptyRules,\n      unreachableRules,\n      warnings\n    };\n  }\n\n  /**\n   * Check if a rule is empty (has no values or only empty values)\n   * @private\n   */\n  private isRuleEmpty(ruleKey: string): boolean {\n    const ruleType = this.ruleManager.getRuleType(ruleKey);\n    \n    switch (ruleType) {\n      case 'static': {\n        const staticRule = this.ruleManager.getGrammar()[ruleKey];\n        return !staticRule || staticRule.length === 0 || \n               staticRule.every(value => !value || value.trim() === '');\n      }\n      \n      case 'function':\n        // Function rules can't be easily checked for emptiness\n        return false;\n        \n      case 'weighted':\n      case 'conditional':\n      case 'sequential':\n      case 'template':\n      case 'range':\n        // These rule types are handled by their respective managers\n        // and should have validation in place during creation\n        return false;\n        \n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Find all variables referenced by a rule\n   * @private\n   */\n  private findRuleReferences(ruleKey: string): string[] {\n    const references: string[] = [];\n    const ruleType = this.ruleManager.getRuleType(ruleKey);\n    \n    switch (ruleType) {\n      case 'static': {\n        const staticRule = this.ruleManager.getGrammar()[ruleKey];\n        if (staticRule) {\n          for (const value of staticRule) {\n            const variables = this.variableExpander.findVariables(value);\n            references.push(...variables.filter(v => !v.startsWith('@')));\n          }\n        }\n        break;\n      }\n        \n      case 'function':\n        // Function rules are dynamic, can't analyze statically\n        break;\n        \n      // Other rule types would need specific analysis\n      // This is a simplified implementation\n    }\n    \n    // Remove duplicates\n    return Array.from(new Set(references));\n  }\n\n  /**\n   * Check if a rule is likely a root rule (commonly used entry points)\n   * @private\n   */\n  private isRootRule(ruleKey: string): boolean {\n    const rootPatterns = [\n      /^(main|start|root|entry|begin)$/i,\n      /^(sentence|story|text|output)$/i,\n      /^(template|pattern|format)$/i\n    ];\n    \n    return rootPatterns.some(pattern => pattern.test(ruleKey));\n  }\n\n  /**\n   * Validate a specific text string for missing variables\n   * @param text - Text to validate\n   * @returns Array of missing variable names\n   */\n  public validateText(text: string): string[] {\n    return this.variableExpander.findMissingVariables(text);\n  }\n\n  /**\n   * Quick validation check - returns true if grammar is valid\n   * @returns True if grammar passes basic validation\n   */\n  public isValid(): boolean {\n    const result = this.validate();\n    return result.isValid;\n  }\n\n  /**\n   * Get validation summary as a readable string\n   * @returns Human-readable validation summary\n   */\n  public getValidationSummary(): string {\n    const result = this.validate();\n    const lines: string[] = [];\n    \n    if (result.isValid) {\n      lines.push('✅ Grammar validation passed');\n    } else {\n      lines.push('❌ Grammar validation failed');\n    }\n    \n    if (result.missingRules.length > 0) {\n      lines.push(`Missing rules: ${result.missingRules.join(', ')}`);\n    }\n    \n    if (result.circularReferences.length > 0) {\n      lines.push(`Circular references: ${result.circularReferences.join(', ')}`);\n    }\n    \n    if (result.emptyRules.length > 0) {\n      lines.push(`Empty rules: ${result.emptyRules.join(', ')}`);\n    }\n    \n    if (result.unreachableRules.length > 0) {\n      lines.push(`Unreachable rules: ${result.unreachableRules.slice(0, 5).join(', ')}${result.unreachableRules.length > 5 ? '...' : ''}`);\n    }\n    \n    if (result.warnings.length > 0) {\n      lines.push('Warnings:');\n      for (const warning of result.warnings) {\n        lines.push(`  - ${warning}`);\n      }\n    }\n    \n    return lines.join('\\n');\n  }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n"],"names":["root","factory","exports","module","define","amd","this","ArticleModifier","PluralizationModifier","OrdinalModifier","CapitalizationModifier","EnglishPossessiveModifier","name","condition","text","test","transform","replace","match","word","endsWith","priority","PunctuationCleanupModifier","trim","EnglishVerbAgreementModifier","AllEnglishModifiers","BasicEnglishModifiers","Parser","constructor","modifiers","Map","random","SeededRandom","ruleManager","RuleManager","variableExpander","VariableExpander","complexityAnalyzer","ComplexityAnalyzer","probabilityAnalyzer","ProbabilityAnalyzer","validator","GrammarValidator","errorHandler","ErrorHandler","addRule","key","values","addRules","rules","addFunctionRule","fn","addWeightedRule","weights","addConditionalRule","rule","addSequentialRule","options","cycle","addRangeRule","config","addTemplateRule","hasRule","removeRule","clear","hasFunctionRule","hasWeightedRule","hasConditionalRule","hasSequentialRule","hasRangeRule","hasTemplateRule","removeFunctionRule","removeWeightedRule","removeConditionalRule","removeSequentialRule","removeRangeRule","removeTemplateRule","clearFunctionRules","clearWeightedRules","clearConditionalRules","clearSequentialRules","clearRangeRules","clearTemplateRules","resetSequentialRule","getGrammar","addModifier","modifier","Error","set","removeModifier","delete","hasModifier","has","getModifiers","Array","from","sort","a","b","loadModifier","loadModifiers","clearModifiers","clearAll","parse","preserveContext","expanded","expandVariables","applyModifiers","originalText","parseWithTiming","startTime","Date","now","expansionStart","expansionEnd","modifierStart","result","modifierEnd","timing","totalMs","expansionMs","modifierMs","safeParse","validateFirst","maxAttempts","attempts","validation","validate","isValid","error","missingRules","length","join","success","getHelpfulError","currentDepth","getMaxDepth","setMaxDepth","Math","max","floor","context","modifiedText","sortedModifiers","parseBatch","texts","isArray","results","i","shouldPreserve","push","generateVariations","count","seed","Number","isInteger","variations","originalSeed","getSeed","undefined","setSeed","clearSeed","depth","setRandomSeed","clearRandomSeed","getRandomSeed","clearReferences","getContext","calculateRuleComplexity","ruleKey","visited","Set","maxDepth","calculateTotalComplexity","calculateProbabilities","maxOutcomes","getMostProbableOutcome","getLeastProbableOutcome","findVariables","getStats","ruleStats","totalRules","total","rulesByType","static","function","weighted","conditional","sequential","range","template","totalModifiers","size","hasRandomSeed","clone","cloned","grammar","exportConfig","map","m","settings","randomSeed","optimize","warnings","suggestions","concat","circularReferences","optimized","analyzeRules","ruleName","complexity","totalComplexity","averageDepth","mostComplex","ruleDetails","type","ruleType","variables","Object","keys","averageComplexity","mostComplexRules","r","isFinite","newVisited","add","getRuleType","calculateStaticRuleComplexity","calculateWeightedRuleComplexity","POSITIVE_INFINITY","calculateConditionalRuleComplexity","calculateSequentialRuleComplexity","calculateRangeRuleComplexity","calculateTemplateRuleComplexity","allRuleKeys","getAllKeys","complexityByRule","some","w","includes","uniqueWarnings","uniqueCircularRefs","filter","slice","finiteRules","reduce","sum","ruleCount","value","valueVariables","valueComplexity","variable","varResult","getWeightedRuleData","getConditionalRuleData","conditions","conditionComplexity","then","default","getSequentialRuleData","getRangeRuleData","step","min","getTemplateRuleData","templateVariables","variableComplexity","nestedVariable","createProbabilityResult","outcome","probability","probabilityTree","outcomes","calculateRuleProbabilities","totalOutcomes","mostProbable","leastProbable","averageProbability","entropy","sortedOutcomes","log2","reverse","o","calculateStaticRuleProbabilities","calculateWeightedRuleProbabilities","calculateRangeRuleProbabilities","calculateTemplateRuleProbabilities","calculateSequentialRuleProbabilities","calculateConditionalRuleProbabilities","baseProb","expandedOutcomes","expandVariablesWithProbabilities","totalWeight","weight","toString","toFixed","currentOutcomes","varName","entries","newOutcomes","valueProbability","currentOutcome","expandedValue","RegExp","nestedVariables","nestedOutcomes","nestedOutcome","remainingVariables","finalOutcomes","conditionProbability","baseProbability","variableProbabilities","varOutcome","combinedProbability","probabilityNode","children","lines","message","isRecursionError","isFunctionRuleError","isWeightError","isMissingRuleError","validateText","emptyRules","toLowerCase","createMissingRuleError","createCircularReferenceError","createFunctionRuleError","originalError","createWeightValidationError","createRecursionDepthError","variablePattern","referenceValues","currentContext","clearContext","expandVariablesRecursive","lastIndex","startsWith","refKey","substring","refValue","get","generateValue","regex","source","exec","findMissingVariables","missing","findCircularReferences","startRule","circular","checkRuleForCircularReferences","allKeys","sampleValue","EnglishArticleModifier","EnglishPluralizationModifier","EnglishOrdinalModifier","EnglishCapitalizationModifier","punctuation","letter","toUpperCase","num","number","parseInt","lastTwoDigits","quantifier","noun","pluralNoun","lowerNoun","irregularPlurals","plural","original","charAt","pluralize","PossessiveModifier","VerbAgreementModifier","ConditionalRuleManager","BaseRuleManager","hasDefault","if","c","randomChoice","SequentialRuleManager","index","_context","_random","resetRule","RangeRuleManager","steps","randomInt","randomValue","TemplateRuleManager","templateVars","getRule","getKeys","getRuleData","weightSum","abs","cumulativeWeights","cumSum","weightedChoice","staticRules","StaticRuleManager","functionRules","FunctionRuleManager","weightedRules","WeightedRuleManager","conditionalRules","sequentialRules","rangeRules","templateRules","ruleManagers","manager","removed","clearStaticRules","currentSeed","array","unreachableRules","allRules","referencedRules","isRuleEmpty","referencedVariables","findRuleReferences","isRootRule","circularRefs","staticRule","every","references","v","pattern","getValidationSummary","warning","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}