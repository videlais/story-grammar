{"version":3,"file":"story-grammar.bundle.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAsB,aAAID,IAE1BD,EAAmB,aAAIC,GACxB,CATD,CASGK,KAAM,I,6WCCI,EAAAC,uBAAmC,CAC9CC,KAAM,kBACNC,UAAYC,GACH,qBAAqBC,KAAKD,GAEnCE,UAAYF,GAEHA,EAAKG,QAAQ,iCAAkC,UAExDC,SAAU,IAOC,EAAAC,6BAAyC,CACpDP,KAAM,uBACNC,UAAYC,GAEH,+FAA+FC,KAAKD,IACpG,mJAAmJC,KAAKD,IACxJ,2BAA2BC,KAAKD,GAEzCE,UAAYF,GACHA,EAAKG,QAAQ,4OAClB,CAACG,EAAOC,EAAYC,KAClB,MAAMC,EA4Jd,SAAmBD,GACjB,MAAME,EAAYF,EAAKG,cAGjBC,EAA8C,CAClD,SAAY,UACZ,SAAY,WACZ,OAAU,UACV,QAAW,SACX,SAAY,WACZ,QAAW,WACX,WAAc,aACd,KAAQ,SACR,SAAY,aACZ,KAAQ,OACR,SAAY,UACZ,UAAa,WACb,MAAS,QACT,KAAQ,QACR,MAAS,QACT,OAAU,UACV,OAAU,QACV,QAAW,WACX,MAAS,WACT,MAAS,UACT,SAAY,WACZ,OAAU,UACV,OAAU,SACV,UAAa,WACb,WAAc,YACd,MAAS,OACT,KAAQ,OACR,UAAa,YACb,IAAO,OACP,MAAS,UACT,SAAY,WACZ,QAAW,SACX,IAAO,SACP,KAAQ,OACR,MAAS,OACT,KAAQ,OACR,QAAW,WACX,OAAU,QACV,MAAS,SACT,MAAS,QACT,SAAY,WACZ,OAAU,SACV,KAAQ,SACR,KAAQ,SACR,WAAc,aACd,MAAS,UACT,MAAS,SACT,SAAY,WACZ,KAAQ,SACR,MAAS,OACT,MAAS,OACT,IAAO,MACP,OAAU,WACV,OAAU,QACV,WAAc,YACd,QAAW,WACX,MAAS,QACT,MAAS,OACT,OAAU,UACV,QAAW,SACX,MAAS,QACT,UAAa,YACb,KAAQ,QACR,KAAQ,MACR,GAAM,OACN,YAAe,cACf,OAAU,SACV,WAAc,YACd,OAAU,QACV,KAAQ,UACR,OAAU,QACV,WAAc,YACd,OAAU,SACV,MAAS,UACT,KAAQ,SACR,OAAU,SACV,MAAS,QACT,OAAU,SACV,QAAW,UACX,SAAY,UACZ,QAAW,SACX,MAAS,QACT,SAAY,UACZ,UAAa,WACb,SAAY,WACZ,QAAW,WACX,OAAU,SACV,MAAS,UACT,MAAS,QACT,MAAS,QACT,KAAQ,OACR,SAAY,YACZ,OAAU,WACV,KAAQ,QACR,OAAU,WACV,MAAS,UACT,KAAQ,QACR,KAAQ,SACR,MAAS,SAIX,OAAIA,EAAiBF,IA8DiBG,EA7DZD,EAAiBF,IA6DvBI,EA3DEN,KA6DLM,EAASC,cACjBF,EAAOE,cAIZD,EAAS,KAAOA,EAAS,GAAGC,cACvBF,EAAOG,OAAO,GAAGD,cAAgBF,EAAOI,MAAM,GAIhDJ,GAjEH,SAASZ,KAAKS,IAAc,SAAST,KAAKS,GACrCF,EAAO,KAIZ,4BAA4BP,KAAKS,GAC5BF,EAAKS,MAAM,GAAI,GAAK,MAIzB,aAAahB,KAAKS,GACbF,EAAO,IAIZ,QAAQP,KAAKS,GAEK,CAAC,SAAU,QAAS,QAAS,QAAS,OAAQ,OAAQ,OAAQ,gBAClEQ,SAASR,GAChBF,EAAO,IAETA,EAAKL,QAAQ,QAAS,OAI3B,4BAA4BF,KAAKS,GAEf,CAClB,QAAS,QAAS,OAAQ,QAAS,SAAU,QAAS,QACtD,OAAQ,OAAQ,MAAO,SAAU,QAAS,YAAa,OACvD,WAAY,OAAQ,UAAW,OAAQ,UAEzBQ,SAASR,GAChBF,EAAO,IAETA,EAAO,MAIZ,aAAaP,KAAKS,GACbF,EAAO,KAalB,IAAsBM,EAAkBD,CARxC,CA7T2BM,CAAUX,GAC7B,MAAO,GAAGD,KAAcE,MAI9BL,SAAU,GAOC,EAAAgB,uBAAmC,CAC9CtB,KAAM,kBACNC,UAAYC,GAEH,UAAUC,KAAKD,GAExBE,UAAYF,GACHA,EAAKG,QAAQ,aAAc,CAACG,EAAOe,KACxC,MAAMC,EAASC,SAASF,EAAK,IAIvBG,EAAgBF,EAAS,IAG/B,GAAsB,KAAlBE,GAA0C,KAAlBA,GAA0C,KAAlBA,EAClD,OAAOH,EAAM,KAIf,OATkBC,EAAS,IAUzB,KAAK,EACH,OAAOD,EAAM,KACf,KAAK,EACH,OAAOA,EAAM,KACf,KAAK,EACH,OAAOA,EAAM,KACf,QACE,OAAOA,EAAM,QAIrBjB,SAAU,GAOC,EAAAqB,8BAA0C,CACrD3B,KAAM,wBACNC,UAAYC,GAEH,gBAAgBC,KAAKD,GAE9BE,UAAYF,GAEHA,EAAKG,QAAQ,qBAAsB,CAACG,EAAOoB,EAAaC,IACtDD,EAAcC,EAAOZ,eAGhCX,SAAU,GAOC,EAAAwB,0BAAsC,CACjD9B,KAAM,qBACNC,UAAYC,GAEH,wBAAwBC,KAAKD,IAAS,gBAAgBC,KAAKD,GAEpEE,UAAYF,IAEVA,EAAOA,EAAKG,QAAQ,2BAA4B,CAACG,EAAOuB,IAC/CA,EAAKC,SAAS,KAAOD,EAAO,IAAMA,EAAO,OAItC1B,QAAQ,aAAc,QAIpCC,SAAU,GAOC,EAAA2B,6BAAyC,CACpDjC,KAAM,uBACNC,UAAYC,GAEH,yBAAyBC,KAAKD,IAC9B,6CAA6CC,KAAKD,IAClD,0BAA0BC,KAAKD,IAC/B,8CAA8CC,KAAKD,GAE5DE,UAAYF,IAQVA,GAHAA,GAHAA,EAAOA,EAAKG,QAAQ,0BAA2B,UAGnCA,QAAQ,8CAA+C,WAGvDA,QAAQ,2BAA4B,WAGpCA,QAAQ,+CAAgD,WAItEC,SAAU,GAOC,EAAA4B,2BAAuC,CAClDlC,KAAM,qBACNC,UAAYC,GAEH,SAASC,KAAKD,IAAS,aAAaC,KAAKD,IAAS,aAAaC,KAAKD,GAE7EE,UAAYF,IAQVA,GAHAA,GAHAA,EAAOA,EAAKG,QAAQ,UAAW,MAGnBA,QAAQ,gBAAiB,OAGzBA,QAAQ,wBAAyB,UAGjC8B,OAId7B,SAAU,GAqMC,EAAA8B,oBAAsB,CACjC,EAAArC,uBACA,EAAAQ,6BACA,EAAAe,uBACA,EAAAK,8BACA,EAAAG,0BACA,EAAAG,6BACA,EAAAC,4BAMW,EAAAG,sBAAwB,CACnC,EAAAtC,uBACA,EAAAQ,6BACA,EAAAe,uB,yhBCpYF,yBAGA,+BAAS,wEAAAgB,MAAM,G,mGCiBf,yCACA,kCACA,sCACA,4CACA,6CACA,4CACA,kCAEA,MAAaA,EAaX,WAAAC,GAFQ,KAAAC,UAAmC,IAAIC,IAI7C3C,KAAK4C,OAAS,IAAI,EAAAC,aAClB7C,KAAK8C,YAAc,IAAI,EAAAC,YACvB/C,KAAKgD,iBAAmB,IAAI,EAAAC,iBAAiBjD,KAAK8C,YAAa9C,KAAK4C,QACpE5C,KAAKkD,mBAAqB,IAAI,EAAAC,mBAAmBnD,KAAK8C,YAAa9C,KAAKgD,kBACxEhD,KAAKoD,oBAAsB,IAAI,EAAAC,oBAAoBrD,KAAK8C,YAAa9C,KAAKgD,kBAC1EhD,KAAKsD,UAAY,IAAI,EAAAC,iBAAiBvD,KAAK8C,YAAa9C,KAAKgD,kBAC7DhD,KAAKwD,aAAe,IAAI,EAAAC,aAAazD,KAAK8C,YAAa9C,KAAKsD,UAC9D,CAOO,OAAAI,CAAQC,EAAaC,GAC1B5D,KAAK8C,YAAYY,QAAQC,EAAKC,EAChC,CAKO,QAAAC,CAASC,GACd9D,KAAK8C,YAAYe,SAASC,EAC5B,CAKO,eAAAC,CAAgBJ,EAAaK,GAClChE,KAAK8C,YAAYiB,gBAAgBJ,EAAKK,EACxC,CAKO,eAAAC,CAAgBN,EAAaC,EAAkBM,GACpDlE,KAAK8C,YAAYmB,gBAAgBN,EAAKC,EAAQM,EAChD,CAKO,kBAAAC,CAAmBR,EAAaS,GACrCpE,KAAK8C,YAAYqB,mBAAmBR,EAAKS,EAC3C,CAKO,iBAAAC,CAAkBV,EAAaC,EAAkBU,EAA8B,CAAEC,OAAO,IAC7FvE,KAAK8C,YAAYuB,kBAAkBV,EAAKC,EAAQU,EAClD,CAKO,YAAAE,CAAab,EAAac,GAC/BzE,KAAK8C,YAAY0B,aAAab,EAAKc,EACrC,CAKO,eAAAC,CAAgBf,EAAaS,GAClCpE,KAAK8C,YAAY4B,gBAAgBf,EAAKS,EACxC,CAGO,OAAAO,CAAQhB,GAAwB,OAAO3D,KAAK8C,YAAY6B,QAAQhB,EAAM,CACtE,UAAAiB,CAAWjB,GAAwB,OAAO3D,KAAK8C,YAAY8B,WAAWjB,EAAM,CAC5E,KAAAkB,GAAgB7E,KAAK8C,YAAY+B,OAAS,CAG1C,eAAAC,CAAgBnB,GAAwB,OAAO3D,KAAK8C,YAAYgC,gBAAgBnB,EAAM,CACtF,eAAAoB,CAAgBpB,GAAwB,OAAO3D,KAAK8C,YAAYiC,gBAAgBpB,EAAM,CACtF,kBAAAqB,CAAmBrB,GAAwB,OAAO3D,KAAK8C,YAAYkC,mBAAmBrB,EAAM,CAC5F,iBAAAsB,CAAkBtB,GAAwB,OAAO3D,KAAK8C,YAAYmC,kBAAkBtB,EAAM,CAC1F,YAAAuB,CAAavB,GAAwB,OAAO3D,KAAK8C,YAAYoC,aAAavB,EAAM,CAChF,eAAAwB,CAAgBxB,GAAwB,OAAO3D,KAAK8C,YAAYqC,gBAAgBxB,EAAM,CAGtF,kBAAAyB,CAAmBzB,GAAwB,OAAO3D,KAAK8C,YAAYsC,mBAAmBzB,EAAM,CAC5F,kBAAA0B,CAAmB1B,GAAwB,OAAO3D,KAAK8C,YAAYuC,mBAAmB1B,EAAM,CAC5F,qBAAA2B,CAAsB3B,GAAwB,OAAO3D,KAAK8C,YAAYwC,sBAAsB3B,EAAM,CAClG,oBAAA4B,CAAqB5B,GAAwB,OAAO3D,KAAK8C,YAAYyC,qBAAqB5B,EAAM,CAChG,eAAA6B,CAAgB7B,GAAwB,OAAO3D,KAAK8C,YAAY0C,gBAAgB7B,EAAM,CACtF,kBAAA8B,CAAmB9B,GAAwB,OAAO3D,KAAK8C,YAAY2C,mBAAmB9B,EAAM,CAG5F,kBAAA+B,GAA6B1F,KAAK8C,YAAY4C,oBAAsB,CACpE,kBAAAC,GAA6B3F,KAAK8C,YAAY6C,oBAAsB,CACpE,qBAAAC,GAAgC5F,KAAK8C,YAAY8C,uBAAyB,CAC1E,oBAAAC,GAA+B7F,KAAK8C,YAAY+C,sBAAwB,CACxE,eAAAC,GAA0B9F,KAAK8C,YAAYgD,iBAAmB,CAC9D,kBAAAC,GAA6B/F,KAAK8C,YAAYiD,oBAAsB,CAGpE,mBAAAC,CAAoBrC,GAAwB,OAAO3D,KAAK8C,YAAYkD,oBAAoBrC,EAAM,CAC9F,UAAAsC,GAAwB,OAAOjG,KAAK8C,YAAYmD,YAAc,CAO9D,WAAAC,CAAYC,G,MACjB,IAAKA,GAAgC,iBAAbA,EACtB,MAAM,IAAIC,MAAM,8BAElB,IAAKD,EAASjG,MAAiC,iBAAlBiG,EAASjG,KACpC,MAAM,IAAIkG,MAAM,6BAElB,GAAkC,mBAAvBD,EAAShG,UAClB,MAAM,IAAIiG,MAAM,2CAElB,GAAkC,mBAAvBD,EAAS7F,UAClB,MAAM,IAAI8F,MAAM,2CAGlBpG,KAAK0C,UAAU2D,IAAIF,EAASjG,KAAM,OAAF,wBAC3BiG,GAAQ,CACX3F,SAA2B,QAAjB,EAAA2F,EAAS3F,gBAAQ,QAAI,IAEnC,CAKO,cAAA8F,CAAepG,GACpB,OAAOF,KAAK0C,UAAU6D,OAAOrG,EAC/B,CAKO,WAAAsG,CAAYtG,GACjB,OAAOF,KAAK0C,UAAU+D,IAAIvG,EAC5B,CAKO,YAAAwG,GACL,OAAOC,MAAMC,KAAK5G,KAAK0C,UAAUkB,UAAUiD,KAAK,CAACC,EAAGC,KAAK,QAAC,OAAW,QAAV,EAAAA,EAAEvG,gBAAQ,QAAI,IAAgB,QAAV,EAAAsG,EAAEtG,gBAAQ,QAAI,IAC/F,CAKO,YAAAwG,CAAab,GAClBnG,KAAKkG,YAAYC,EACnB,CAKO,aAAAc,CAAcvE,GACnB,IAAK,MAAMyD,KAAYzD,EACrB1C,KAAKkG,YAAYC,EAErB,CAKO,cAAAe,GACLlH,KAAK0C,UAAUmC,OACjB,CAKO,QAAAsC,GACLnH,KAAK6E,QACL7E,KAAKkH,gBACP,CAcO,KAAAE,CAAMhH,EAAciH,GAA2B,GACpD,GAAoB,iBAATjH,EACT,MAAM,IAAIgG,MAAM,yBAGlB,MAAMkB,EAAWtH,KAAKgD,iBAAiBuE,gBAAgBnH,EAAMiH,GAC7D,OAAOrH,KAAKwH,eAAeF,EAAU,CAAEG,aAAcrH,GACvD,CAKO,eAAAsH,CAAgBtH,EAAciH,GAA2B,GAC9D,MAAMM,EAAYC,KAAKC,MAEvB,GAAoB,iBAATzH,EACT,MAAM,IAAIgG,MAAM,yBAGlB,MAAM0B,EAAiBF,KAAKC,MACtBP,EAAWtH,KAAKgD,iBAAiBuE,gBAAgBnH,EAAMiH,GACvDU,EAAeH,KAAKC,MAEpBG,EAAgBJ,KAAKC,MACrBI,EAASjI,KAAKwH,eAAeF,EAAU,CAAEG,aAAcrH,IACvD8H,EAAcN,KAAKC,MAIzB,MAAO,CACLI,SACAE,OAAQ,CACNC,QALaR,KAAKC,MAKEF,EACpBU,YAAaN,EAAeD,EAC5BQ,WAAYJ,EAAcF,GAGhC,CAKO,SAAAO,CAAUnI,EAAckE,EAAwB,CAAC,GACtD,MAAM,gBACJ+C,GAAkB,EAAK,cACvBmB,GAAgB,EAAI,YACpBC,EAAc,GACZnE,EAEJ,IAAIoE,EAAW,EAEf,KAAOA,EAAWD,GAAa,CAC7BC,IAEA,IAEE,GAAIF,GAA8B,IAAbE,EAAgB,CACnC,MAAMC,EAAa3I,KAAK4I,WACxB,IAAKD,EAAWE,QAAS,CACvB,IAAIC,EAAQ,oBAIZ,OAHIH,EAAWI,aAAaC,OAAS,IACnCF,EAAQ,sCAAsCH,EAAWI,aAAaE,KAAK,SAEtE,CACLC,SAAS,EACTJ,QACAJ,WACAC,aAEJ,CACF,CAGA,MAAO,CACLO,SAAS,EACTjB,OAHajI,KAAKoH,MAAMhH,EAAMiH,GAI9BqB,WAGJ,CAAE,MAAOI,GACP,GAAIJ,GAAYD,EACd,MAAO,CACLS,SAAS,EACTJ,MAAO9I,KAAKwD,aAAa2F,gBAAgBL,EAAgB,CAAE1I,SAC3DsI,YAKJ,GAAI1I,KAAKwD,aAA+B,iBAAEsF,GAAiB,CACzD,MAAMM,EAAepJ,KAAKgD,iBAAiBqG,cAC3CrJ,KAAKgD,iBAAiBsG,YAAYC,KAAKC,IAAI,GAAID,KAAKE,MAAqB,GAAfL,IAC5D,CACF,CACF,CAEA,MAAO,CACLF,SAAS,EACTJ,MAAO,4BACPJ,WAEJ,CAMQ,cAAAlB,CAAepH,EAAcsJ,GACnC,IAAIC,EAAevJ,EAGnB,MAAMwJ,EAAkB5J,KAAK0G,eAE7B,IAAK,MAAMP,KAAYyD,EACjBzD,EAAShG,UAAUwJ,EAAcD,KACnCC,EAAexD,EAAS7F,UAAUqJ,EAAcD,IAIpD,OAAOC,CACT,CAOO,UAAAE,CAAWC,EAAiBzC,GAA2B,GAC5D,IAAKV,MAAMoD,QAAQD,GACjB,MAAM,IAAI1D,MAAM,0BAGlB,MAAM4D,EAAoB,GAE1B,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAMd,OAAQiB,IAAK,CACrC,MAAMC,EAAiB7C,GAAmB4C,EAAI,EAC9CD,EAAQG,KAAKnK,KAAKoH,MAAM0C,EAAMG,GAAIC,GACpC,CAEA,OAAOF,CACT,CAKO,kBAAAI,CAAmBhK,EAAciK,EAAeC,GACrD,GAAoB,iBAATlK,EACT,MAAM,IAAIgG,MAAM,yBAElB,IAAKmE,OAAOC,UAAUH,IAAUA,GAAS,EACvC,MAAM,IAAIjE,MAAM,oCAGlB,MAAMqE,EAAuB,GACvBC,EAAe1K,KAAK4C,OAAO+H,UAEjC,IACE,IAAK,IAAIV,EAAI,EAAGA,EAAII,EAAOJ,SACZW,IAATN,GACFtK,KAAK4C,OAAOiI,QAAQP,EAAOL,GAE7BQ,EAAWN,KAAKnK,KAAKoH,MAAMhH,GAAM,IAGnC,OAAOqK,CACT,C,QAEuB,OAAjBC,EACF1K,KAAK4C,OAAOiI,QAAQH,GAEpB1K,KAAK4C,OAAOkI,WAEhB,CACF,CAOO,WAAAxB,CAAYyB,GACjB/K,KAAKgD,iBAAiBsG,YAAYyB,EACpC,CAKO,WAAA1B,GACL,OAAOrJ,KAAKgD,iBAAiBqG,aAC/B,CAKO,aAAA2B,CAAcV,GACnBtK,KAAK4C,OAAOiI,QAAQP,EACtB,CAKO,eAAAW,GACLjL,KAAK4C,OAAOkI,WACd,CAKO,aAAAI,GACL,OAAOlL,KAAK4C,OAAO+H,SACrB,CAKO,eAAAQ,GACLnL,KAAKgD,iBAAiBmI,iBACxB,CAKO,UAAAC,GACL,OAAOpL,KAAKgD,iBAAiBoI,YAC/B,CAOO,uBAAAC,CAAwBC,EAAiBC,EAAuB,IAAIC,IAAOC,EAAmB,IACnG,OAAOzL,KAAKkD,mBAAmBmI,wBAAwBC,EAASC,EAASE,EAC3E,CAKO,wBAAAC,CAAyBD,EAAmB,IACjD,OAAOzL,KAAKkD,mBAAmBwI,yBAAyBD,EAC1D,CAKO,sBAAAE,CAAuBL,EAAiBG,EAAmB,GAAIG,EAAsB,KAC1F,OAAO5L,KAAKoD,oBAAoBuI,uBAAuBL,EAASG,EAAUG,EAC5E,CAKO,sBAAAC,CAAuBP,EAAiBG,EAAmB,GAAIG,EAAsB,KAC1F,OAAO5L,KAAKoD,oBAAoByI,uBAAuBP,EAASG,EAAUG,EAC5E,CAKO,uBAAAE,CAAwBR,EAAiBG,EAAmB,GAAIG,EAAsB,KAC3F,OAAO5L,KAAKoD,oBAAoB0I,wBAAwBR,EAASG,EAAUG,EAC7E,CAOO,QAAAhD,GACL,OAAO5I,KAAKsD,UAAUsF,UACxB,CAKO,aAAAmD,CAAc3L,GACnB,OAAOJ,KAAKgD,iBAAiB+I,cAAc3L,EAC7C,CAKO,eAAA+I,CAAgBL,EAAcY,GACnC,OAAO1J,KAAKwD,aAAa2F,gBAAgBL,EAAOY,EAClD,CAOO,QAAAsC,GACL,MAAMC,EAAYjM,KAAK8C,YAAYkJ,WAEnC,MAAO,CACLE,WAAYD,EAAUE,MACtBC,YAAa,CACXC,OAAQJ,EAAUI,OAClBC,SAAUL,EAAUK,SACpBC,SAAUN,EAAUM,SACpBC,YAAaP,EAAUO,YACvBC,WAAYR,EAAUQ,WACtBC,MAAOT,EAAUS,MACjBC,SAAUV,EAAUU,UAEtBC,eAAgB5M,KAAK0C,UAAUmK,KAC/BpB,SAAUzL,KAAKqJ,cACfyD,cAAyC,OAA1B9M,KAAK4C,OAAO+H,UAE/B,CAKO,KAAAoC,GACL,MAAMC,EAAS,IAAIxK,EAGbyK,EAAUjN,KAAKiG,aACrB+G,EAAOnJ,SAASoJ,GAGhBD,EAAO1D,YAAYtJ,KAAKqJ,eACxB,MAAMiB,EAAOtK,KAAKkL,gBACL,OAATZ,GACF0C,EAAOhC,cAAcV,GAIvB,MAAM5H,EAAY1C,KAAK0G,eAGvB,OAFAsG,EAAO/F,cAAcvE,GAEdsK,CACT,CAQO,YAAAE,GAEL,MAAO,CACLD,QAASjN,KAAKiG,aACdvD,UAAW1C,KAAK0G,eAAeyG,IAAIC,GAAKA,EAAElN,MAC1CmN,SAAU,CACR5B,SAAUzL,KAAKqJ,cACfiE,WAAYtN,KAAKkL,iBAGvB,CAKO,QAAAqC,GACL,MAAM5E,EAAa3I,KAAK4I,WAClB4E,EAAW,IAAI7E,EAAW6E,UAC1BC,EAAc,GAcpB,OAXIzN,KAAKgD,iBAAiBqG,cAAgB,IACxCoE,EAAYtD,KAAK,uDAIfnK,KAAK0C,UAAUmK,MAAQ,IACzBW,EAASrD,KAAK,mBAAmBnK,KAAK0C,UAAUmK,6CAGlDY,EAAYtD,QAAQxB,EAAWI,aAAa2E,OAAO/E,EAAWgF,qBAEvD,CACLH,WACAC,cACAG,WAAW,EAEf,CAKO,YAAAC,CAAaC,GAClB,GAAIA,EAAU,CACZ,MAAMC,EAAa/N,KAAKqL,wBAAwByC,GAChD,MAAO,CACLE,gBAAiBD,EAAWA,WAC5BE,aAAcF,EAAWhD,MACzBmD,YAAa,CAACH,EAAWD,UACzBL,YAAaM,EAAWP,SACxBW,YAAa,CACXjO,KAAM6N,EAAWD,SACjBM,KAAML,EAAWM,SACjBN,WAAYA,EAAWA,WACvBO,UAAWP,EAAWO,UACtBvD,MAAOgD,EAAWhD,OAGxB,CAAO,CACL,MAAMiD,EAAkBhO,KAAK0L,2BACvB+B,EAAc,IAAIO,EAAgBR,UAYxC,OATmBe,OAAOC,KAAKxO,KAAK8C,YAAYmD,cAAc+C,OAC7C,IACfyE,EAAYtD,KAAK,2DAGf6D,EAAgBA,gBAAkB,KACpCP,EAAYtD,KAAK,sDAGZ,CACL6D,gBAAiBA,EAAgBA,gBACjCC,aAAcD,EAAgBS,kBAC9BP,YAAaF,EAAgBU,iBAAiBvB,IAAIwB,GAAKA,EAAEb,UACzDL,cAEJ,CACF,EAhnBF,U,8HC1BA,2BACE,WAAAhL,CACUK,EACAE,GADA,KAAAF,YAAAA,EACA,KAAAE,iBAAAA,CACP,CAgBI,uBAAAqI,CACLC,EACAC,EAAuB,IAAIC,IAC3BC,EAAmB,IAEnB,MAAM+B,EAAqB,GACrBc,EAAyB,IAAI9C,IACnC,IAAI6C,EAAW,UACXN,EAAa,EACba,GAAW,EAGf,IAAK5O,KAAK8C,YAAY6B,QAAQ2G,GAC5B,MAAM,IAAIlF,MAAM,SAASkF,qBAI3B,GAAIC,EAAQ9E,IAAI6E,GAEd,OADAkC,EAASrD,KAAK,yCAAyCmB,MAChD,CACLwC,SAAUxC,EACVyC,WAAY,EACZM,SAAU,WACVO,UAAU,EACVN,UAAW,GACXvD,MAAOQ,EAAQsB,KACfW,YAKJ,GAAIjC,EAAQsB,MAAQpB,EAElB,OADA+B,EAASrD,KAAK,kBAAkBsB,gDACzB,CACLqC,SAAUxC,EACVyC,WAAY,EACZM,SAAU,YACVO,UAAU,EACVN,UAAW,GACXvD,MAAOQ,EAAQsB,KACfW,YAIJ,MAAMqB,EAAa,IAAIrD,IAAID,GAC3BsD,EAAWC,IAAIxD,GAGf,MAAM8C,EAAOpO,KAAK8C,YAAYiM,YAAYzD,GAG1C,OAFA+C,EAAWD,GAAQ,UAEXA,GACN,IAAK,SACHL,EAAa/N,KAAKgP,8BAA8B1D,EAASuD,EAAYpD,EAAU6C,EAAWd,GAC1F,MACF,IAAK,WACHO,EAAa/N,KAAKiP,gCAAgC3D,EAASuD,EAAYpD,EAAU6C,EAAWd,GAC5F,MACF,IAAK,WACHO,EAAaxD,OAAO2E,kBACpBN,GAAW,EACXpB,EAASrD,KAAK,kBAAkBmB,qDAChC,MACF,IAAK,cACHyC,EAAa/N,KAAKmP,mCAAmC7D,EAASuD,EAAYpD,EAAU6C,EAAWd,GAC/F,MACF,IAAK,aACHO,EAAa/N,KAAKoP,kCAAkC9D,EAASuD,EAAYpD,EAAU6C,EAAWd,GAC9F,MACF,IAAK,QACHO,EAAa/N,KAAKqP,6BAA6B/D,GAC/C,MACF,IAAK,WACHyC,EAAa/N,KAAKsP,gCAAgChE,EAASuD,EAAYpD,EAAU6C,EAAWd,GAC5F,MACF,QACEA,EAASrD,KAAK,0BAA0BmB,MACxCyC,EAAa,EAGjB,MAAO,CACLD,SAAUxC,EACVyC,aACAM,WACAO,WACAN,UAAW3H,MAAMC,KAAK0H,GACtBvD,MAAOQ,EAAQsB,KACfW,WAEJ,CAKO,wBAAA9B,CAAyBD,EAAmB,IACjD,MAAM8D,EAAcvP,KAAK8C,YAAY0M,aAC/BC,EAAuC,GACvCjC,EAAqB,GACrBG,EAA+B,GACrC,IAAIK,EAAkB,EAClBY,GAAW,EAGf,IAAK,MAAMtD,KAAWiE,EACpB,IACE,MAAMtH,EAASjI,KAAKqL,wBAAwBC,EAAS,IAAIE,IAAOC,GAChEgE,EAAiBtF,KAAKlC,GAEjBA,EAAO2G,SAGVZ,GAAmB/F,EAAO8F,WAF1Ba,GAAW,EAKbpB,EAASrD,QAAQlC,EAAOuF,UAEpBvF,EAAOuF,SAASkC,KAAKC,GAAKA,EAAErO,SAAS,wBACvCqM,EAAmBxD,KAAKmB,EAE5B,CAAE,MAAOxC,GACP0E,EAASrD,KAAK,0CAA0CmB,OAAaxC,KACrE2G,EAAiBtF,KAAK,CACpB2D,SAAUxC,EACVyC,WAAY,EACZM,SAAU,QACVO,UAAU,EACVN,UAAW,GACXvD,MAAO,EACPyC,SAAU,CAAC,UAAU1E,MAEzB,CAIF,MAAM8G,EAAiBjJ,MAAMC,KAAK,IAAI4E,IAAIgC,IACpCqC,EAAqBlJ,MAAMC,KAAK,IAAI4E,IAAImC,IAQxCe,EALqB,IAAIe,GAC5BK,OAAOnB,GAAKA,EAAEC,UACd/H,KAAK,CAACC,EAAGC,IAAMA,EAAEgH,WAAajH,EAAEiH,YAGS1M,MAAM,EAAG,GAG/C0O,EAAcN,EAAiBK,OAAOnB,GAAKA,EAAEC,UAC7CH,EAAoBsB,EAAY/G,OAAS,EAC3C+G,EAAYC,OAAO,CAACC,EAAKtB,IAAMsB,EAAMtB,EAAEZ,WAAY,GAAKgC,EAAY/G,OACpE,EAEJ,MAAO,CACLgF,gBAAiBY,EAAWZ,EAAkBzD,OAAO2E,kBACrDN,WACAsB,UAAWX,EAAYvG,OACvByG,mBACAhB,oBACAC,mBACAlB,SAAUoC,EACVjC,mBAAoBkC,EAExB,CAKQ,6BAAAb,CACN1D,EACAC,EACAE,EACA6C,EACAd,GAEA,MAAMpJ,EAAOpE,KAAK8C,YAAYmD,aAAaqF,GAC3C,IAAKlH,EAAM,OAAO,EAElB,IAAI4J,EAAkB,EAEtB,IAAK,MAAMmC,KAAS/L,EAAM,CACxB,MAAMgM,EAAiBpQ,KAAKgD,iBAAiB+I,cAAcoE,GAE3D,GAA8B,IAA1BC,EAAepH,OAEjBgF,GAAmB,MACd,CAEL,IAAIqC,EAAkB,EACtB,IAAK,MAAMC,KAAYF,EAErB,GADA9B,EAAUQ,IAAIwB,GACV/E,EAAQ9E,IAAI6J,GAEd9C,EAASrD,KAAK,yCAAyCmG,MACvDD,GAAmB,OACd,GAAI9E,EAAQsB,MAAQpB,EAEzB+B,EAASrD,KAAK,kBAAkBsB,+BAAsC6E,wCACtED,GAAmB,OACd,GAAIrQ,KAAK8C,YAAY6B,QAAQ2L,GAAW,CAC7C,MAAMC,EAAYvQ,KAAKqL,wBAAwBiF,EAAU/E,EAASE,GAClE,IAAK8E,EAAU3B,SACb,OAAOrE,OAAO2E,kBAEhBmB,GAAmBE,EAAUxC,WAC7BP,EAASrD,QAAQoG,EAAU/C,SAC7B,MACEA,EAASrD,KAAK,iBAAiBmG,qBAA4BhF,MAC3D+E,GAAmB,EAGvBrC,GAAmBqC,CACrB,CACF,CAEA,OAAOrC,CACT,CAKQ,+BAAAiB,CACN3D,EACAC,EACAE,EACA6C,EACAd,GAEA,MAAMpJ,EAAOpE,KAAK8C,YAAY0N,oBAAoBlF,GAClD,IAAKlH,EAAM,OAAO,EAElB,IAAI4J,EAAkB,EAEtB,IAAK,MAAMmC,KAAS/L,EAAKR,OAAQ,CAC/B,MAAMwM,EAAiBpQ,KAAKgD,iBAAiB+I,cAAcoE,GAE3D,GAA8B,IAA1BC,EAAepH,OACjBgF,GAAmB,MACd,CACL,IAAIqC,EAAkB,EACtB,IAAK,MAAMC,KAAYF,EAErB,GADA9B,EAAUQ,IAAIwB,GACV/E,EAAQ9E,IAAI6J,GACd9C,EAASrD,KAAK,yCAAyCmG,MACvDD,GAAmB,OACd,GAAI9E,EAAQsB,MAAQpB,EACzB+B,EAASrD,KAAK,kBAAkBsB,+BAAsC6E,wCACtED,GAAmB,OACd,GAAIrQ,KAAK8C,YAAY6B,QAAQ2L,GAAW,CAC7C,MAAMC,EAAYvQ,KAAKqL,wBAAwBiF,EAAU/E,EAASE,GAClE,IAAK8E,EAAU3B,SACb,OAAOrE,OAAO2E,kBAEhBmB,GAAmBE,EAAUxC,WAC7BP,EAASrD,QAAQoG,EAAU/C,SAC7B,MACEA,EAASrD,KAAK,iBAAiBmG,qBAA4BhF,MAC3D+E,GAAmB,EAGvBrC,GAAmBqC,CACrB,CACF,CAEA,OAAOrC,CACT,CAKQ,kCAAAmB,CACN7D,EACAC,EACAE,EACA6C,EACAd,GAEA,MAAMpJ,EAAOpE,KAAK8C,YAAY2N,uBAAuBnF,GACrD,IAAKlH,EAAM,OAAO,EAElB,IAAI4J,EAAkB,EAEtB,IAAK,MAAM7N,KAAaiE,EAAKsM,WAAY,CACvC,IAAIC,EAAsB,EAG1B,MAAM/M,EAASzD,EAAUyQ,MAAQzQ,EAAU0Q,SAAW,GAEtD,IAAK,MAAMV,KAASvM,EAAQ,CAC1B,MAAMwM,EAAiBpQ,KAAKgD,iBAAiB+I,cAAcoE,GAE3D,GAA8B,IAA1BC,EAAepH,OACjB2H,GAAuB,MAClB,CACL,IAAIN,EAAkB,EACtB,IAAK,MAAMC,KAAYF,EAErB,GADA9B,EAAUQ,IAAIwB,GACV/E,EAAQ9E,IAAI6J,GACd9C,EAASrD,KAAK,yCAAyCmG,MACvDD,GAAmB,OACd,GAAI9E,EAAQsB,MAAQpB,EACzB+B,EAASrD,KAAK,kBAAkBsB,+BAAsC6E,wCACtED,GAAmB,OACd,GAAIrQ,KAAK8C,YAAY6B,QAAQ2L,GAAW,CAC7C,MAAMC,EAAYvQ,KAAKqL,wBAAwBiF,EAAU/E,EAASE,GAClE,IAAK8E,EAAU3B,SACb,OAAOrE,OAAO2E,kBAEhBmB,GAAmBE,EAAUxC,WAC7BP,EAASrD,QAAQoG,EAAU/C,SAC7B,MACEA,EAASrD,KAAK,iBAAiBmG,qBAA4BhF,MAC3D+E,GAAmB,EAGvBM,GAAuBN,CACzB,CACF,CAEArC,GAAmB2C,CACrB,CAEA,OAAO3C,CACT,CAKQ,iCAAAoB,CACN9D,EACAC,EACAE,EACA6C,EACAd,GAEA,MAAMpJ,EAAOpE,KAAK8C,YAAYgO,sBAAsBxF,GACpD,IAAKlH,EAAM,OAAO,EAElB,IAAI4J,EAAkB,EAEtB,IAAK,MAAMmC,KAAS/L,EAAKR,OAAQ,CAC/B,MAAMwM,EAAiBpQ,KAAKgD,iBAAiB+I,cAAcoE,GAE3D,GAA8B,IAA1BC,EAAepH,OACjBgF,GAAmB,MACd,CACL,IAAIqC,EAAkB,EACtB,IAAK,MAAMC,KAAYF,EAErB,GADA9B,EAAUQ,IAAIwB,GACV/E,EAAQ9E,IAAI6J,GACd9C,EAASrD,KAAK,yCAAyCmG,MACvDD,GAAmB,OACd,GAAI9E,EAAQsB,MAAQpB,EACzB+B,EAASrD,KAAK,kBAAkBsB,+BAAsC6E,wCACtED,GAAmB,OACd,GAAIrQ,KAAK8C,YAAY6B,QAAQ2L,GAAW,CAC7C,MAAMC,EAAYvQ,KAAKqL,wBAAwBiF,EAAU/E,EAASE,GAClE,IAAK8E,EAAU3B,SACb,OAAOrE,OAAO2E,kBAEhBmB,GAAmBE,EAAUxC,WAC7BP,EAASrD,QAAQoG,EAAU/C,SAC7B,MACEA,EAASrD,KAAK,iBAAiBmG,qBAA4BhF,MAC3D+E,GAAmB,EAGvBrC,GAAmBqC,CACrB,CACF,CAEA,OAAOrC,CACT,CAKQ,4BAAAqB,CAA6B/D,GACnC,MAAMlH,EAAOpE,KAAK8C,YAAYiO,iBAAiBzF,GAC/C,IAAKlH,EAAM,OAAO,EAGlB,MAAM4M,EAAO5M,EAAK4M,MAAQ,EAG1B,OAFuBzH,KAAKE,OAAOrF,EAAKoF,IAAMpF,EAAK6M,KAAOD,GAAQ,CAGpE,CAKQ,+BAAA1B,CACNhE,EACAC,EACAE,EACA6C,EACAd,GAEA,MAAMpJ,EAAOpE,KAAK8C,YAAYoO,oBAAoB5F,GAClD,IAAKlH,EAAM,OAAO,EAElB,IAAI4J,EAAkB,EAGtB,MAAMmD,EAAoBnR,KAAKgD,iBAAiB+I,cAAc3H,EAAKuI,UAEnE,IAAK,MAAM2D,KAAYa,EAIrB,GAHA7C,EAAUQ,IAAIwB,GAGVlM,EAAKkK,UAAUgC,GAAW,CAC5B,MAAM1M,EAASQ,EAAKkK,UAAUgC,GAC9B,IAAIc,EAAqB,EAEzB,IAAK,MAAMjB,KAASvM,EAAQ,CAC1B,MAAMwM,EAAiBpQ,KAAKgD,iBAAiB+I,cAAcoE,GAE3D,GAA8B,IAA1BC,EAAepH,OACjBoI,GAAsB,MACjB,CACL,IAAIf,EAAkB,EACtB,IAAK,MAAMgB,KAAkBjB,EAE3B,GADA9B,EAAUQ,IAAIuC,GACV9F,EAAQ9E,IAAI4K,GACd7D,EAASrD,KAAK,yCAAyCkH,MACvDhB,GAAmB,OACd,GAAI9E,EAAQsB,MAAQpB,EACzB+B,EAASrD,KAAK,kBAAkBsB,+BAAsC4F,wCACtEhB,GAAmB,OACd,GAAIrQ,KAAK8C,YAAY6B,QAAQ0M,GAAiB,CACnD,MAAMd,EAAYvQ,KAAKqL,wBAAwBgG,EAAgB9F,EAASE,GACxE,IAAK8E,EAAU3B,SACb,OAAOrE,OAAO2E,kBAEhBmB,GAAmBE,EAAUxC,WAC7BP,EAASrD,QAAQoG,EAAU/C,SAC7B,MACEA,EAASrD,KAAK,iBAAiBkH,qBAAkC/F,MACjE+E,GAAmB,EAGvBe,GAAsBf,CACxB,CACF,CAEArC,GAAmBoD,CACrB,MAAO,GAAIpR,KAAK8C,YAAY6B,QAAQ2L,GAElC,GAAI/E,EAAQ9E,IAAI6J,GACd9C,EAASrD,KAAK,yCAAyCmG,MACvDtC,GAAmB,OACd,GAAIzC,EAAQsB,MAAQpB,EACzB+B,EAASrD,KAAK,kBAAkBsB,+BAAsC6E,wCACtEtC,GAAmB,MACd,CACL,MAAMuC,EAAYvQ,KAAKqL,wBAAwBiF,EAAU/E,EAASE,GAClE,IAAK8E,EAAU3B,SACb,OAAOrE,OAAO2E,kBAEhBlB,GAAmBuC,EAAUxC,WAC7BP,EAASrD,QAAQoG,EAAU/C,SAC7B,MAEAA,EAASrD,KAAK,iBAAiBmG,qBAA4BhF,MAC3D0C,GAAmB,EAIvB,OAAOA,CACT,E,gICteF,4BACE,WAAAvL,CACUK,EACAE,GADA,KAAAF,YAAAA,EACA,KAAAE,iBAAAA,CACP,CAMK,uBAAAsO,CACNC,EACAC,EACAlD,EAAsB,GACtBmD,EAAwD,IAExD,MAAO,CAAEF,UAASC,cAAalD,YAAWmD,kBAC5C,CAiBO,sBAAA9F,CACLL,EACAG,EAAmB,GACnBG,EAAsB,KAEtB,IAAK5L,KAAK8C,YAAY6B,QAAQ2G,GAC5B,MAAM,IAAIlF,MAAM,SAASkF,qBAG3B,MAAMkC,EAAqB,GACrBkE,EAAW1R,KAAK2R,2BAA2BrG,EAAS,IAAIE,IAAOC,EAAUG,EAAa4B,GAE5F,GAAwB,IAApBkE,EAAS1I,OACX,MAAO,CACL8E,SAAUxC,EACVoG,SAAU,GACVE,cAAe,EACfC,aAAc,GACdC,cAAe,GACfC,mBAAoB,EACpBC,QAAS,EACTpD,UAAU,EACVpB,YAKJ,MAAMyE,EAAiBP,EAAS7K,KAAK,CAACC,EAAGC,IAAMA,EAAEyK,YAAc1K,EAAE0K,aAG3DQ,EAAUN,EAAS1B,OAAO,CAACC,EAAKsB,IAChCA,EAAQC,YAAc,EACjBvB,EAAOsB,EAAQC,YAAcjI,KAAK2I,KAAKX,EAAQC,aAEjDvB,EACN,GAGG4B,EAAeI,EAAe5Q,MAAM,EAAG,IACvCyQ,EAAgBG,EAAe5Q,OAAO,IAAI8Q,UAG1CJ,EAAqBL,EAAS1I,OAAS,EACzC0I,EAAS1B,OAAO,CAACC,EAAKmC,IAAMnC,EAAMmC,EAAEZ,YAAa,GAAKE,EAAS1I,OAC/D,EAEJ,MAAO,CACL8E,SAAUxC,EACVoG,SAAUO,EACVL,cAAeF,EAAS1I,OACxB6I,eACAC,gBACAC,qBACAC,UACApD,UAAU,EACVpB,WAEJ,CAKO,sBAAA3B,CACLP,EACAG,EAAmB,GACnBG,EAAsB,KAGtB,OADiB5L,KAAK2L,uBAAuBL,EAASG,EAAUG,GAChDiG,aAAa,IAAM,IACrC,CAKO,uBAAA/F,CACLR,EACAG,EAAmB,GACnBG,EAAsB,KAGtB,OADiB5L,KAAK2L,uBAAuBL,EAASG,EAAUG,GAChDkG,cAAc,IAAM,IACtC,CAMQ,0BAAAH,CACNrG,EACAC,EACAE,EACAG,EACA4B,GAGA,GAAIjC,EAAQ9E,IAAI6E,GAEd,OADAkC,EAASrD,KAAK,yCAAyCmB,MAChD,CAACtL,KAAKsR,wBAAwBhG,EAAS,IAGhD,GAAIC,EAAQsB,MAAQpB,EAElB,OADA+B,EAASrD,KAAK,kBAAkBsB,wBAA+BH,MACxD,CAACtL,KAAKsR,wBAAwBhG,EAAS,IAGhD,MAAMuD,EAAa,IAAIrD,IAAID,GAK3B,OAJAsD,EAAWC,IAAIxD,GAEEtL,KAAK8C,YAAYiM,YAAYzD,IAG5C,IAAK,SACH,OAAOtL,KAAKqS,iCAAiC/G,EAASuD,EAAYpD,EAAUG,EAAa4B,GAC3F,IAAK,WACH,OAAOxN,KAAKsS,mCAAmChH,EAASuD,EAAYpD,EAAUG,EAAa4B,GAC7F,IAAK,QACH,OAAOxN,KAAKuS,gCAAgCjH,GAC9C,IAAK,WACH,OAAOtL,KAAKwS,mCAAmClH,EAASuD,EAAYpD,EAAUG,EAAa4B,GAC7F,IAAK,aACH,OAAOxN,KAAKyS,qCAAqCnH,EAASuD,EAAYpD,EAAUG,EAAa4B,GAC/F,IAAK,cACH,OAAOxN,KAAK0S,sCAAsCpH,EAASuD,EAAYpD,EAAUG,EAAa4B,GAChG,IAAK,WAEH,OADAA,EAASrD,KAAK,kBAAkBmB,kEACzB,CAACtL,KAAKsR,wBAAwB,aAAahG,KAAY,IAChE,QAEE,OADAkC,EAASrD,KAAK,0BAA0BmB,MACjC,CAACtL,KAAKsR,wBAAwBhG,EAAS,IAEpD,CAMQ,gCAAA+G,CACN/G,EACAC,EACAE,EACAG,EACA4B,GAEA,MAAMpJ,EAAOpE,KAAK8C,YAAYmD,aAAaqF,GAC3C,IAAKlH,GAAwB,IAAhBA,EAAK4E,OAChB,MAAO,GAGT,MAAM0I,EAAgC,GAChCiB,EAAW,EAAMvO,EAAK4E,OAE5B,IAAK,MAAMmH,KAAS/L,EAAM,CACxB,MAAMkK,EAAYtO,KAAKgD,iBAAiB+I,cAAcoE,GAEtD,GAAyB,IAArB7B,EAAUtF,OAEZ0I,EAASvH,KAAKnK,KAAKsR,wBAAwBnB,EAAOwC,QAC7C,CAEL,MAAMC,EAAmB5S,KAAK6S,iCAC5B1C,EAAO7B,EAAWqE,EAAUpH,EAASE,EAAUG,EAAa4B,GAE9DkE,EAASvH,QAAQyI,EACnB,CAEA,GAAIlB,EAAS1I,QAAU4C,EAAa,CAClC4B,EAASrD,KAAK,qBAAqByB,wBAAkCN,MACrE,KACF,CACF,CAEA,OAAOoG,CACT,CAGQ,kCAAAY,CAAmChH,EAAiBC,EAAsBE,EAAkBG,EAAqB4B,GACvH,MAAMpJ,EAAOpE,KAAK8C,YAAY0N,oBAAoBlF,GAClD,IAAKlH,EAAM,MAAO,GAElB,MAAMsN,EAAgC,GAChCoB,EAAc1O,EAAKF,QAAQ8L,OAAO,CAACC,EAAa8C,IAAmB9C,EAAM8C,EAAQ,GAEvF,IAAK,IAAI9I,EAAI,EAAGA,EAAI7F,EAAKR,OAAOoF,OAAQiB,IAAK,CAC3C,MAAMkG,EAAQ/L,EAAKR,OAAOqG,GAEpBuH,EADSpN,EAAKF,QAAQ+F,GACC6I,EAEvBxE,EAAYtO,KAAKgD,iBAAiB+I,cAAcoE,GAEtD,GAAyB,IAArB7B,EAAUtF,OACZ0I,EAASvH,KAAKnK,KAAKsR,wBAAwBnB,EAAOqB,QAC7C,CACL,MAAMoB,EAAmB5S,KAAK6S,iCAC5B1C,EAAO7B,EAAWkD,EAAajG,EAASE,EAAUG,EAAa4B,GAEjEkE,EAASvH,QAAQyI,EACnB,CAEA,GAAIlB,EAAS1I,QAAU4C,EAAa,CAClC4B,EAASrD,KAAK,qBAAqByB,wBAAkCN,MACrE,KACF,CACF,CAEA,OAAOoG,CACT,CAEQ,+BAAAa,CAAgCjH,GACtC,MAAMlH,EAAOpE,KAAK8C,YAAYiO,iBAAiBzF,GAC/C,IAAKlH,EAAM,MAAO,GAElB,MAAMsN,EAAgC,GAChCV,EAAO5M,EAAK4M,MAAQ,EAEpBQ,EAAc,GADGjI,KAAKE,OAAOrF,EAAKoF,IAAMpF,EAAK6M,KAAOD,GAAQ,GAGlE,IAAK,IAAIb,EAAQ/L,EAAK6M,IAAKd,GAAS/L,EAAKoF,IAAK2G,GAASa,EAAM,CAC3D,MAAMO,EAAwB,YAAdnN,EAAKgK,KAAqB+B,EAAM6C,WAAa7C,EAAM8C,QAAQ,GAC3EvB,EAASvH,KAAKnK,KAAKsR,wBAAwBC,EAASC,GACtD,CAEA,OAAOE,CACT,CAEQ,kCAAAc,CAAmClH,EAAiBC,EAAsBE,EAAkBG,EAAqB4B,G,MACvH,MAAMpJ,EAAOpE,KAAK8C,YAAYoO,oBAAoB5F,GAClD,IAAKlH,EAAM,MAAO,GAGlB,IAAI8O,EAAkB,CAAC,CAAE/C,MAAO/L,EAAKuI,SAAU6E,YAAa,IAG5D,IAAK,MAAO2B,EAASvP,KAAW2K,OAAO6E,QAAQhP,EAAKkK,WAAoC,CACtF,MAAM+E,EAAwD,GACxDC,EAAmB,EAAM1P,EAAOoF,OAEtC,IAAK,MAAMuK,KAAkBL,EAAiB,CAC5C,IAAK,MAAM/C,KAASvM,EAAQ,CAE1B,MAAM4P,EAAgBD,EAAepD,MAAM5P,QACzC,IAAIkT,OAAO,IAAIN,KAAY,KAC3BhD,GAIIuD,EAAkB1T,KAAKgD,iBAAiB+I,cAAcoE,GAC5D,GAAIuD,EAAgB1K,OAAS,EAAG,CAE9B,MAAM2K,EAAiB3T,KAAK6S,iCAC1BW,EAAeE,EAAiBH,EAAe/B,YAAc8B,EAC7D/H,EAASE,EAAUG,EAAa4B,GAElC,IAAK,MAAMoG,KAAiBD,EAC1BN,EAAYlJ,KAAK,CACfgG,MAAOyD,EAAcrC,QACrBC,YAAaoC,EAAcpC,aAGjC,MACE6B,EAAYlJ,KAAK,CACfgG,MAAOqD,EACPhC,YAAa+B,EAAe/B,YAAc8B,IAI9C,GAAID,EAAYrK,QAAU4C,EAAa,CACrC4B,EAASrD,KAAK,qBAAqByB,iCAA2CN,MAC9E,KACF,CACF,CACA,GAAI+H,EAAYrK,QAAU4C,EAAa,KACzC,CAGA,GADAsH,EAAkBG,EACdH,EAAgBlK,QAAU4C,EAAa,KAC7C,CAGA,MAAMiI,EAAqB7T,KAAKgD,iBAAiB+I,eAAgC,QAAlB,EAAAmH,EAAgB,UAAE,eAAE/C,QAAS,IAC5F,GAAI0D,EAAmB7K,OAAS,EAAG,CACjC,MAAM8K,EAA0D,GAEhE,IAAK,MAAMvC,KAAW2B,EAAiB,CACrC,MAAMN,EAAmB5S,KAAK6S,iCAC5BtB,EAAQpB,MAAO0D,EAAoBtC,EAAQC,YAC3CjG,EAASE,EAAUG,EAAa4B,GAElC,IAAK,MAAMlG,KAAYsL,EACrBkB,EAAc3J,KAAK,CACjBgG,MAAO7I,EAASiK,QAChBC,YAAalK,EAASkK,cAI1B,GAAIsC,EAAc9K,QAAU4C,EAAa,KAC3C,CAEAsH,EAAkBY,CACpB,CAGA,OAAOZ,EAAgB/F,IAAIoE,GACzBvR,KAAKsR,wBAAwBC,EAAQpB,MAAOoB,EAAQC,aAExD,CAEQ,oCAAAiB,CAAqCnH,EAAiBC,EAAsBE,EAAkBG,EAAqB4B,GACzH,MAAMpJ,EAAOpE,KAAK8C,YAAYgO,sBAAsBxF,GACpD,IAAKlH,EAAM,MAAO,GAElB,MAAMsN,EAAgC,GAChCiB,EAAW,EAAMvO,EAAKR,OAAOoF,OAEnC,IAAK,MAAMmH,KAAS/L,EAAKR,OAAQ,CAC/B,MAAM0K,EAAYtO,KAAKgD,iBAAiB+I,cAAcoE,GAEtD,GAAyB,IAArB7B,EAAUtF,OACZ0I,EAASvH,KAAKnK,KAAKsR,wBAAwBnB,EAAOwC,QAC7C,CACL,MAAMC,EAAmB5S,KAAK6S,iCAC5B1C,EAAO7B,EAAWqE,EAAUpH,EAASE,EAAUG,EAAa4B,GAE9DkE,EAASvH,QAAQyI,EACnB,CAEA,GAAIlB,EAAS1I,QAAU4C,EAAa,CAClC4B,EAASrD,KAAK,qBAAqByB,wBAAkCN,MACrE,KACF,CACF,CAEA,OAAOoG,CACT,CAEQ,qCAAAgB,CAAsCpH,EAAiBC,EAAsBE,EAAkBG,EAAqB4B,GAC1H,MAAMpJ,EAAOpE,KAAK8C,YAAY2N,uBAAuBnF,GACrD,IAAKlH,EAAM,MAAO,GAElB,MAAMsN,EAAgC,GAChCqC,EAAuB,EAAM3P,EAAKsM,WAAW1H,OAEnD,IAAK,MAAM7I,KAAaiE,EAAKsM,WAAY,CACvC,MAAM9M,EAASzD,EAAUyQ,MAAQzQ,EAAU0Q,SAAW,GAChDyC,EAAmBS,EAAuBnQ,EAAOoF,OAEvD,IAAK,MAAMmH,KAASvM,EAAQ,CAC1B,MAAM0K,EAAYtO,KAAKgD,iBAAiB+I,cAAcoE,GAEtD,GAAyB,IAArB7B,EAAUtF,OACZ0I,EAASvH,KAAKnK,KAAKsR,wBAAwBnB,EAAOmD,QAC7C,CACL,MAAMV,EAAmB5S,KAAK6S,iCAC5B1C,EAAO7B,EAAWgF,EAAkB/H,EAASE,EAAUG,EAAa4B,GAEtEkE,EAASvH,QAAQyI,EACnB,CAEA,GAAIlB,EAAS1I,QAAU4C,EAAa,CAClC4B,EAASrD,KAAK,qBAAqByB,wBAAkCN,MACrE,KACF,CACF,CAEA,GAAIoG,EAAS1I,QAAU4C,EAAa,KACtC,CAEA,OAAO8F,CACT,CAMQ,gCAAAmB,CACN1C,EACA7B,EACA0F,EACAzI,EACAE,EACAG,EACA4B,GAEA,GAAyB,IAArBc,EAAUtF,OACZ,MAAO,CAAChJ,KAAKsR,wBAAwBnB,EAAO6D,IAI9C,IAAId,EAIC,CAAC,CAAE/C,QAAOqB,YAAawC,IAE5B,IAAK,MAAM1D,KAAYhC,EAAW,CAChC,MAAM+E,EAID,GAGL,GAAI9H,EAAQ9E,IAAI6J,GAAW,CACzB9C,EAASrD,KAAK,yCAAyCmG,MAEvD,IAAK,MAAMiB,KAAW2B,EACpBG,EAAYlJ,KAAK,CACfgG,MAAOoB,EAAQpB,MAAM5P,QAAQ,IAAIkT,OAAO,IAAInD,KAAa,KAAM,aAAaA,MAC5EkB,YAAaD,EAAQC,cAGzB0B,EAAkBG,EAClB,QACF,CAEA,GAAI9H,EAAQsB,MAAQpB,EAAU,CAC5B+B,EAASrD,KAAK,kBAAkBsB,wBAA+B6E,MAE/D,IAAK,MAAMiB,KAAW2B,EACpBG,EAAYlJ,KAAK,CACfgG,MAAOoB,EAAQpB,MAAM5P,QAAQ,IAAIkT,OAAO,IAAInD,KAAa,KAAM,cAAcA,MAC7EkB,YAAaD,EAAQC,cAGzB0B,EAAkBG,EAClB,QACF,CAEA,IAAKrT,KAAK8C,YAAY6B,QAAQ2L,GAAW,CACvC9C,EAASrD,KAAK,iBAAiBmG,8BAE/B,IAAK,MAAMiB,KAAW2B,EACpBG,EAAYlJ,KAAK,CACfgG,MAAOoB,EAAQpB,MAAM5P,QAAQ,IAAIkT,OAAO,IAAInD,KAAa,KAAM,YAAYA,MAC3EkB,YAAaD,EAAQC,cAGzB0B,EAAkBG,EAClB,QACF,CAIA,GAAiB,aADArT,KAAK8C,YAAYiM,YAAYuB,GACjB,CAC3B9C,EAASrD,KAAK,kBAAkBmG,kEAEhC,IAAK,MAAMiB,KAAW2B,EACpBG,EAAYlJ,KAAK,CACfgG,MAAOoB,EAAQpB,MAAM5P,QAAQ,IAAIkT,OAAO,IAAInD,KAAa,KAAM,aAAaA,MAC5EkB,YAAaD,EAAQC,cAGzB0B,EAAkBG,EAClB,QACF,CAGA,MAAMY,EAAwBjU,KAAK2R,2BACjCrB,EAAU,IAAI9E,IAAID,GAAUE,EAAUG,EAAa4B,GAIrD,IAAK,MAAM+F,KAAkBL,EAAiB,CAC5C,IAAK,MAAMgB,KAAcD,EAAuB,CAC9C,MAAMT,EAAgBD,EAAepD,MAAM5P,QACzC,IAAIkT,OAAO,IAAInD,KAAa,KAC5B4D,EAAW3C,SAEP4C,EAAsBZ,EAAe/B,YAAc0C,EAAW1C,YAG9D4C,EAAkB,CACtBtG,SAAUwC,EACVH,MAAO+D,EAAW3C,QAClBC,YAAa0C,EAAW1C,YACxB6C,SAAUH,EAAWzC,iBAAmB,IAS1C,GANA4B,EAAYlJ,KAAK,CACfgG,MAAOqD,EACPhC,YAAa2C,EACb1C,gBAAiB,CAAC2C,KAGhBf,EAAYrK,QAAU4C,EAAa,CACrC4B,EAASrD,KAAK,qBAAqByB,+BACnC,KACF,CACF,CACA,GAAIyH,EAAYrK,QAAU4C,EAAa,KACzC,CAGA,GADAsH,EAAkBG,EACdH,EAAgBlK,QAAU4C,EAAa,KAC7C,CAGA,OAAOsH,EAAgB/F,IAAIoE,GACzBvR,KAAKsR,wBACHC,EAAQpB,MACRoB,EAAQC,YACRlD,EACAiD,EAAQE,iBAAmB,IAGjC,E,8GC9hBF,qBACE,WAAAhP,CACUK,EACAQ,GADA,KAAAR,YAAAA,EACA,KAAAQ,UAAAA,CACP,CAaI,eAAA6F,CAAgBL,EAAcY,GACnC,MAAM4K,EAAkB,GAOxB,GAJAA,EAAMnK,KAAKrB,EAAMyL,SACjBD,EAAMnK,KAAK,IAGPnK,KAAKwU,iBAAiB1L,GACxBwL,EAAMnK,KAAK,gBACXmK,EAAMnK,KAAK,yDACXmK,EAAMnK,KAAK,2DACXmK,EAAMnK,KAAK,uEACXmK,EAAMnK,KAAK,kDACXmK,EAAMnK,KAAK,oEAGPT,aAAO,EAAPA,EAASoE,YACXwG,EAAMnK,KAAK,IACXmK,EAAMnK,KAAK,cAAcT,EAAQoE,YACjCwG,EAAMnK,KAAK,aAAaT,EAAQoE,qDAE7B,GAAI9N,KAAKyU,oBAAoB3L,GAClCwL,EAAMnK,KAAK,gBACXmK,EAAMnK,KAAK,8CACXmK,EAAMnK,KAAK,+DACXmK,EAAMnK,KAAK,6CACXmK,EAAMnK,KAAK,8CACXmK,EAAMnK,KAAK,kDACXmK,EAAMnK,KAAK,mEACN,GAAInK,KAAK0U,cAAc5L,GAC5BwL,EAAMnK,KAAK,gBACXmK,EAAMnK,KAAK,6CACXmK,EAAMnK,KAAK,4CACXmK,EAAMnK,KAAK,gEACXmK,EAAMnK,KAAK,+DACXmK,EAAMnK,KAAK,gEACN,GAAInK,KAAK2U,mBAAmB7L,IAMjC,GALAwL,EAAMnK,KAAK,gBACXmK,EAAMnK,KAAK,iDACXmK,EAAMnK,KAAK,iDAGPT,aAAO,EAAPA,EAAStJ,KAAM,CACjB,MAAM2I,EAAe/I,KAAKsD,UAAUsR,aAAalL,EAAQtJ,MACrD2I,EAAaC,OAAS,GACxBsL,EAAMnK,KAAK,6BAA6BpB,EAAaE,KAAK,QAE9D,OAGAqL,EAAMnK,KAAK,gBACXmK,EAAMnK,KAAK,uDACXmK,EAAMnK,KAAK,2CACXmK,EAAMnK,KAAK,+CACXmK,EAAMnK,KAAK,4CAGbmK,EAAMnK,KAAK,IAGX,MAAMxB,EAAa3I,KAAKsD,UAAUsF,WAoBlC,GAnBKD,EAAWE,UACdyL,EAAMnK,KAAK,sBAEPxB,EAAWI,aAAaC,OAAS,GACnCsL,EAAMnK,KAAK,oBAAoBxB,EAAWI,aAAaE,KAAK,SAG1DN,EAAWgF,mBAAmB3E,OAAS,GACzCsL,EAAMnK,KAAK,0BAA0BxB,EAAWgF,mBAAmB1E,KAAK,SAGtEN,EAAWkM,WAAW7L,OAAS,GACjCsL,EAAMnK,KAAK,kBAAkBxB,EAAWkM,WAAW5L,KAAK,SAG1DqL,EAAMnK,KAAK,KAITT,IACEA,EAAQtJ,MACVkU,EAAMnK,KAAK,uBAAuBT,EAAQtJ,SAGxCsJ,EAAQoE,UAAU,CACpBwG,EAAMnK,KAAK,cAAcT,EAAQoE,YACjC,MAAMO,EAAWrO,KAAK8C,YAAYiM,YAAYrF,EAAQoE,UAClDO,GACFiG,EAAMnK,KAAK,cAAckE,IAE7B,CAGF,OAAOiG,EAAMrL,KAAK,KACpB,CAMQ,gBAAAuL,CAAiB1L,GACvB,MAAMyL,EAAUzL,EAAMyL,QAAQxT,cAC9B,OAAOwT,EAAQjT,SAAS,cACjBiT,EAAQjT,SAAS,aACjBiT,EAAQjT,SAAS,UACjBiT,EAAQjT,SAAS,qBAC1B,CAMQ,mBAAAmT,CAAoB3L,GAC1B,MAAMyL,EAAUzL,EAAMyL,QAAQxT,cAC9B,OAAOwT,EAAQjT,SAAS,kBACjBiT,EAAQjT,SAAS,aAAeiT,EAAQjT,SAAS,WACjDiT,EAAQjT,SAAS,uBAC1B,CAMQ,aAAAoT,CAAc5L,GACpB,MAAMyL,EAAUzL,EAAMyL,QAAQxT,cAC9B,OAAOwT,EAAQjT,SAAS,WACjBiT,EAAQjT,SAAS,aACjBiT,EAAQjT,SAAS,cAC1B,CAMQ,kBAAAqT,CAAmB7L,GACzB,MAAMyL,EAAUzL,EAAMyL,QAAQxT,cAC9B,OAAOwT,EAAQjT,SAAS,SAAWiT,EAAQjT,SAAS,cAC7CiT,EAAQjT,SAAS,SAAWiT,EAAQjT,SAAS,mBAC7CiT,EAAQjT,SAAS,iBACjBiT,EAAQjT,SAAS,iBAC1B,CAKO,sBAAAwT,CAAuBhH,GAC5B,OAAO,IAAI1H,MAAM,SAAS0H,uDAC5B,CAKO,4BAAAiH,CAA6BjH,GAClC,OAAO,IAAI1H,MAAM,wCAAwC0H,uCAC3D,CAKO,uBAAAkH,CAAwBlH,EAAkBmH,GAC/C,OAAO,IAAI7O,MAAM,kBAAkB0H,cAAqBmH,EAAcV,UACxE,CAKO,2BAAAW,CAA4BX,GACjC,OAAO,IAAInO,MAAM,6BAA6BmO,IAChD,CAKO,yBAAAY,CAA0B1J,GAC/B,OAAO,IAAIrF,MAAM,8BAA8BqF,2EACjD,E,sHCnMF,yBAME,WAAAhJ,CACUK,EACAF,GADA,KAAAE,YAAAA,EACA,KAAAF,OAAAA,EAPF,KAAAwS,gBAAkB,aAClB,KAAAC,gBAAuC,IAAI1S,IAC3C,KAAA2S,eAA4C,CAAC,EAC7C,KAAA7J,SAAmB,GAKxB,CAKI,WAAAnC,CAAYyB,GACjB,GAAqB,iBAAVA,GAAsBA,EAAQ,EACvC,MAAM,IAAI3E,MAAM,gCAElBpG,KAAKyL,SAAWV,CAClB,CAKO,WAAA1B,GACL,OAAOrJ,KAAKyL,QACd,CAKO,YAAA8J,GACLvV,KAAKsV,eAAiB,CAAC,EACvBtV,KAAKqV,gBAAgBxQ,OACvB,CAKO,UAAAuG,GACL,OAAO,OAAP,UAAYpL,KAAKsV,eACnB,CAKO,eAAAnK,GACLnL,KAAKqV,gBAAgBxQ,QACrB7E,KAAKsV,eAAiB,CAAC,CACzB,CAQO,eAAA/N,CAAgBnH,EAAciH,GAA2B,GAK9D,OAJKA,GACHrH,KAAKuV,eAGAvV,KAAKwV,yBAAyBpV,EAAM,EAC7C,CAMQ,wBAAAoV,CAAyBpV,EAAc2K,GAC7C,GAAIA,GAAS/K,KAAKyL,SAChB,MAAM,IAAIrF,MAAM,8BAA8BpG,KAAKyL,mFAMrD,OAFAzL,KAAKoV,gBAAgBK,UAAY,EAE1BrV,EAAKG,QAAQP,KAAKoV,gBAAiB,CAAC1U,EAAOiD,KAEhD,GAAIA,EAAI+R,WAAW,KAAM,CACvB,MAAMC,EAAShS,EAAIiS,UAAU,GACvBC,EAAW7V,KAAKqV,gBAAgBS,IAAIH,GAC1C,QAAiB/K,IAAbiL,EACF,OAAOA,EAGTlS,EAAMgS,CACR,CAGA,MAAMxF,EAAQnQ,KAAK8C,YAAYiT,cAAcpS,EAAK3D,KAAKsV,eAAgBtV,KAAK4C,QAE5E,OAAc,OAAVuN,EAEKzP,GAITV,KAAKsV,eAAe3R,GAAOwM,EAC3BnQ,KAAKqV,gBAAgBhP,IAAI1C,EAAKwM,GAGvBnQ,KAAKwV,yBAAyBrF,EAAOpF,EAAQ,KAExD,CAOO,aAAAgB,CAAc3L,GACnB,MAAMkO,EAAY,IAAI9C,IAChBwK,EAAQ,IAAIvC,OAAOzT,KAAKoV,gBAAgBa,OAAQ,KACtD,IAAIvV,EAEJ,KAAsC,QAA9BA,EAAQsV,EAAME,KAAK9V,KACzBkO,EAAUQ,IAAIpO,EAAM,IAGtB,OAAOiG,MAAMC,KAAK0H,EACpB,CAOO,oBAAA6H,CAAqB/V,GAC1B,MAAMkO,EAAYtO,KAAK+L,cAAc3L,GAC/BgW,EAAoB,GAE1B,IAAK,MAAM9F,KAAYhC,EAEjBgC,EAASoF,WAAW,MAInB1V,KAAK8C,YAAY6B,QAAQ2L,IAC5B8F,EAAQjM,KAAKmG,GAIjB,OAAO8F,CACT,CAQO,sBAAAC,CAAuBC,EAAoB/K,EAAuB,IAAIC,KAC3E,MAAM+K,EAAqB,GAE3B,GAAID,EACFtW,KAAKwW,+BAA+BF,EAAW/K,EAASgL,OACnD,CAEL,MAAME,EAAUzW,KAAK8C,YAAY0M,aACjC,IAAK,MAAM7L,KAAO8S,EAChBzW,KAAKwW,+BAA+B7S,EAAK,IAAI6H,IAAO+K,EAExD,CAEA,OAAOA,CACT,CAMQ,8BAAAC,CACN1I,EACAvC,EACAgL,GAEA,GAAIhL,EAAQ9E,IAAIqH,GAEd,YADAyI,EAASpM,KAAK2D,GAIhBvC,EAAQuD,IAAIhB,GAGZ,MAAM4I,EAAc1W,KAAK8C,YAAYiT,cAAcjI,EAAU,CAAC,EAAG9N,KAAK4C,QACtE,GAAI8T,EAAa,CACf,MAAMpI,EAAYtO,KAAK+L,cAAc2K,GACrC,IAAK,MAAMpG,KAAYhC,GAChBgC,EAASoF,WAAW,MAAQ1V,KAAK8C,YAAY6B,QAAQ2L,IACxDtQ,KAAKwW,+BAA+BlG,EAAU,IAAI9E,IAAID,GAAUgL,EAGtE,CAEAhL,EAAQhF,OAAOuH,EACjB,E,8wCCrMF,2BAAS,wEAAAtL,MAAM,IAGf,yBAGA,6CAGA,qCACE,wFAAAvC,sBAAsB,IACtB,8FAAAQ,4BAA4B,IAC5B,wFAAAe,sBAAsB,IACtB,+FAAAK,6BAA6B,IAC7B,2FAAAG,yBAAyB,IACzB,8FAAAG,4BAA4B,IAC5B,4FAAAC,0BAA0B,IAC1B,qFAAAE,mBAAmB,IACnB,uFAAAC,qBAAqB,IAIvB,2BAAS,8EAAAC,MAAM,G,iICpBF,EAAAmU,gBAA4B,CACvCzW,KAAM,kBACNC,UAAYC,GACH,qBAAqBC,KAAKD,GAEnCE,UAAYF,GAEHA,EAAKG,QAAQ,iCAAkC,UAExDC,SAAU,G,+ICTC,EAAAoW,uBAAmC,CAC9C1W,KAAM,wBACNC,UAAYC,GAEH,gBAAgBC,KAAKD,GAE9BE,UAAYF,GAEHA,EAAKG,QAAQ,qBAAsB,CAACG,EAAOoB,EAAaC,IACtDD,EAAcC,EAAOZ,eAGhCX,SAAU,E,iICZC,EAAAqW,gBAA4B,CACvC3W,KAAM,kBACNC,UAAYC,GAEH,UAAUC,KAAKD,GAExBE,UAAYF,GACHA,EAAKG,QAAQ,aAAc,CAACG,EAAOe,KACxC,MAAMC,EAASC,SAASF,EAAK,IAIvBG,EAAgBF,EAAS,IAG/B,GAAsB,KAAlBE,GAA0C,KAAlBA,GAA0C,KAAlBA,EAClD,OAAOH,EAAM,KAIf,OATkBC,EAAS,IAUzB,KAAK,EACH,OAAOD,EAAM,KACf,KAAK,EACH,OAAOA,EAAM,KACf,KAAK,EACH,OAAOA,EAAM,KACf,QACE,OAAOA,EAAM,QAIrBjB,SAAU,E,6IChCC,EAAAsW,sBAAkC,CAC7C5W,KAAM,uBACNC,UAAYC,GAEH,+FAA+FC,KAAKD,IACpG,mJAAmJC,KAAKD,IACxJ,2BAA2BC,KAAKD,GAEzCE,UAAYF,GACHA,EAAKG,QAAQ,4OAClB,CAACG,EAAOC,EAAYC,KAClB,MAAMC,EAad,SAAmBD,GACjB,MAAME,EAAYF,EAAKG,cAGjBC,EAA8C,CAClD,SAAY,UACZ,SAAY,WACZ,OAAU,UACV,QAAW,SACX,SAAY,WACZ,QAAW,WACX,WAAc,aACd,KAAQ,SACR,SAAY,aACZ,KAAQ,OACR,SAAY,UACZ,UAAa,WACb,MAAS,QACT,KAAQ,QACR,MAAS,QACT,OAAU,UACV,OAAU,QACV,QAAW,WACX,MAAS,WACT,MAAS,UACT,SAAY,WACZ,OAAU,UACV,OAAU,SACV,UAAa,WACb,WAAc,YACd,MAAS,OACT,KAAQ,OACR,UAAa,YACb,IAAO,OACP,MAAS,UACT,SAAY,WACZ,QAAW,SACX,IAAO,SACP,KAAQ,OACR,MAAS,OACT,KAAQ,OACR,QAAW,WACX,OAAU,QACV,MAAS,SACT,MAAS,QACT,SAAY,WACZ,OAAU,SACV,KAAQ,SACR,KAAQ,SACR,WAAc,aACd,MAAS,UACT,MAAS,SACT,SAAY,WACZ,KAAQ,SACR,MAAS,OACT,MAAS,OACT,IAAO,MACP,OAAU,WACV,OAAU,QACV,WAAc,YACd,QAAW,WACX,MAAS,QACT,MAAS,OACT,OAAU,UACV,QAAW,SACX,MAAS,QACT,UAAa,YACb,KAAQ,QACR,KAAQ,MACR,GAAM,OACN,YAAe,cACf,OAAU,SACV,WAAc,YACd,OAAU,QACV,KAAQ,UACR,OAAU,QACV,WAAc,YACd,OAAU,SACV,MAAS,UACT,KAAQ,SACR,OAAU,SACV,MAAS,QACT,OAAU,SACV,QAAW,UACX,SAAY,UACZ,QAAW,SACX,MAAS,QACT,SAAY,UACZ,UAAa,WACb,SAAY,WACZ,QAAW,WACX,OAAU,SACV,MAAS,UACT,MAAS,QACT,MAAS,QACT,KAAQ,OACR,SAAY,YACZ,OAAU,WACV,KAAQ,QACR,OAAU,WACV,MAAS,UACT,KAAQ,QACR,KAAQ,SACR,MAAS,SAIX,OAAIA,EAAiBF,IA8DiBG,EA7DZD,EAAiBF,IA6DvBI,EA3DEN,KA6DLM,EAASC,cACjBF,EAAOE,cAIZD,EAAS,KAAOA,EAAS,GAAGC,cACvBF,EAAOG,OAAO,GAAGD,cAAgBF,EAAOI,MAAM,GAIhDJ,GAjEH,SAASZ,KAAKS,IAAc,SAAST,KAAKS,GACrCF,EAAO,KAIZ,4BAA4BP,KAAKS,GAC5BF,EAAKS,MAAM,GAAI,GAAK,MAIzB,aAAahB,KAAKS,GACbF,EAAO,IAIZ,QAAQP,KAAKS,GAEK,CAAC,SAAU,QAAS,QAAS,QAAS,OAAQ,OAAQ,OAAQ,gBAClEQ,SAASR,GAChBF,EAAO,IAETA,EAAKL,QAAQ,QAAS,OAI3B,4BAA4BF,KAAKS,GAEf,CAClB,QAAS,QAAS,OAAQ,QAAS,SAAU,QAAS,QACtD,OAAQ,OAAQ,MAAO,SAAU,QAAS,YAAa,OACvD,WAAY,OAAQ,UAAW,OAAQ,UAEzBQ,SAASR,GAChBF,EAAO,IAETA,EAAO,MAIZ,aAAaP,KAAKS,GACbF,EAAO,KAalB,IAAsBM,EAAkBD,CARxC,CA9K2BM,CAAUX,GAC7B,MAAO,GAAGD,KAAcE,MAI9BL,SAAU,E,uIChBC,EAAAuW,mBAA+B,CAC1C7W,KAAM,oBACNC,UAAYC,GAAiBA,EAAKkB,SAAS,cAC3ChB,UAAYF,GACHA,EAAKG,QAAQ,mBAAoB,CAACG,EAAOuB,IAC1CA,EAAKC,SAAS,KACTD,EAAO,IAEPA,EAAO,MAIpBzB,SAAU,E,uJCZC,EAAA4B,2BAAuC,CAClDlC,KAAM,4BACNC,UAAYC,GAEH,qBAAqBC,KAAKD,GAEnCE,UAAYF,IAKVA,GAHAA,EAAOA,EAAKG,QAAQ,iBAAkB,OAG1BA,QAAQ,UAAW,MAGnBA,QAAQ,kBAAmB,SAIzCC,SAAU,E,6IClBC,EAAAwW,sBAAkC,CAC7C9W,KAAM,uBACNC,UAAYC,GAEH,uCAAuCC,KAAKD,IAC5C,+BAA+BC,KAAKD,GAE7CE,UAAYF,IAEVA,EAAOA,EAAKG,QAAQ,0BAA2B,UAGnCA,QAAQ,2BAA4B,UAIlDC,SAAU,E,oTClBZ,sDAAS,iFAAAmW,eAAe,IACxB,4DAAS,uFAAAG,qBAAqB,IAC9B,sDAAS,iFAAAD,eAAe,IACxB,6DAAS,wFAAAD,sBAAsB,IAC/B,yDAAS,oFAAAG,kBAAkB,IAC3B,4DAAS,uFAAAC,qBAAqB,IAC9B,iEAAS,4FAAA5U,0BAA0B,IAGnC,wDACA,wDACA,kDACA,yDACA,qDACA,wDACA,6DAEa,EAAAE,oBAAsB,CACjC,EAAAqU,gBACA,EAAAG,sBACA,EAAAD,gBACA,EAAAD,uBACA,EAAAG,mBACA,EAAAC,sBACA,EAAA5U,4BAGW,EAAAG,sBAAwB,CACnC,EAAAoU,gBACA,EAAAG,sBACA,EAAAD,gB,gkCC7BF,mDAGA,4CACE,iFAAAF,eAAe,IACf,uFAAAG,qBAAqB,IACrB,iFAAAD,eAAe,IACf,wFAAAD,sBAAsB,IACtB,oFAAAG,kBAAkB,IAClB,uFAAAC,qBAAqB,IACrB,4FAAA5U,0BAA0B,IAC1B,qFAAAE,mBAAmB,G,oMCRrB,4CAMA,MAAa2U,UAA+B,EAAAC,gBAMnC,OAAAxT,CAAQC,EAAaS,GAC1B,IAAKT,GAAsB,iBAARA,EACjB,MAAM,IAAIyC,MAAM,uCAElB,IAAKhC,IAASuC,MAAMoD,QAAQ3F,EAAKsM,YAC/B,MAAM,IAAItK,MAAM,iDAElB,GAA+B,IAA3BhC,EAAKsM,WAAW1H,OAClB,MAAM,IAAI5C,MAAM,oCAIlB,IAAI+Q,GAAa,EACjB,IAAK,MAAMhX,KAAaiE,EAAKsM,WAC3B,GAAI,YAAavQ,EAAW,CAC1B,GAAIgX,EACF,MAAM,IAAI/Q,MAAM,yCAGlB,GADA+Q,GAAa,GACRxQ,MAAMoD,QAAQ5J,EAAU0Q,UAAyC,IAA7B1Q,EAAU0Q,QAAQ7H,OACzD,MAAM,IAAI5C,MAAM,iDAEpB,KAAO,MAAI,OAAQjG,MAAa,SAAUA,GAQxC,MAAM,IAAIiG,MAAM,0DAPhB,GAA4B,mBAAjBjG,EAAUiX,GACnB,MAAM,IAAIhR,MAAM,qCAElB,IAAKO,MAAMoD,QAAQ5J,EAAUyQ,OAAmC,IAA1BzQ,EAAUyQ,KAAK5H,OACnD,MAAM,IAAI5C,MAAM,8CAIpB,CAGFpG,KAAK8D,MAAMuC,IAAI1C,EAAK,CAClB+M,WAAYtM,EAAKsM,WAAWvD,IAAIkK,GAAM,OAAD,UAAMA,KAE/C,CASO,aAAAtB,CACLpS,EACA+F,EACA9G,GAEA,MAAMwB,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,IAAKS,EACH,OAAO,KAGT,IAAK,MAAMjE,KAAaiE,EAAKsM,WAAY,CACvC,GAAI,YAAavQ,GAAaA,EAAU0Q,QACtC,OAAOjO,EAAO0U,aAAanX,EAAU0Q,SAChC,GAAI1Q,EAAUiX,IAAMjX,EAAUiX,GAAG1N,GACtC,OAAO9G,EAAO0U,aAAanX,EAAUyQ,KAEzC,CAEA,MAAM,IAAIxK,MAAM,sDAClB,EAvEF,2BA6EA,MAAamR,UAA8B,EAAAL,gBAOlC,OAAAxT,CAAQC,EAAaC,EAAkBU,EAA8B,CAAEC,OAAO,IACnF,IAAKZ,GAAsB,iBAARA,EACjB,MAAM,IAAIyC,MAAM,kCAElB,IAAKO,MAAMoD,QAAQnG,IAA6B,IAAlBA,EAAOoF,OACnC,MAAM,IAAI5C,MAAM,oCAGlBpG,KAAK8D,MAAMuC,IAAI1C,EAAK,CAClBC,OAAQ,IAAIA,GACZ4T,MAAO,EACPjT,MAAOD,EAAQC,OAEnB,CASO,aAAAwR,CACLpS,EAEA8T,EAEAC,GAEA,MAAMtT,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,IAAKS,EACH,OAAO,KAGT,GAAIA,EAAKoT,OAASpT,EAAKR,OAAOoF,OAAQ,CACpC,IAAI5E,EAAKG,MAGP,OAAOH,EAAKR,OAAOQ,EAAKR,OAAOoF,OAAS,GAFxC5E,EAAKoT,MAAQ,CAIjB,CAEA,MAAMrH,EAAQ/L,EAAKR,OAAOQ,EAAKoT,OAE/B,OADApT,EAAKoT,QACErH,CACT,CAOO,SAAAwH,CAAUhU,GACf,MAAMS,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,QAAIS,IACFA,EAAKoT,MAAQ,GACN,EAGX,EAlEF,0BAwEA,MAAaI,UAAyB,EAAAV,gBAM7B,OAAAxT,CAAQC,EAAac,GAC1B,IAAKd,GAAsB,iBAARA,EACjB,MAAM,IAAIyC,MAAM,kCAElB,GAA0B,iBAAf3B,EAAOwM,KAA0C,iBAAfxM,EAAO+E,IAClD,MAAM,IAAIpD,MAAM,+BAElB,GAAI3B,EAAOwM,KAAOxM,EAAO+E,IACvB,MAAM,IAAIpD,MAAM,6BAElB,QAAoBwE,IAAhBnG,EAAOuM,OAA8C,iBAAhBvM,EAAOuM,MAAqBvM,EAAOuM,MAAQ,GAClF,MAAM,IAAI5K,MAAM,kCAElB,IAAK,CAAC,UAAW,SAAS9E,SAASmD,EAAO2J,MACxC,MAAM,IAAIhI,MAAM,qCAGlBpG,KAAK8D,MAAMuC,IAAI1C,EAAK,CAClBsN,IAAKxM,EAAOwM,IACZzH,IAAK/E,EAAO+E,IACZwH,KAAMvM,EAAOuM,KACb5C,KAAM3J,EAAO2J,MAEjB,CASO,aAAA2H,CACLpS,EACA8T,EACA7U,GAEA,MAAMwB,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,IAAKS,EACH,OAAO,KAGT,MAAM,IAAE6M,EAAG,IAAEzH,EAAG,KAAEwH,EAAI,KAAE5C,GAAShK,EAEjC,QAAawG,IAAToG,EAAoB,CAEtB,MAAM6G,EAAQtO,KAAKE,OAAOD,EAAMyH,GAAOD,GAEjCb,EAAQc,EADKrO,EAAOkV,UAAU,EAAGD,EAAQ,GACb7G,EAClC,MAAgB,YAAT5C,EAAqB7E,KAAKE,MAAM0G,GAAO6C,WAAa7C,EAAM6C,UACnE,CAAO,CAEL,MAAM+E,EAAc9G,EAAOrO,EAAOA,UAAY4G,EAAMyH,GACpD,MAAgB,YAAT7C,EAAqB7E,KAAKE,MAAMsO,GAAa/E,WAAa+E,EAAY/E,UAC/E,CACF,EA7DF,qBAmEA,MAAagF,UAA4B,EAAAd,gBAMhC,OAAAxT,CAAQC,EAAaS,GAC1B,IAAKT,GAAsB,iBAARA,EACjB,MAAM,IAAIyC,MAAM,kCAElB,IAAKhC,EAAKuI,UAAqC,iBAAlBvI,EAAKuI,SAChC,MAAM,IAAIvG,MAAM,uCAElB,IAAKhC,EAAKkK,WAAuC,iBAAnBlK,EAAKkK,UACjC,MAAM,IAAIlI,MAAM,+BAIlB,MAAM6R,EAAejY,KAAK+L,cAAc3H,EAAKuI,UAC7C,IAAK,MAAM2D,KAAY2H,EAAc,CACnC,KAAM3H,KAAYlM,EAAKkK,WACrB,MAAM,IAAIlI,MAAM,sBAAsBkK,oCAExC,IAAK3J,MAAMoD,QAAQ3F,EAAKkK,UAAUgC,KAAkD,IAApClM,EAAKkK,UAAUgC,GAAUtH,OACvE,MAAM,IAAI5C,MAAM,aAAakK,sBAEjC,CAEAtQ,KAAK8D,MAAMuC,IAAI1C,EAAK,CAClBgJ,SAAUvI,EAAKuI,SACf2B,UAAW,OAAF,UAAOlK,EAAKkK,YAEzB,CASO,aAAAyH,CACLpS,EACA8T,EACA7U,GAEA,MAAMwB,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,IAAKS,EACH,OAAO,KAIT,IAAI6D,EAAS7D,EAAKuI,SAClB,MAAMsL,EAAejY,KAAK+L,cAAc9D,GAExC,IAAK,MAAMqI,KAAY2H,EAAc,CACnC,MAAMrU,EAASQ,EAAKkK,UAAUgC,GAC9B,GAAI1M,GAAUA,EAAOoF,OAAS,EAAG,CAC/B,MAAMmH,EAAQvN,EAAO0U,aAAa1T,GAClCqE,EAASA,EAAO1H,QAAQ,IAAIkT,OAAO,IAAInD,KAAa,KAAMH,EAC5D,CACF,CAEA,OAAOlI,CACT,CAOQ,aAAA8D,CAAc3L,GACpB,MAAMgV,EAAkB,aAClB9G,EAAY,IAAI9C,IACtB,IAAI9K,EACJ,KAAgD,QAAxCA,EAAQ0U,EAAgBc,KAAK9V,KACnCkO,EAAUQ,IAAIpO,EAAM,IAEtB,OAAOiG,MAAMC,KAAK0H,EACpB,EA/EF,uB,qLC7NA,MAAsB4I,EAAtB,cACY,KAAApT,MAAwB,IAAInB,GAgFxC,CAlES,UAAAiC,CAAWjB,GAChB,OAAO3D,KAAK8D,MAAMyC,OAAO5C,EAC3B,CAOO,OAAAgB,CAAQhB,GACb,OAAO3D,KAAK8D,MAAM2C,IAAI9C,EACxB,CAOO,OAAAuU,CAAQvU,GACb,OAAO3D,KAAK8D,MAAMgS,IAAInS,EACxB,CAKO,KAAAkB,GACL7E,KAAK8D,MAAMe,OACb,CAMO,OAAAsT,GACL,OAAOxR,MAAMC,KAAK5G,KAAK8D,MAAM0K,OAC/B,CAMO,IAAA3B,GACL,OAAO7M,KAAK8D,MAAM+I,IACpB,CAOO,WAAAuL,CAAYzU,GACjB,OAAO3D,KAAK8D,MAAMgS,IAAInS,EACxB,EAnEF,oBAsFA,kCAAuCuT,EAM9B,OAAAxT,CAAQC,EAAaC,GAC1B,IAAKD,GAAsB,iBAARA,EACjB,MAAM,IAAIyC,MAAM,uCAElB,IAAKO,MAAMoD,QAAQnG,GACjB,MAAM,IAAIwC,MAAM,gCAElBpG,KAAK8D,MAAMuC,IAAI1C,EAAK,IAAIC,GAC1B,CAMO,QAAAC,CAASoJ,GACd,IAAK,MAAOtJ,EAAKC,KAAW2K,OAAO6E,QAAQnG,GACzCjN,KAAK0D,QAAQC,EAAKC,EAEtB,CASO,aAAAmS,CACLpS,EACA+F,EACA9G,GAEA,MAAMwB,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,OAAKS,EAGe,IAAhBA,EAAK4E,OACA,GAEFpG,EAAO0U,aAAalT,GALlB,IAMX,CAMO,UAAA6B,GACL,MAAMgH,EAAmB,CAAC,EAC1B,IAAK,MAAOtJ,EAAKC,KAAW5D,KAAK8D,MAAMsP,UACrCnG,EAAQtJ,GAAO,IAAIC,GAErB,OAAOqJ,CACT,GAMF,oCAAyCiK,EAMhC,OAAAxT,CAAQC,EAAaK,GAC1B,IAAKL,GAAsB,iBAARA,EACjB,MAAM,IAAIyC,MAAM,uCAElB,GAAkB,mBAAPpC,EACT,MAAM,IAAIoC,MAAM,oCAElBpG,KAAK8D,MAAMuC,IAAI1C,EAAKK,EACtB,CASO,aAAA+R,CACLpS,EACA+F,EACA9G,GAEA,MAAMwB,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,IAAKS,EACH,OAAO,KAGT,IACE,MAAMR,EAASQ,IACf,IAAKuC,MAAMoD,QAAQnG,GACjB,MAAM,IAAIwC,MAAM,kBAAkBzC,2BAEpC,OAAsB,IAAlBC,EAAOoF,OACF,KAEFpG,EAAO0U,aAAa1T,EAC7B,CAAE,MAAOkF,GACP,MAAM,IAAI1C,MAAM,kCAAkCzC,OAAUmF,EAAgByL,UAC9E,CACF,GAMF,oCAAyC2C,EAOhC,OAAAxT,CAAQC,EAAaC,EAAkBM,GAC5C,IAAKP,GAAsB,iBAARA,EACjB,MAAM,IAAIyC,MAAM,uCAElB,IAAKO,MAAMoD,QAAQnG,GACjB,MAAM,IAAIwC,MAAM,gCAElB,IAAKO,MAAMoD,QAAQ7F,GACjB,MAAM,IAAIkC,MAAM,iCAElB,GAAIxC,EAAOoF,SAAW9E,EAAQ8E,OAC5B,MAAM,IAAI5C,MAAM,uDAElB,GAAsB,IAAlBxC,EAAOoF,OACT,MAAM,IAAI5C,MAAM,gCAIlB,IAAK,MAAM2M,KAAU7O,EACnB,GAAsB,iBAAX6O,GAAuBA,EAAS,EACzC,MAAM,IAAI3M,MAAM,4CAIpB,MAAMiS,EAAYnU,EAAQ8L,OAAO,CAACC,EAAK8C,IAAW9C,EAAM8C,EAAQ,GAChE,GAAIxJ,KAAK+O,IAAID,EAAY,GAAO,KAC9B,MAAM,IAAIjS,MAAM,gCAAgCiS,KAIlD,MAAME,EAA8B,GACpC,IAAIC,EAAS,EACb,IAAK,MAAMzF,KAAU7O,EACnBsU,GAAUzF,EACVwF,EAAkBpO,KAAKqO,GAGzBxY,KAAK8D,MAAMuC,IAAI1C,EAAK,CAClBC,OAAQ,IAAIA,GACZM,QAAS,IAAIA,GACbqU,qBAEJ,CASO,aAAAxC,CACLpS,EACA+F,EACA9G,GAEA,MAAMwB,EAAOpE,KAAK8D,MAAMgS,IAAInS,GAC5B,OAAKS,EAIExB,EAAO6V,eAAerU,EAAKR,OAAQQ,EAAKmU,mBAHtC,IAIX,E,+GC3QF,4CAKA,2CAUA,kCACU,KAAAG,YAAc,IAAI,EAAAC,kBAClB,KAAAC,cAAgB,IAAI,EAAAC,oBACpB,KAAAC,cAAgB,IAAI,EAAAC,oBACpB,KAAAC,iBAAmB,IAAI,EAAA/B,uBACvB,KAAAgC,gBAAkB,IAAI,EAAA1B,sBACtB,KAAA2B,WAAa,IAAI,EAAAtB,iBACjB,KAAAuB,cAAgB,IAAI,EAAAnB,oBAGX,KAAAoB,aAAe,CAC9B,CAAElZ,KAAM,WAAYmZ,QAASrZ,KAAK4Y,eAClC,CAAE1Y,KAAM,cAAemZ,QAASrZ,KAAKgZ,kBACrC,CAAE9Y,KAAM,aAAcmZ,QAASrZ,KAAKiZ,iBACpC,CAAE/Y,KAAM,QAASmZ,QAASrZ,KAAKkZ,YAC/B,CAAEhZ,KAAM,WAAYmZ,QAASrZ,KAAKmZ,eAClC,CAAEjZ,KAAM,WAAYmZ,QAASrZ,KAAK8Y,eAClC,CAAE5Y,KAAM,SAAUmZ,QAASrZ,KAAK0Y,aA8MpC,CAxMS,OAAAhV,CAAQC,EAAaC,GAC1B5D,KAAK0Y,YAAYhV,QAAQC,EAAKC,EAChC,CAEO,QAAAC,CAASoJ,GACdjN,KAAK0Y,YAAY7U,SAASoJ,EAC5B,CAKO,eAAAlJ,CAAgBJ,EAAaK,GAClChE,KAAK4Y,cAAclV,QAAQC,EAAKK,EAClC,CAKO,eAAAC,CAAgBN,EAAaC,EAAkBM,GACpDlE,KAAK8Y,cAAcpV,QAAQC,EAAKC,EAAQM,EAC1C,CAKO,kBAAAC,CAAmBR,EAAaS,GACrCpE,KAAKgZ,iBAAiBtV,QAAQC,EAAKS,EACrC,CAKO,iBAAAC,CAAkBV,EAAaC,EAAkBU,GACtDtE,KAAKiZ,gBAAgBvV,QAAQC,EAAKC,EAAQU,EAC5C,CAKO,YAAAE,CAAab,EAAac,GAC/BzE,KAAKkZ,WAAWxV,QAAQC,EAAKc,EAC/B,CAKO,eAAAC,CAAgBf,EAAaS,GAClCpE,KAAKmZ,cAAczV,QAAQC,EAAKS,EAClC,CAKO,OAAAO,CAAQhB,GACb,OAAO3D,KAAKoZ,aAAa1J,KAAK,EAAG2J,aAAcA,EAAQ1U,QAAQhB,GACjE,CAKO,UAAAiB,CAAWjB,GAChB,IAAI2V,GAAU,EACd,IAAK,MAAM,QAAED,KAAarZ,KAAKoZ,aACzBC,EAAQzU,WAAWjB,KACrB2V,GAAU,GAGd,OAAOA,CACT,CAMO,aAAAvD,CAAcpS,EAAa+F,EAAoC9G,GACpE,IAAK,MAAM,QAAEyW,KAAarZ,KAAKoZ,aAC7B,GAAIC,EAAQ1U,QAAQhB,GAClB,OAAO0V,EAAQtD,cAAcpS,EAAK+F,EAAS9G,GAG/C,OAAO,IACT,CAKO,WAAAmM,CAAYpL,GACjB,IAAK,MAAM,KAAEzD,EAAI,QAAEmZ,KAAarZ,KAAKoZ,aACnC,GAAIC,EAAQ1U,QAAQhB,GAClB,OAAOzD,EAGX,OAAO,IACT,CAKO,KAAA2E,GACL,IAAK,MAAM,QAAEwU,KAAarZ,KAAKoZ,aAC7BC,EAAQxU,OAEZ,CAKO,gBAAA0U,GAA2BvZ,KAAK0Y,YAAY7T,OAAS,CACrD,kBAAAa,GAA6B1F,KAAK4Y,cAAc/T,OAAS,CACzD,kBAAAc,GAA6B3F,KAAK8Y,cAAcjU,OAAS,CACzD,qBAAAe,GAAgC5F,KAAKgZ,iBAAiBnU,OAAS,CAC/D,oBAAAgB,GAA+B7F,KAAKiZ,gBAAgBpU,OAAS,CAC7D,eAAAiB,GAA0B9F,KAAKkZ,WAAWrU,OAAS,CACnD,kBAAAkB,GAA6B/F,KAAKmZ,cAActU,OAAS,CAKzD,QAAAmH,GACL,MAAO,CACLK,OAAQrM,KAAK0Y,YAAY7L,OACzBP,SAAUtM,KAAK4Y,cAAc/L,OAC7BN,SAAUvM,KAAK8Y,cAAcjM,OAC7BL,YAAaxM,KAAKgZ,iBAAiBnM,OACnCJ,WAAYzM,KAAKiZ,gBAAgBpM,OACjCH,MAAO1M,KAAKkZ,WAAWrM,OACvBF,SAAU3M,KAAKmZ,cAActM,OAC7BV,MAAOnM,KAAKoZ,aAAapJ,OAAO,CAACC,GAAOoJ,aAAcpJ,EAAMoJ,EAAQxM,OAAQ,GAEhF,CAKO,UAAA2C,GACL,MAAMhB,EAAO,IAAIhD,IACjB,IAAK,MAAM,QAAE6N,KAAarZ,KAAKoZ,aAC7B,IAAK,MAAMzV,KAAO0V,EAAQlB,UACxB3J,EAAKM,IAAInL,GAGb,OAAOgD,MAAMC,KAAK4H,EACpB,CAKO,mBAAAxI,CAAoBrC,GACzB,OAAO3D,KAAKiZ,gBAAgBtB,UAAUhU,EACxC,CAKO,UAAAsC,GACL,OAAOjG,KAAK0Y,YAAYzS,YAC1B,CAKO,mBAAAuK,CAAoB7M,GACzB,OAAO3D,KAAK8Y,cAAcV,YAAYzU,EACxC,CAEO,sBAAA8M,CAAuB9M,GAC5B,OAAO3D,KAAKgZ,iBAAiBZ,YAAYzU,EAC3C,CAEO,qBAAAmN,CAAsBnN,GAC3B,OAAO3D,KAAKiZ,gBAAgBb,YAAYzU,EAC1C,CAEO,gBAAAoN,CAAiBpN,GACtB,OAAO3D,KAAKkZ,WAAWd,YAAYzU,EACrC,CAEO,mBAAAuN,CAAoBvN,GACzB,OAAO3D,KAAKmZ,cAAcf,YAAYzU,EACxC,CAKO,eAAAmB,CAAgBnB,GAAwB,OAAO3D,KAAK4Y,cAAcjU,QAAQhB,EAAM,CAChF,eAAAoB,CAAgBpB,GAAwB,OAAO3D,KAAK8Y,cAAcnU,QAAQhB,EAAM,CAChF,kBAAAqB,CAAmBrB,GAAwB,OAAO3D,KAAKgZ,iBAAiBrU,QAAQhB,EAAM,CACtF,iBAAAsB,CAAkBtB,GAAwB,OAAO3D,KAAKiZ,gBAAgBtU,QAAQhB,EAAM,CACpF,YAAAuB,CAAavB,GAAwB,OAAO3D,KAAKkZ,WAAWvU,QAAQhB,EAAM,CAC1E,eAAAwB,CAAgBxB,GAAwB,OAAO3D,KAAKmZ,cAAcxU,QAAQhB,EAAM,CAKhF,kBAAAyB,CAAmBzB,GAAwB,OAAO3D,KAAK4Y,cAAchU,WAAWjB,EAAM,CACtF,kBAAA0B,CAAmB1B,GAAwB,OAAO3D,KAAK8Y,cAAclU,WAAWjB,EAAM,CACtF,qBAAA2B,CAAsB3B,GAAwB,OAAO3D,KAAKgZ,iBAAiBpU,WAAWjB,EAAM,CAC5F,oBAAA4B,CAAqB5B,GAAwB,OAAO3D,KAAKiZ,gBAAgBrU,WAAWjB,EAAM,CAC1F,eAAA6B,CAAgB7B,GAAwB,OAAO3D,KAAKkZ,WAAWtU,WAAWjB,EAAM,CAChF,kBAAA8B,CAAmB9B,GAAwB,OAAO3D,KAAKmZ,cAAcvU,WAAWjB,EAAM,E,0LCtP/F,mCACU,KAAA2G,KAAsB,KACtB,KAAAkP,YAAsB,CA+FhC,CAzFS,OAAA3O,CAAQP,GACb,IAAKC,OAAOC,UAAUF,GACpB,MAAM,IAAIlE,MAAM,2BAElBpG,KAAKsK,KAAOf,KAAK+O,IAAIhO,KAAU,EAC/BtK,KAAKwZ,YAAcxZ,KAAKsK,IAC1B,CAKO,SAAAQ,GACL9K,KAAKsK,KAAO,KACZtK,KAAKwZ,YAAc,CACrB,CAMO,OAAA7O,GACL,OAAO3K,KAAKsK,IACd,CAOO,MAAA1H,GACL,OAAkB,OAAd5C,KAAKsK,KACAf,KAAK3G,UAKd5C,KAAKwZ,YAAkC,QAAnBxZ,KAAKwZ,YAAwB,aAAgB,EAC1DxZ,KAAKwZ,YAAc,WAC5B,CAQO,SAAA1B,CAAU7G,EAAazH,GAC5B,OAAOD,KAAKE,MAAMzJ,KAAK4C,UAAY4G,EAAMyH,IAAQA,CACnD,CAOO,YAAAqG,CAAgBmC,GACrB,GAAqB,IAAjBA,EAAMzQ,OACR,MAAM,IAAI5C,MAAM,kCAGlB,OAAOqT,EADOzZ,KAAK8X,UAAU,EAAG2B,EAAMzQ,QAExC,CAQO,cAAAyP,CAAkB7U,EAAa2U,GACpC,GAAI3U,EAAOoF,SAAWuP,EAAkBvP,OACtC,MAAM,IAAI5C,MAAM,mDAElB,GAAsB,IAAlBxC,EAAOoF,OACT,MAAM,IAAI5C,MAAM,mCAGlB,MAAMxD,EAAS5C,KAAK4C,SAGpB,IAAK,IAAIqH,EAAI,EAAGA,EAAIsO,EAAkBvP,OAAQiB,IAC5C,GAAIrH,GAAU2V,EAAkBtO,GAC9B,OAAOrG,EAAOqG,GAKlB,OAAOrG,EAAOA,EAAOoF,OAAS,EAChC,E,4HC7FF,yBACE,WAAAvG,CACUK,EACAE,GADA,KAAAF,YAAAA,EACA,KAAAE,iBAAAA,CACP,CAWI,QAAA4F,GACL,MAAMG,EAAyB,GACzB4E,EAA+B,GAC/BkH,EAAuB,GACvB6E,EAA6B,GAC7BlM,EAAqB,GAErBmM,EAAW3Z,KAAK8C,YAAY0M,aAC5BoK,EAAkB,IAAIpO,IAG5B,IAAK,MAAMF,KAAWqO,EAAU,CAE1B3Z,KAAK6Z,YAAYvO,IACnBuJ,EAAW1K,KAAKmB,GAIlB,MAAMwO,EAAsB9Z,KAAK+Z,mBAAmBzO,GACpD,IAAK,MAAMgF,KAAYwJ,EACrBF,EAAgB9K,IAAIwB,GACftQ,KAAK8C,YAAY6B,QAAQ2L,IACvBvH,EAAazH,SAASgP,IACzBvH,EAAaoB,KAAKmG,EAI1B,CAGA,IAAK,MAAMhF,KAAWqO,EACfC,EAAgBnT,IAAI6E,IAAatL,KAAKga,WAAW1O,IACpDoO,EAAiBvP,KAAKmB,GAK1B,MAAM2O,EAAeja,KAAKgD,iBAAiBqT,yBAkB3C,OAjBA1I,EAAmBxD,QAAQ8P,GAGvBpF,EAAW7L,OAAS,GACtBwE,EAASrD,KAAK,SAAS0K,EAAW7L,4CAEhC0Q,EAAiB1Q,OAAS,GAC5BwE,EAASrD,KAAK,SAASuP,EAAiB1Q,+CAEtC2Q,EAAS3Q,OAAS,KACpBwE,EAASrD,KAAK,sBAAsBwP,EAAS3Q,kDAOxC,CACLH,QALsC,IAAxBE,EAAaC,QACgB,IAA9B2E,EAAmB3E,QACG,IAAtB6L,EAAW7L,OAIxBD,eACA4E,qBACAkH,aACA6E,mBACAlM,WAEJ,CAMQ,WAAAqM,CAAYvO,GAGlB,OAFiBtL,KAAK8C,YAAYiM,YAAYzD,IAG5C,IAAK,SAAU,CACb,MAAM4O,EAAala,KAAK8C,YAAYmD,aAAaqF,GACjD,OAAQ4O,GAAoC,IAAtBA,EAAWlR,QAC1BkR,EAAWC,MAAMhK,IAAUA,GAA0B,KAAjBA,EAAM9N,OACnD,CAEA,IAAK,WAIL,IAAK,WACL,IAAK,cACL,IAAK,aACL,IAAK,WACL,IAAK,QAGH,OAAO,EAET,QACE,OAAO,EAEb,CAMQ,kBAAA0X,CAAmBzO,GACzB,MAAM8O,EAAuB,GAG7B,OAFiBpa,KAAK8C,YAAYiM,YAAYzD,IAG5C,IAAK,SAAU,CACb,MAAM4O,EAAala,KAAK8C,YAAYmD,aAAaqF,GACjD,GAAI4O,EACF,IAAK,MAAM/J,KAAS+J,EAAY,CAC9B,MAAM5L,EAAYtO,KAAKgD,iBAAiB+I,cAAcoE,GACtDiK,EAAWjQ,QAAQmE,EAAUwB,OAAOuK,IAAMA,EAAE3E,WAAW,MACzD,CAEF,KACF,EAWF,OAAO/O,MAAMC,KAAK,IAAI4E,IAAI4O,GAC5B,CAMQ,UAAAJ,CAAW1O,GAOjB,MANqB,CACnB,mCACA,kCACA,gCAGkBoE,KAAK4K,GAAWA,EAAQja,KAAKiL,GACnD,CAOO,YAAAsJ,CAAaxU,GAClB,OAAOJ,KAAKgD,iBAAiBmT,qBAAqB/V,EACpD,CAMO,OAAAyI,GAEL,OADe7I,KAAK4I,WACNC,OAChB,CAMO,oBAAA0R,GACL,MAAMtS,EAASjI,KAAK4I,WACd0L,EAAkB,GAwBxB,GAtBIrM,EAAOY,QACTyL,EAAMnK,KAAK,+BAEXmK,EAAMnK,KAAK,+BAGTlC,EAAOc,aAAaC,OAAS,GAC/BsL,EAAMnK,KAAK,kBAAkBlC,EAAOc,aAAaE,KAAK,SAGpDhB,EAAO0F,mBAAmB3E,OAAS,GACrCsL,EAAMnK,KAAK,wBAAwBlC,EAAO0F,mBAAmB1E,KAAK,SAGhEhB,EAAO4M,WAAW7L,OAAS,GAC7BsL,EAAMnK,KAAK,gBAAgBlC,EAAO4M,WAAW5L,KAAK,SAGhDhB,EAAOyR,iBAAiB1Q,OAAS,GACnCsL,EAAMnK,KAAK,sBAAsBlC,EAAOyR,iBAAiBrY,MAAM,EAAG,GAAG4H,KAAK,QAAQhB,EAAOyR,iBAAiB1Q,OAAS,EAAI,MAAQ,MAG7Hf,EAAOuF,SAASxE,OAAS,EAAG,CAC9BsL,EAAMnK,KAAK,aACX,IAAK,MAAMqQ,KAAWvS,EAAOuF,SAC3B8G,EAAMnK,KAAK,OAAOqQ,IAEtB,CAEA,OAAOlG,EAAMrL,KAAK,KACpB,E,GC5NEwR,EAA2B,CAAC,E,OAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB/P,IAAjBgQ,EACH,OAAOA,EAAahb,QAGrB,IAAIC,EAAS4a,EAAyBE,GAAY,CAGjD/a,QAAS,CAAC,GAOX,OAHAib,EAAoBF,GAAUG,KAAKjb,EAAOD,QAASC,EAAQA,EAAOD,QAAS8a,GAGpE7a,EAAOD,OACf,CCnB0B8a,CAAoB,iB","sources":["webpack://StoryGrammar/webpack/universalModuleDefinition","webpack://StoryGrammar/./src/EnglishModifiers.ts","webpack://StoryGrammar/./src/Parser.ts","webpack://StoryGrammar/./src/ParserCore.ts","webpack://StoryGrammar/./src/analysis/ComplexityAnalyzer.ts","webpack://StoryGrammar/./src/analysis/ProbabilityAnalyzer.ts","webpack://StoryGrammar/./src/core/ErrorHandler.ts","webpack://StoryGrammar/./src/core/VariableExpander.ts","webpack://StoryGrammar/./src/index.ts","webpack://StoryGrammar/./src/modifiers/english/ArticleModifier.ts","webpack://StoryGrammar/./src/modifiers/english/CapitalizationModifier.ts","webpack://StoryGrammar/./src/modifiers/english/OrdinalModifier.ts","webpack://StoryGrammar/./src/modifiers/english/PluralizationModifier.ts","webpack://StoryGrammar/./src/modifiers/english/PossessiveModifier.ts","webpack://StoryGrammar/./src/modifiers/english/PunctuationCleanupModifier.ts","webpack://StoryGrammar/./src/modifiers/english/VerbAgreementModifier.ts","webpack://StoryGrammar/./src/modifiers/english/index.ts","webpack://StoryGrammar/./src/modifiers/index.ts","webpack://StoryGrammar/./src/rules/AdvancedRuleManagers.ts","webpack://StoryGrammar/./src/rules/BaseRuleManager.ts","webpack://StoryGrammar/./src/rules/RuleManager.ts","webpack://StoryGrammar/./src/utils/SeededRandom.ts","webpack://StoryGrammar/./src/validation/GrammarValidator.ts","webpack://StoryGrammar/webpack/bootstrap","webpack://StoryGrammar/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StoryGrammar\"] = factory();\n\telse\n\t\troot[\"StoryGrammar\"] = factory();\n})(this, () => {\nreturn ","/**\n * English language modifiers for the Story Grammar Parser\n */\n\nimport { Modifier } from './types.js';\n\n/**\n * English article modifier (a/an correction)\n * Converts \"a\" to \"an\" before vowel sounds\n */\nexport const EnglishArticleModifier: Modifier = {\n  name: 'englishArticles',\n  condition: (text: string) => {\n    return /\\ba\\s+[aeiouAEIOU]/.test(text);\n  },\n  transform: (text: string) => {\n    // More precise regex to handle vowel sounds at word boundaries\n    return text.replace(/\\ba(\\s+)([aeiouAEIOU][a-z]*)/gi, 'an$1$2');\n  },\n  priority: 10\n};\n\n/**\n * English pluralization modifier\n * Handles comprehensive pluralization patterns including irregular forms\n */\nexport const EnglishPluralizationModifier: Modifier = {\n  name: 'englishPluralization',\n  condition: (text: string) => {\n    // Look for plural indicators: numbers > 1, \"many\", \"several\", \"multiple\", etc.\n    return /\\b(many|several|multiple|some|few|all|both|various|numerous|[2-9]\\d*|\\d*[02-9])\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(zero|no)\\s+[a-zA-Z]+/i.test(text); // Zero/no also takes plural\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(many|several|multiple|some|few|all|both|various|numerous|zero|no|[2-9]\\d*|\\d*[02-9]|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+([a-zA-Z]+)\\b/gi, \n      (match, quantifier, noun) => {\n        const pluralNoun = pluralize(noun);\n        return `${quantifier} ${pluralNoun}`;\n      }\n    );\n  },\n  priority: 9\n};\n\n/**\n * English ordinal modifier\n * Converts cardinal numbers to ordinal format (1 -> 1st, 2 -> 2nd, etc.)\n */\nexport const EnglishOrdinalModifier: Modifier = {\n  name: 'englishOrdinals',\n  condition: (text: string) => {\n    // Look for standalone numbers (digits)\n    return /\\b\\d+\\b/.test(text);\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(\\d+)\\b/g, (match, num) => {\n      const number = parseInt(num, 10);\n      \n      // Get the last digit and last two digits\n      const lastDigit = number % 10;\n      const lastTwoDigits = number % 100;\n      \n      // Exception: numbers ending in 11, 12, 13 use 'th'\n      if (lastTwoDigits === 11 || lastTwoDigits === 12 || lastTwoDigits === 13) {\n        return num + 'th';\n      }\n      \n      // Apply ordinal rules based on last digit\n      switch (lastDigit) {\n        case 1:\n          return num + 'st';\n        case 2:\n          return num + 'nd';\n        case 3:\n          return num + 'rd';\n        default:\n          return num + 'th';\n      }\n    });\n  },\n  priority: 8\n};\n\n/**\n * English capitalization modifier\n * Capitalizes words after sentence-ending punctuation\n */\nexport const EnglishCapitalizationModifier: Modifier = {\n  name: 'englishCapitalization',\n  condition: (text: string) => {\n    // Look for lowercase letters after sentence endings\n    return /[.!?]\\s+[a-z]/.test(text);\n  },\n  transform: (text: string) => {\n    // Capitalize first letter of sentences\n    return text.replace(/([.!?]\\s+)([a-z])/g, (match, punctuation, letter) => {\n      return punctuation + letter.toUpperCase();\n    });\n  },\n  priority: 7\n};\n\n/**\n * English possessive modifier\n * Handles English possessive forms ('s and s')\n */\nexport const EnglishPossessiveModifier: Modifier = {\n  name: 'englishPossessives',\n  condition: (text: string) => {\n    // Look for possessive patterns: word + possessive marker\n    return /\\b\\w+\\s+possessive\\b/i.test(text) || /\\b\\w+'s?\\s+\\w/.test(text);\n  },\n  transform: (text: string) => {\n    // Handle explicit possessive marker\n    text = text.replace(/\\b(\\w+)\\s+possessive\\b/gi, (match, word) => {\n      return word.endsWith('s') ? word + \"'\" : word + \"'s\";\n    });\n    \n    // Fix double possessives (word's's -> word's)\n    text = text.replace(/(\\w+)'s's/g, \"$1's\");\n    \n    return text;\n  },\n  priority: 6\n};\n\n/**\n * English verb agreement modifier\n * Handles basic subject-verb agreement for common verbs\n */\nexport const EnglishVerbAgreementModifier: Modifier = {\n  name: 'englishVerbAgreement',\n  condition: (text: string) => {\n    // Look for agreement issues\n    return /\\b(he|she|it)\\s+are\\b/i.test(text) || \n           /\\b(they|many|several|few|all|both)\\s+is\\b/i.test(text) ||\n           /\\b(he|she|it)\\s+have\\b/i.test(text) ||\n           /\\b(they|many|several|few|all|both)\\s+has\\b/i.test(text);\n  },\n  transform: (text: string) => {\n    // Fix is/are agreement for singular subjects\n    text = text.replace(/\\b(he|she|it)\\s+are\\b/gi, '$1 is');\n    \n    // Fix is/are agreement for plural subjects and quantifiers\n    text = text.replace(/\\b(they|many|several|few|all|both)\\s+is\\b/gi, '$1 are');\n    \n    // Fix has/have agreement for singular subjects\n    text = text.replace(/\\b(he|she|it)\\s+have\\b/gi, '$1 has');\n    \n    // Fix has/have agreement for plural subjects and quantifiers\n    text = text.replace(/\\b(they|many|several|few|all|both)\\s+has\\b/gi, '$1 have');\n    \n    return text;\n  },\n  priority: 5\n};\n\n/**\n * Punctuation cleanup modifier\n * Fixes common punctuation issues like double spaces and spacing around punctuation\n */\nexport const PunctuationCleanupModifier: Modifier = {\n  name: 'punctuationCleanup',\n  condition: (text: string) => {\n    // Look for punctuation spacing issues\n    return /\\s{2,}/.test(text) || /\\s[.!?,:;]/.test(text) || /[.!?,:;]\\S/.test(text);\n  },\n  transform: (text: string) => {\n    // Fix multiple spaces\n    text = text.replace(/\\s{2,}/g, ' ');\n    \n    // Fix space before punctuation\n    text = text.replace(/\\s([.!?,:;])/g, '$1');\n    \n    // Add space after punctuation if missing (except at end)\n    text = text.replace(/([.!?,:;])([A-Za-z])/g, '$1 $2');\n    \n    // Trim leading/trailing whitespace\n    text = text.trim();\n    \n    return text;\n  },\n  priority: 1\n};\n\n// Helper functions\n\n/**\n * Convert a singular noun to its plural form\n * @param noun - The singular noun to pluralize\n * @returns The plural form of the noun\n */\nfunction pluralize(noun: string): string {\n  const lowerNoun = noun.toLowerCase();\n  \n  // Irregular plurals mapping\n  const irregularPlurals: { [key: string]: string } = {\n    'addendum': 'addenda',\n    'aircraft': 'aircraft',\n    'alumna': 'alumnae',\n    'alumnus': 'alumni',\n    'analysis': 'analyses',\n    'antenna': 'antennae',\n    'antithesis': 'antitheses',\n    'apex': 'apices',\n    'appendix': 'appendices',\n    'axis': 'axes',\n    'bacillus': 'bacilli',\n    'bacterium': 'bacteria',\n    'basis': 'bases',\n    'beau': 'beaux',\n    'bison': 'bison',\n    'bureau': 'bureaux',\n    'cactus': 'cacti',\n    'chteau': 'chteaux',\n    'child': 'children',\n    'codex': 'codices',\n    'concerto': 'concerti',\n    'corpus': 'corpora',\n    'crisis': 'crises',\n    'criterion': 'criteria',\n    'curriculum': 'curricula',\n    'datum': 'data',\n    'deer': 'deer',\n    'diagnosis': 'diagnoses',\n    'die': 'dice',\n    'dwarf': 'dwarves',\n    'ellipsis': 'ellipses',\n    'erratum': 'errata',\n    'fez': 'fezzes',\n    'fish': 'fish',\n    'focus': 'foci',\n    'foot': 'feet',\n    'formula': 'formulae',\n    'fungus': 'fungi',\n    'genus': 'genera',\n    'goose': 'geese',\n    'graffito': 'graffiti',\n    'grouse': 'grouse',\n    'half': 'halves',\n    'hoof': 'hooves',\n    'hypothesis': 'hypotheses',\n    'index': 'indices',\n    'larva': 'larvae',\n    'libretto': 'libretti',\n    'loaf': 'loaves',\n    'locus': 'loci',\n    'louse': 'lice',\n    'man': 'men',\n    'matrix': 'matrices',\n    'medium': 'media',\n    'memorandum': 'memoranda',\n    'minutia': 'minutiae',\n    'moose': 'moose',\n    'mouse': 'mice',\n    'nebula': 'nebulae',\n    'nucleus': 'nuclei',\n    'oasis': 'oases',\n    'offspring': 'offspring',\n    'opus': 'opera',\n    'ovum': 'ova',\n    'ox': 'oxen',\n    'parenthesis': 'parentheses',\n    'person': 'people',\n    'phenomenon': 'phenomena',\n    'phylum': 'phyla',\n    'quiz': 'quizzes',\n    'radius': 'radii',\n    'referendum': 'referenda',\n    'salmon': 'salmon',\n    'scarf': 'scarves',\n    'self': 'selves',\n    'series': 'series',\n    'sheep': 'sheep',\n    'shrimp': 'shrimp',\n    'species': 'species',\n    'stimulus': 'stimuli',\n    'stratum': 'strata',\n    'swine': 'swine',\n    'syllabus': 'syllabi',\n    'symposium': 'symposia',\n    'synopsis': 'synopses',\n    'tableau': 'tableaux',\n    'thesis': 'theses',\n    'thief': 'thieves',\n    'tooth': 'teeth',\n    'trout': 'trout',\n    'tuna': 'tuna',\n    'vertebra': 'vertebrae',\n    'vertex': 'vertices',\n    'vita': 'vitae',\n    'vortex': 'vortices',\n    'wharf': 'wharves',\n    'wife': 'wives',\n    'wolf': 'wolves',\n    'woman': 'women'\n  };\n  \n  // Check for irregular plurals first\n  if (irregularPlurals[lowerNoun]) {\n    const irregularPlural = irregularPlurals[lowerNoun];\n    // Preserve original case pattern\n    return preserveCase(noun, irregularPlural);\n  }\n  \n  // Apply regular pluralization rules in order of specificity\n  \n  // 1. Words ending in -s, -ss, -sh, -ch, -x, -z: add -es\n  if (/[sxz]$/.test(lowerNoun) || /[sc]h$/.test(lowerNoun)) {\n    return noun + 'es';\n  }\n  \n  // 2. Words ending in consonant + y: change y to ies\n  if (/[bcdfghjklmnpqrstvwxz]y$/i.test(lowerNoun)) {\n    return noun.slice(0, -1) + 'ies';\n  }\n  \n  // 3. Words ending in vowel + y: just add -s\n  if (/[aeiou]y$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 4. Words ending in -f or -fe: change to -ves (with exceptions)\n  if (/fe?$/i.test(lowerNoun)) {\n    // Exceptions that just add -s\n    const fExceptions = ['belief', 'chief', 'cliff', 'proof', 'roof', 'safe', 'chef', 'handkerchief'];\n    if (fExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun.replace(/fe?$/i, 'ves');\n  }\n  \n  // 5. Words ending in consonant + o: add -es (with common exceptions)\n  if (/[bcdfghjklmnpqrstvwxz]o$/i.test(lowerNoun)) {\n    // Common exceptions that just add -s\n    const oExceptions = [\n      'photo', 'piano', 'halo', 'disco', 'studio', 'radio', 'video', \n      'auto', 'memo', 'pro', 'casino', 'patio', 'portfolio', 'logo',\n      'commando', 'solo', 'soprano', 'alto', 'kimono'\n    ];\n    if (oExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun + 'es';\n  }\n  \n  // 6. Words ending in vowel + o: just add -s\n  if (/[aeiou]o$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 7. Default case: add -s\n  return noun + 's';\n}\n\n/**\n * Preserve the case pattern of the original word in the plural form\n * @param original - The original word with its case pattern\n * @param plural - The lowercase plural form\n * @returns The plural with preserved case pattern\n */\nfunction preserveCase(original: string, plural: string): string {\n  // If original is all uppercase, make plural all uppercase\n  if (original === original.toUpperCase()) {\n    return plural.toUpperCase();\n  }\n  \n  // If original starts with uppercase, capitalize the plural\n  if (original[0] === original[0].toUpperCase()) {\n    return plural.charAt(0).toUpperCase() + plural.slice(1);\n  }\n  \n  // Otherwise, return lowercase plural\n  return plural;\n}\n\n/**\n * Collection of all English modifiers for convenience\n */\nexport const AllEnglishModifiers = [\n  EnglishArticleModifier,\n  EnglishPluralizationModifier,\n  EnglishOrdinalModifier,\n  EnglishCapitalizationModifier,\n  EnglishPossessiveModifier,\n  EnglishVerbAgreementModifier,\n  PunctuationCleanupModifier\n];\n\n/**\n * Basic English modifiers (articles, pluralization, ordinals)\n */\nexport const BasicEnglishModifiers = [\n  EnglishArticleModifier,\n  EnglishPluralizationModifier,\n  EnglishOrdinalModifier\n];","/**\n * Parser for combinatorial grammar with variable expansion\n * \n * This file re-exports the core Parser class and all types for backward compatibility.\n * The actual implementation has been moved to separate files for better modularity.\n */\n\n// Re-export all types and interfaces\nexport * from './types.js';\n\n// Re-export the core Parser class\nexport { Parser } from './ParserCore.js';","/**\n * Simplified Parser class that coordinates between all the specialized modules\n */\nimport {\n  Grammar,\n  Modifier,\n  ModifierContext,\n  FunctionRule,\n  ConditionalRule,\n  SequentialRule,\n  RangeRule,\n  TemplateRule,\n  ParseOptions,\n  ParseResult,\n  ValidationResult,  \n  ParseTimingResult,\n  ParserStats,\n  ParserConfig,\n  OptimizationReport,\n  RuleAnalysis,\n  ErrorContext,\n  ComplexityResult,\n  TotalComplexityResult,\n  ProbabilityAnalysis,\n  ProbabilityResult\n} from './types.js';\n\n// Import all the specialized modules\nimport { SeededRandom } from './utils/SeededRandom.js';\nimport { RuleManager } from './rules/RuleManager.js';\nimport { VariableExpander } from './core/VariableExpander.js';\nimport { ComplexityAnalyzer } from './analysis/ComplexityAnalyzer.js';\nimport { ProbabilityAnalyzer } from './analysis/ProbabilityAnalyzer.js';\nimport { GrammarValidator } from './validation/GrammarValidator.js';\nimport { ErrorHandler } from './core/ErrorHandler.js';\n\nexport class Parser {\n  // Core modules\n  private random: SeededRandom;\n  private ruleManager: RuleManager;\n  private variableExpander: VariableExpander;\n  private complexityAnalyzer: ComplexityAnalyzer;\n  private probabilityAnalyzer: ProbabilityAnalyzer;\n  private validator: GrammarValidator;\n  private errorHandler: ErrorHandler;\n  \n  // Modifiers\n  private modifiers: Map<string, Modifier> = new Map();\n\n  constructor() {\n    // Initialize all modules\n    this.random = new SeededRandom();\n    this.ruleManager = new RuleManager();\n    this.variableExpander = new VariableExpander(this.ruleManager, this.random);\n    this.complexityAnalyzer = new ComplexityAnalyzer(this.ruleManager, this.variableExpander);\n    this.probabilityAnalyzer = new ProbabilityAnalyzer(this.ruleManager, this.variableExpander);\n    this.validator = new GrammarValidator(this.ruleManager, this.variableExpander);\n    this.errorHandler = new ErrorHandler(this.ruleManager, this.validator);\n  }\n\n  // ==================== RULE MANAGEMENT ====================\n\n  /**\n   * Add a static rule to the grammar\n   */\n  public addRule(key: string, values: string[]): void {\n    this.ruleManager.addRule(key, values);\n  }\n\n  /**\n   * Add multiple rules to the grammar\n   */\n  public addRules(rules: Grammar): void {\n    this.ruleManager.addRules(rules);\n  }\n\n  /**\n   * Add a function rule to the grammar\n   */\n  public addFunctionRule(key: string, fn: FunctionRule): void {\n    this.ruleManager.addFunctionRule(key, fn);\n  }\n\n  /**\n   * Add a weighted rule for probability-controlled random selection\n   */\n  public addWeightedRule(key: string, values: string[], weights: number[]): void {\n    this.ruleManager.addWeightedRule(key, values, weights);\n  }\n\n  /**\n   * Add a context-aware conditional rule for dynamic value selection\n   */\n  public addConditionalRule(key: string, rule: ConditionalRule): void {\n    this.ruleManager.addConditionalRule(key, rule);\n  }\n\n  /**\n   * Add a sequential rule for ordered value progression\n   */\n  public addSequentialRule(key: string, values: string[], options: { cycle: boolean } = { cycle: true }): void {\n    this.ruleManager.addSequentialRule(key, values, options);\n  }\n\n  /**\n   * Add a numeric range rule for generating values within specified bounds\n   */\n  public addRangeRule(key: string, config: { min: number; max: number; step?: number; type: 'integer' | 'float' }): void {\n    this.ruleManager.addRangeRule(key, config);\n  }\n\n  /**\n   * Add a template rule for structured text generation with embedded variables\n   */\n  public addTemplateRule(key: string, rule: TemplateRule): void {\n    this.ruleManager.addTemplateRule(key, rule);\n  }\n\n  // Rule checking and removal methods\n  public hasRule(key: string): boolean { return this.ruleManager.hasRule(key); }\n  public removeRule(key: string): boolean { return this.ruleManager.removeRule(key); }\n  public clear(): void { this.ruleManager.clear(); }\n\n  // Specific rule type checks\n  public hasFunctionRule(key: string): boolean { return this.ruleManager.hasFunctionRule(key); }\n  public hasWeightedRule(key: string): boolean { return this.ruleManager.hasWeightedRule(key); }\n  public hasConditionalRule(key: string): boolean { return this.ruleManager.hasConditionalRule(key); }\n  public hasSequentialRule(key: string): boolean { return this.ruleManager.hasSequentialRule(key); }\n  public hasRangeRule(key: string): boolean { return this.ruleManager.hasRangeRule(key); }\n  public hasTemplateRule(key: string): boolean { return this.ruleManager.hasTemplateRule(key); }\n\n  // Specific rule type removal\n  public removeFunctionRule(key: string): boolean { return this.ruleManager.removeFunctionRule(key); }\n  public removeWeightedRule(key: string): boolean { return this.ruleManager.removeWeightedRule(key); }\n  public removeConditionalRule(key: string): boolean { return this.ruleManager.removeConditionalRule(key); }\n  public removeSequentialRule(key: string): boolean { return this.ruleManager.removeSequentialRule(key); }\n  public removeRangeRule(key: string): boolean { return this.ruleManager.removeRangeRule(key); }\n  public removeTemplateRule(key: string): boolean { return this.ruleManager.removeTemplateRule(key); }\n\n  // Clear specific rule types\n  public clearFunctionRules(): void { this.ruleManager.clearFunctionRules(); }\n  public clearWeightedRules(): void { this.ruleManager.clearWeightedRules(); }\n  public clearConditionalRules(): void { this.ruleManager.clearConditionalRules(); }\n  public clearSequentialRules(): void { this.ruleManager.clearSequentialRules(); }\n  public clearRangeRules(): void { this.ruleManager.clearRangeRules(); }\n  public clearTemplateRules(): void { this.ruleManager.clearTemplateRules(); }\n\n  // Special operations\n  public resetSequentialRule(key: string): boolean { return this.ruleManager.resetSequentialRule(key); }\n  public getGrammar(): Grammar { return this.ruleManager.getGrammar(); }\n\n  // ==================== MODIFIER MANAGEMENT ====================\n\n  /**\n   * Add a modifier to the grammar\n   */\n  public addModifier(modifier: Modifier): void {\n    if (!modifier || typeof modifier !== 'object') {\n      throw new Error('Modifier must be an object');\n    }\n    if (!modifier.name || typeof modifier.name !== 'string') {\n      throw new Error('Modifier must have a name');\n    }\n    if (typeof modifier.condition !== 'function') {\n      throw new Error('Modifier must have a condition function');\n    }\n    if (typeof modifier.transform !== 'function') {\n      throw new Error('Modifier must have a transform function');\n    }\n    \n    this.modifiers.set(modifier.name, {\n      ...modifier,\n      priority: modifier.priority ?? 0\n    });\n  }\n\n  /**\n   * Remove a modifier from the grammar\n   */\n  public removeModifier(name: string): boolean {\n    return this.modifiers.delete(name);\n  }\n\n  /**\n   * Check if a modifier exists\n   */\n  public hasModifier(name: string): boolean {\n    return this.modifiers.has(name);\n  }\n\n  /**\n   * Get all modifiers sorted by priority\n   */\n  public getModifiers(): Modifier[] {\n    return Array.from(this.modifiers.values()).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n  }\n\n  /**\n   * Load a modifier into the parser\n   */\n  public loadModifier(modifier: Modifier): void {\n    this.addModifier(modifier);\n  }\n\n  /**\n   * Load multiple modifiers into the parser\n   */\n  public loadModifiers(modifiers: Modifier[]): void {\n    for (const modifier of modifiers) {\n      this.addModifier(modifier);\n    }\n  }\n\n  /**\n   * Clear all modifiers\n   */\n  public clearModifiers(): void {\n    this.modifiers.clear();\n  }\n\n  /**\n   * Clear all rules and modifiers\n   */\n  public clearAll(): void {\n    this.clear();\n    this.clearModifiers();\n  }\n\n  // ==================== PARSING ====================\n\n  /**\n   * Parse and expand variables in text using the configured grammar rules\n   * \n   * This is the core parsing method that processes text containing %variable% placeholders,\n   * replacing them with generated values according to the defined grammar rules.\n   * \n   * @param text - Input text containing %variable% placeholders to expand\n   * @param preserveContext - If true, maintains variable values from previous parse calls\n   * @returns Fully expanded text with all variables replaced and modifiers applied\n   */\n  public parse(text: string, preserveContext: boolean = false): string {\n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    \n    const expanded = this.variableExpander.expandVariables(text, preserveContext);\n    return this.applyModifiers(expanded, { originalText: text });\n  }\n\n  /**\n   * Parse text with performance timing\n   */\n  public parseWithTiming(text: string, preserveContext: boolean = false): ParseTimingResult {\n    const startTime = Date.now();\n    \n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    \n    const expansionStart = Date.now();\n    const expanded = this.variableExpander.expandVariables(text, preserveContext);\n    const expansionEnd = Date.now();\n    \n    const modifierStart = Date.now();\n    const result = this.applyModifiers(expanded, { originalText: text });\n    const modifierEnd = Date.now();\n    \n    const totalEnd = Date.now();\n    \n    return {\n      result,\n      timing: {\n        totalMs: totalEnd - startTime,\n        expansionMs: expansionEnd - expansionStart,\n        modifierMs: modifierEnd - modifierStart\n      }\n    };\n  }\n\n  /**\n   * Parse text with comprehensive error handling and retry logic\n   */\n  public safeParse(text: string, options: ParseOptions = {}): ParseResult {\n    const {\n      preserveContext = false,\n      validateFirst = true,\n      maxAttempts = 3\n    } = options;\n\n    let attempts = 0;\n\n    while (attempts < maxAttempts) {\n      attempts++;\n\n      try {\n        // Validate grammar first if requested\n        if (validateFirst && attempts === 1) {\n          const validation = this.validate();\n          if (!validation.isValid) {\n            let error = 'Validation failed';\n            if (validation.missingRules.length > 0) {\n              error = `Validation failed - missing rules: ${validation.missingRules.join(', ')}`;\n            }\n            return {\n              success: false,\n              error,\n              attempts,\n              validation\n            };\n          }\n        }\n\n        const result = this.parse(text, preserveContext);\n        return {\n          success: true,\n          result,\n          attempts\n        };\n\n      } catch (error) {\n        if (attempts >= maxAttempts) {\n          return {\n            success: false,\n            error: this.errorHandler.getHelpfulError(error as Error, { text }),\n            attempts\n          };\n        }\n\n        // For recursion errors, try reducing max depth\n        if (this.errorHandler['isRecursionError'](error as Error)) {\n          const currentDepth = this.variableExpander.getMaxDepth();\n          this.variableExpander.setMaxDepth(Math.max(10, Math.floor(currentDepth * 0.7)));\n        }\n      }\n    }\n\n    return {\n      success: false,\n      error: 'Maximum attempts exceeded',\n      attempts\n    };\n  }\n\n  /**\n   * Apply all applicable modifiers to text\n   * @private\n   */\n  private applyModifiers(text: string, context?: ModifierContext): string {\n    let modifiedText = text;\n    \n    // Get modifiers sorted by priority (higher priority first)\n    const sortedModifiers = this.getModifiers();\n    \n    for (const modifier of sortedModifiers) {\n      if (modifier.condition(modifiedText, context)) {\n        modifiedText = modifier.transform(modifiedText, context);\n      }\n    }\n    \n    return modifiedText;\n  }\n\n  // ==================== BATCH PROCESSING ====================\n\n  /**\n   * Efficiently process multiple texts with optimized context management\n   */\n  public parseBatch(texts: string[], preserveContext: boolean = true): string[] {\n    if (!Array.isArray(texts)) {\n      throw new Error('Texts must be an array');\n    }\n\n    const results: string[] = [];\n    \n    for (let i = 0; i < texts.length; i++) {\n      const shouldPreserve = preserveContext && i > 0;\n      results.push(this.parse(texts[i], shouldPreserve));\n    }\n    \n    return results;\n  }\n\n  /**\n   * Generate multiple unique variations of text for testing and content creation\n   */\n  public generateVariations(text: string, count: number, seed?: number): string[] {\n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    if (!Number.isInteger(count) || count <= 0) {\n      throw new Error('Count must be a positive integer');\n    }\n\n    const variations: string[] = [];\n    const originalSeed = this.random.getSeed();\n\n    try {\n      for (let i = 0; i < count; i++) {\n        if (seed !== undefined) {\n          this.random.setSeed(seed + i);\n        }\n        variations.push(this.parse(text, false));\n      }\n\n      return variations;\n    } finally {\n      // Restore original seed state\n      if (originalSeed !== null) {\n        this.random.setSeed(originalSeed);\n      } else {\n        this.random.clearSeed();\n      }\n    }\n  }\n\n  // ==================== CONFIGURATION ====================\n\n  /**\n   * Set maximum recursion depth for variable expansion\n   */\n  public setMaxDepth(depth: number): void {\n    this.variableExpander.setMaxDepth(depth);\n  }\n\n  /**\n   * Get the current maximum recursion depth\n   */\n  public getMaxDepth(): number {\n    return this.variableExpander.getMaxDepth();\n  }\n\n  /**\n   * Configure deterministic random number generation for reproducible results\n   */\n  public setRandomSeed(seed: number): void {\n    this.random.setSeed(seed);\n  }\n\n  /**\n   * Clear the random seed and return to using Math.random()\n   */\n  public clearRandomSeed(): void {\n    this.random.clearSeed();\n  }\n\n  /**\n   * Get the current random seed, if any\n   */\n  public getRandomSeed(): number | null {\n    return this.random.getSeed();\n  }\n\n  /**\n   * Clear all reference values and reset context\n   */\n  public clearReferences(): void {\n    this.variableExpander.clearReferences();\n  }\n\n  /**\n   * Get the current context of generated values\n   */\n  public getContext(): { [key: string]: string } {\n    return this.variableExpander.getContext();\n  }\n\n  // ==================== ANALYSIS ====================\n\n  /**\n   * Calculate the complexity (number of possible outcomes) for a specific rule\n   */\n  public calculateRuleComplexity(ruleKey: string, visited: Set<string> = new Set(), maxDepth: number = 50): ComplexityResult {\n    return this.complexityAnalyzer.calculateRuleComplexity(ruleKey, visited, maxDepth);\n  }\n\n  /**\n   * Calculate total complexity across all rules in the grammar\n   */\n  public calculateTotalComplexity(maxDepth: number = 50): TotalComplexityResult {\n    return this.complexityAnalyzer.calculateTotalComplexity(maxDepth);\n  }\n\n  /**\n   * Calculate probability analysis for a specific rule\n   */\n  public calculateProbabilities(ruleKey: string, maxDepth: number = 50, maxOutcomes: number = 1000): ProbabilityAnalysis {\n    return this.probabilityAnalyzer.calculateProbabilities(ruleKey, maxDepth, maxOutcomes);\n  }\n\n  /**\n   * Get the most probable outcome for a rule\n   */\n  public getMostProbableOutcome(ruleKey: string, maxDepth: number = 50, maxOutcomes: number = 1000): ProbabilityResult | null {\n    return this.probabilityAnalyzer.getMostProbableOutcome(ruleKey, maxDepth, maxOutcomes);\n  }\n\n  /**\n   * Get the least probable outcome for a rule\n   */\n  public getLeastProbableOutcome(ruleKey: string, maxDepth: number = 50, maxOutcomes: number = 1000): ProbabilityResult | null {\n    return this.probabilityAnalyzer.getLeastProbableOutcome(ruleKey, maxDepth, maxOutcomes);\n  }\n\n  // ==================== VALIDATION ====================\n\n  /**\n   * Perform comprehensive grammar validation to detect potential issues\n   */\n  public validate(): ValidationResult {\n    return this.validator.validate();\n  }\n\n  /**\n   * Get all variable names found in a text string\n   */\n  public findVariables(text: string): string[] {\n    return this.variableExpander.findVariables(text);\n  }\n\n  /**\n   * Generate helpful error messages with contextual suggestions\n   */\n  public getHelpfulError(error: Error, context?: ErrorContext): string {\n    return this.errorHandler.getHelpfulError(error, context);\n  }\n\n  // ==================== STATISTICS AND UTILITIES ====================\n\n  /**\n   * Get comprehensive performance statistics and configuration metrics\n   */\n  public getStats(): ParserStats {\n    const ruleStats = this.ruleManager.getStats();\n    \n    return {\n      totalRules: ruleStats.total,\n      rulesByType: {\n        static: ruleStats.static,\n        function: ruleStats.function,\n        weighted: ruleStats.weighted,\n        conditional: ruleStats.conditional,\n        sequential: ruleStats.sequential,\n        range: ruleStats.range,\n        template: ruleStats.template\n      },\n      totalModifiers: this.modifiers.size,\n      maxDepth: this.getMaxDepth(),\n      hasRandomSeed: this.random.getSeed() !== null\n    };\n  }\n\n  /**\n   * Create a lightweight copy of the parser for parallel processing or experimentation\n   */\n  public clone(): Parser {\n    const cloned = new Parser();\n    \n    // Copy static rules\n    const grammar = this.getGrammar();\n    cloned.addRules(grammar);\n    \n    // Copy settings\n    cloned.setMaxDepth(this.getMaxDepth());\n    const seed = this.getRandomSeed();\n    if (seed !== null) {\n      cloned.setRandomSeed(seed);\n    }\n    \n    // Copy modifiers\n    const modifiers = this.getModifiers();\n    cloned.loadModifiers(modifiers);\n    \n    return cloned;\n  }\n\n  // ==================== PLACEHOLDER METHODS ====================\n  // These methods are included for compatibility but may not be fully implemented\n\n  /**\n   * Export the parser configuration as JSON\n   */\n  public exportConfig(): ParserConfig {\n    // Placeholder implementation\n    return {\n      grammar: this.getGrammar(),\n      modifiers: this.getModifiers().map(m => m.name),\n      settings: {\n        maxDepth: this.getMaxDepth(),\n        randomSeed: this.getRandomSeed()\n      }\n    };\n  }\n\n  /**\n   * Optimize the parser for better performance\n   */\n  public optimize(): OptimizationReport {\n    const validation = this.validate();\n    const warnings = [...validation.warnings];\n    const suggestions = [];\n    \n    // Add optimization-specific warnings and suggestions\n    if (this.variableExpander.getMaxDepth() > 20) {\n      suggestions.push('Consider reducing max depth for better performance.');\n    }\n    \n    // Check modifier count\n    if (this.modifiers.size >= 15) {\n      warnings.push(`Many modifiers (${this.modifiers.size}). High-priority modifiers run first.`);\n    }\n    \n    suggestions.push(...validation.missingRules.concat(validation.circularReferences));\n    \n    return {\n      warnings,\n      suggestions,\n      optimized: false // Always false for now since we don't actually optimize\n    };\n  }\n\n  /**\n   * Analyze grammar complexity, performance characteristics, and usage patterns\n   */\n  public analyzeRules(ruleName?: string): RuleAnalysis {\n    if (ruleName) {\n      const complexity = this.calculateRuleComplexity(ruleName);\n      return {\n        totalComplexity: complexity.complexity,\n        averageDepth: complexity.depth,\n        mostComplex: [complexity.ruleName],\n        suggestions: complexity.warnings,\n        ruleDetails: {\n          name: complexity.ruleName,\n          type: complexity.ruleType,\n          complexity: complexity.complexity,\n          variables: complexity.variables,\n          depth: complexity.depth\n        }\n      };\n    } else {\n      const totalComplexity = this.calculateTotalComplexity();\n      const suggestions = [...totalComplexity.warnings];\n      \n      // Add analysis-based suggestions\n      const totalRules = Object.keys(this.ruleManager.getGrammar()).length;\n      if (totalRules > 50) {\n        suggestions.push('Large number of rules - consider organizing into groups');\n      }\n      \n      if (totalComplexity.totalComplexity > 100) {\n        suggestions.push('High total complexity - consider simplifying rules');\n      }\n      \n      return {\n        totalComplexity: totalComplexity.totalComplexity,\n        averageDepth: totalComplexity.averageComplexity,\n        mostComplex: totalComplexity.mostComplexRules.map(r => r.ruleName),\n        suggestions\n      };\n    }\n  }\n}","/**\n * Complexity analysis for grammar rules\n */\nimport { \n  ComplexityResult, \n  TotalComplexityResult \n} from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { VariableExpander } from '../core/VariableExpander.js';\n\nexport class ComplexityAnalyzer {\n  constructor(\n    private ruleManager: RuleManager,\n    private variableExpander: VariableExpander\n  ) {}\n\n  /**\n   * Calculate the complexity (number of possible outcomes) for a specific rule\n   * \n   * This method analyzes a single rule and calculates how many different possible\n   * values it can generate, taking into account nested variables and rule dependencies.\n   * \n   * @param ruleKey - The name of the rule to analyze\n   * @param visited - Internal set to track visited rules (prevents infinite recursion)\n   * @param maxDepth - Maximum recursion depth to prevent stack overflow (default: 50)\n   * \n   * @returns ComplexityResult containing detailed analysis of the rule's complexity\n   * \n   * @throws {Error} If the rule does not exist\n   */\n  public calculateRuleComplexity(\n    ruleKey: string, \n    visited: Set<string> = new Set(), \n    maxDepth: number = 50\n  ): ComplexityResult {\n    const warnings: string[] = [];\n    const variables: Set<string> = new Set();\n    let ruleType = 'unknown';\n    let complexity = 1;\n    let isFinite = true;\n    \n    // Check if rule exists\n    if (!this.ruleManager.hasRule(ruleKey)) {\n      throw new Error(`Rule '${ruleKey}' does not exist`);\n    }\n    \n    // Check for circular references\n    if (visited.has(ruleKey)) {\n      warnings.push(`Circular reference detected for rule '${ruleKey}'`);\n      return {\n        ruleName: ruleKey,\n        complexity: 1,\n        ruleType: 'circular',\n        isFinite: true,\n        variables: [],\n        depth: visited.size,\n        warnings\n      };\n    }\n    \n    // Check maximum depth\n    if (visited.size >= maxDepth) {\n      warnings.push(`Maximum depth (${maxDepth}) reached, complexity may be underestimated`);\n      return {\n        ruleName: ruleKey,\n        complexity: 1,\n        ruleType: 'max-depth',\n        isFinite: true,\n        variables: [],\n        depth: visited.size,\n        warnings\n      };\n    }\n    \n    const newVisited = new Set(visited);\n    newVisited.add(ruleKey);\n    \n    // Determine rule type and calculate complexity\n    const type = this.ruleManager.getRuleType(ruleKey);\n    ruleType = type || 'unknown';\n    \n    switch (type) {\n      case 'static':\n        complexity = this.calculateStaticRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'weighted':\n        complexity = this.calculateWeightedRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'function':\n        complexity = Number.POSITIVE_INFINITY;\n        isFinite = false;\n        warnings.push(`Function rule '${ruleKey}' has infinite complexity (cannot be calculated)`);\n        break;\n      case 'conditional':\n        complexity = this.calculateConditionalRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'sequential':\n        complexity = this.calculateSequentialRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      case 'range':\n        complexity = this.calculateRangeRuleComplexity(ruleKey);\n        break;\n      case 'template':\n        complexity = this.calculateTemplateRuleComplexity(ruleKey, newVisited, maxDepth, variables, warnings);\n        break;\n      default:\n        warnings.push(`Unknown rule type for '${ruleKey}'`);\n        complexity = 1;\n    }\n    \n    return {\n      ruleName: ruleKey,\n      complexity,\n      ruleType,\n      isFinite,\n      variables: Array.from(variables),\n      depth: visited.size,\n      warnings\n    };\n  }\n\n  /**\n   * Calculate total complexity across all rules in the grammar\n   */\n  public calculateTotalComplexity(maxDepth: number = 50): TotalComplexityResult {\n    const allRuleKeys = this.ruleManager.getAllKeys();\n    const complexityByRule: ComplexityResult[] = [];\n    const warnings: string[] = [];\n    const circularReferences: string[] = [];\n    let totalComplexity = 0;\n    let isFinite = true;\n\n    // Calculate complexity for each rule\n    for (const ruleKey of allRuleKeys) {\n      try {\n        const result = this.calculateRuleComplexity(ruleKey, new Set(), maxDepth);\n        complexityByRule.push(result);\n        \n        if (!result.isFinite) {\n          isFinite = false;\n        } else {\n          totalComplexity += result.complexity;\n        }\n        \n        warnings.push(...result.warnings);\n        \n        if (result.warnings.some(w => w.includes('Circular reference'))) {\n          circularReferences.push(ruleKey);\n        }\n      } catch (error) {\n        warnings.push(`Error calculating complexity for rule '${ruleKey}': ${error}`);\n        complexityByRule.push({\n          ruleName: ruleKey,\n          complexity: 1,\n          ruleType: 'error',\n          isFinite: true,\n          variables: [],\n          depth: 0,\n          warnings: [`Error: ${error}`]\n        });\n      }\n    }\n\n    // Remove duplicate warnings\n    const uniqueWarnings = Array.from(new Set(warnings));\n    const uniqueCircularRefs = Array.from(new Set(circularReferences));\n\n    // Sort rules by complexity (descending)\n    const sortedByComplexity = [...complexityByRule]\n      .filter(r => r.isFinite)\n      .sort((a, b) => b.complexity - a.complexity);\n\n    // Get top 5 most complex rules\n    const mostComplexRules = sortedByComplexity.slice(0, 5);\n\n    // Calculate average complexity (only finite rules)\n    const finiteRules = complexityByRule.filter(r => r.isFinite);\n    const averageComplexity = finiteRules.length > 0 \n      ? finiteRules.reduce((sum, r) => sum + r.complexity, 0) / finiteRules.length \n      : 0;\n\n    return {\n      totalComplexity: isFinite ? totalComplexity : Number.POSITIVE_INFINITY,\n      isFinite,\n      ruleCount: allRuleKeys.length,\n      complexityByRule,\n      averageComplexity,\n      mostComplexRules,\n      warnings: uniqueWarnings,\n      circularReferences: uniqueCircularRefs\n    };\n  }\n\n  /**\n   * Calculate complexity for static grammar rules\n   */\n  private calculateStaticRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getGrammar()[ruleKey];\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const value of rule) {\n      const valueVariables = this.variableExpander.findVariables(value);\n      \n      if (valueVariables.length === 0) {\n        // Literal string\n        totalComplexity += 1;\n      } else {\n        // Calculate complexity by multiplying all variable complexities\n        let valueComplexity = 1;\n        for (const variable of valueVariables) {\n          variables.add(variable);\n          if (visited.has(variable)) {\n            // Circular reference detected during recursion\n            warnings.push(`Circular reference detected for rule '${variable}'`);\n            valueComplexity *= 1; // Treat as single possibility to avoid infinite recursion\n          } else if (visited.size >= maxDepth) {\n            // Max depth reached during recursion\n            warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n            valueComplexity *= 1; // Treat as single possibility\n          } else if (this.ruleManager.hasRule(variable)) {\n            const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n            if (!varResult.isFinite) {\n              return Number.POSITIVE_INFINITY;\n            }\n            valueComplexity *= varResult.complexity;\n            warnings.push(...varResult.warnings);\n          } else {\n            warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n            valueComplexity *= 1; // Treat as single possibility\n          }\n        }\n        totalComplexity += valueComplexity;\n      }\n    }\n    \n    return totalComplexity;\n  }\n\n  /**\n   * Calculate complexity for weighted rules\n   */\n  private calculateWeightedRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getWeightedRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const value of rule.values) {\n      const valueVariables = this.variableExpander.findVariables(value);\n      \n      if (valueVariables.length === 0) {\n        totalComplexity += 1;\n      } else {\n        let valueComplexity = 1;\n        for (const variable of valueVariables) {\n          variables.add(variable);\n          if (visited.has(variable)) {\n            warnings.push(`Circular reference detected for rule '${variable}'`);\n            valueComplexity *= 1;\n          } else if (visited.size >= maxDepth) {\n            warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n            valueComplexity *= 1;\n          } else if (this.ruleManager.hasRule(variable)) {\n            const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n            if (!varResult.isFinite) {\n              return Number.POSITIVE_INFINITY;\n            }\n            valueComplexity *= varResult.complexity;\n            warnings.push(...varResult.warnings);\n          } else {\n            warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n            valueComplexity *= 1;\n          }\n        }\n        totalComplexity += valueComplexity;\n      }\n    }\n    \n    return totalComplexity;\n  }\n\n    /**\n   * Calculate complexity for conditional rules\n   */\n  private calculateConditionalRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getConditionalRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const condition of rule.conditions) {\n      let conditionComplexity = 0;\n      \n      // Process values in 'then' or 'default' array\n      const values = condition.then || condition.default || [];\n      \n      for (const value of values) {\n        const valueVariables = this.variableExpander.findVariables(value);\n        \n        if (valueVariables.length === 0) {\n          conditionComplexity += 1;\n        } else {\n          let valueComplexity = 1;\n          for (const variable of valueVariables) {\n            variables.add(variable);\n            if (visited.has(variable)) {\n              warnings.push(`Circular reference detected for rule '${variable}'`);\n              valueComplexity *= 1;\n            } else if (visited.size >= maxDepth) {\n              warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n              valueComplexity *= 1;\n            } else if (this.ruleManager.hasRule(variable)) {\n              const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n              if (!varResult.isFinite) {\n                return Number.POSITIVE_INFINITY;\n              }\n              valueComplexity *= varResult.complexity;\n              warnings.push(...varResult.warnings);\n            } else {\n              warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n              valueComplexity *= 1;\n            }\n          }\n          conditionComplexity += valueComplexity;\n        }\n      }\n      \n      totalComplexity += conditionComplexity;\n    }\n    \n    return totalComplexity;\n  }\n\n    /**\n   * Calculate complexity for sequential rules\n   */\n  private calculateSequentialRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getSequentialRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 0;\n    \n    for (const value of rule.values) {\n      const valueVariables = this.variableExpander.findVariables(value);\n      \n      if (valueVariables.length === 0) {\n        totalComplexity += 1;\n      } else {\n        let valueComplexity = 1;\n        for (const variable of valueVariables) {\n          variables.add(variable);\n          if (visited.has(variable)) {\n            warnings.push(`Circular reference detected for rule '${variable}'`);\n            valueComplexity *= 1;\n          } else if (visited.size >= maxDepth) {\n            warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n            valueComplexity *= 1;\n          } else if (this.ruleManager.hasRule(variable)) {\n            const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n            if (!varResult.isFinite) {\n              return Number.POSITIVE_INFINITY;\n            }\n            valueComplexity *= varResult.complexity;\n            warnings.push(...varResult.warnings);\n          } else {\n            warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n            valueComplexity *= 1;\n          }\n        }\n        totalComplexity += valueComplexity;\n      }\n    }\n    \n    return totalComplexity;\n  }\n\n  /**\n   * Calculate complexity for range rules\n   */\n  private calculateRangeRuleComplexity(ruleKey: string): number {\n    const rule = this.ruleManager.getRangeRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    // For range rules, complexity is the number of possible values\n    const step = rule.step || 1;\n    const possibleValues = Math.floor((rule.max - rule.min) / step) + 1;\n    \n    return possibleValues;\n  }\n\n  /**\n   * Calculate complexity for template rules\n   */\n  private calculateTemplateRuleComplexity(\n    ruleKey: string, \n    visited: Set<string>, \n    maxDepth: number,\n    variables: Set<string>,\n    warnings: string[]\n  ): number {\n    const rule = this.ruleManager.getTemplateRuleData(ruleKey);\n    if (!rule) return 1;\n    \n    let totalComplexity = 1;\n    \n    // Find all variables in the template\n    const templateVariables = this.variableExpander.findVariables(rule.template);\n    \n    for (const variable of templateVariables) {\n      variables.add(variable);\n      \n      // Check if this variable has values defined in the template rule\n      if (rule.variables[variable]) {\n        const values = rule.variables[variable];\n        let variableComplexity = 0;\n        \n        for (const value of values) {\n          const valueVariables = this.variableExpander.findVariables(value);\n          \n          if (valueVariables.length === 0) {\n            variableComplexity += 1;\n          } else {\n            let valueComplexity = 1;\n            for (const nestedVariable of valueVariables) {\n              variables.add(nestedVariable);\n              if (visited.has(nestedVariable)) {\n                warnings.push(`Circular reference detected for rule '${nestedVariable}'`);\n                valueComplexity *= 1;\n              } else if (visited.size >= maxDepth) {\n                warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${nestedVariable}', complexity may be underestimated`);\n                valueComplexity *= 1;\n              } else if (this.ruleManager.hasRule(nestedVariable)) {\n                const varResult = this.calculateRuleComplexity(nestedVariable, visited, maxDepth);\n                if (!varResult.isFinite) {\n                  return Number.POSITIVE_INFINITY;\n                }\n                valueComplexity *= varResult.complexity;\n                warnings.push(...varResult.warnings);\n              } else {\n                warnings.push(`Missing rule '${nestedVariable}' referenced in '${ruleKey}'`);\n                valueComplexity *= 1;\n              }\n            }\n            variableComplexity += valueComplexity;\n          }\n        }\n        \n        totalComplexity *= variableComplexity;\n      } else if (this.ruleManager.hasRule(variable)) {\n        // Variable references another rule\n        if (visited.has(variable)) {\n          warnings.push(`Circular reference detected for rule '${variable}'`);\n          totalComplexity *= 1;\n        } else if (visited.size >= maxDepth) {\n          warnings.push(`Maximum depth (${maxDepth}) reached while analyzing '${variable}', complexity may be underestimated`);\n          totalComplexity *= 1;\n        } else {\n          const varResult = this.calculateRuleComplexity(variable, visited, maxDepth);\n          if (!varResult.isFinite) {\n            return Number.POSITIVE_INFINITY;\n          }\n          totalComplexity *= varResult.complexity;\n          warnings.push(...varResult.warnings);\n        }\n      } else {\n        warnings.push(`Missing rule '${variable}' referenced in '${ruleKey}'`);\n        totalComplexity *= 1;\n      }\n    }\n    \n    return totalComplexity;\n  }\n}","/**\n * Probability analysis for grammar rules\n */\nimport { \n  ProbabilityAnalysis, \n  ProbabilityResult,\n  ProbabilityNode\n} from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { VariableExpander } from '../core/VariableExpander.js';\n\nexport class ProbabilityAnalyzer {\n  constructor(\n    private ruleManager: RuleManager,\n    private variableExpander: VariableExpander\n  ) {}\n\n  /**\n   * Create a proper ProbabilityResult object\n   * @private\n   */\n  private createProbabilityResult(\n    outcome: string, \n    probability: number, \n    variables: string[] = [],\n    probabilityTree: ProbabilityResult['probabilityTree'] = []\n  ): ProbabilityResult {\n    return { outcome, probability, variables, probabilityTree };\n  }\n\n  /**\n   * Calculate probability analysis for a specific rule\n   * \n   * This method analyzes all possible outcomes of a rule and calculates the probability\n   * of each outcome occurring. It considers weighted rules, nested variables, and\n   * rule dependencies to provide accurate probability distributions.\n   * \n   * @param ruleKey - The name of the rule to analyze\n   * @param maxDepth - Maximum recursion depth to prevent stack overflow (default: 50)\n   * @param maxOutcomes - Maximum number of outcomes to calculate (default: 1000)\n   * \n   * @returns ProbabilityAnalysis with detailed probability information\n   * \n   * @throws {Error} If the rule does not exist\n   */\n  public calculateProbabilities(\n    ruleKey: string, \n    maxDepth: number = 50, \n    maxOutcomes: number = 1000\n  ): ProbabilityAnalysis {\n    if (!this.ruleManager.hasRule(ruleKey)) {\n      throw new Error(`Rule '${ruleKey}' does not exist`);\n    }\n\n    const warnings: string[] = [];\n    const outcomes = this.calculateRuleProbabilities(ruleKey, new Set(), maxDepth, maxOutcomes, warnings);\n    \n    if (outcomes.length === 0) {\n      return {\n        ruleName: ruleKey,\n        outcomes: [],\n        totalOutcomes: 0,\n        mostProbable: [],\n        leastProbable: [],\n        averageProbability: 0,\n        entropy: 0,\n        isFinite: true,\n        warnings\n      };\n    }\n\n    // Sort by probability (descending)\n    const sortedOutcomes = outcomes.sort((a, b) => b.probability - a.probability);\n    \n    // Calculate entropy: H = -(p * log2(p))\n    const entropy = outcomes.reduce((sum, outcome) => {\n      if (outcome.probability > 0) {\n        return sum - (outcome.probability * Math.log2(outcome.probability));\n      }\n      return sum;\n    }, 0);\n\n    // Get top 10 most and least probable\n    const mostProbable = sortedOutcomes.slice(0, 10);\n    const leastProbable = sortedOutcomes.slice(-10).reverse();\n    \n    // Calculate average probability\n    const averageProbability = outcomes.length > 0 \n      ? outcomes.reduce((sum, o) => sum + o.probability, 0) / outcomes.length \n      : 0;\n\n    return {\n      ruleName: ruleKey,\n      outcomes: sortedOutcomes,\n      totalOutcomes: outcomes.length,\n      mostProbable,\n      leastProbable,\n      averageProbability,\n      entropy,\n      isFinite: true,\n      warnings\n    };\n  }\n\n  /**\n   * Get the most probable outcome for a rule\n   */\n  public getMostProbableOutcome(\n    ruleKey: string, \n    maxDepth: number = 50, \n    maxOutcomes: number = 1000\n  ): ProbabilityResult | null {\n    const analysis = this.calculateProbabilities(ruleKey, maxDepth, maxOutcomes);\n    return analysis.mostProbable[0] || null;\n  }\n\n  /**\n   * Get the least probable outcome for a rule\n   */\n  public getLeastProbableOutcome(\n    ruleKey: string, \n    maxDepth: number = 50, \n    maxOutcomes: number = 1000\n  ): ProbabilityResult | null {\n    const analysis = this.calculateProbabilities(ruleKey, maxDepth, maxOutcomes);\n    return analysis.leastProbable[0] || null;\n  }\n\n  /**\n   * Calculate probabilities for a specific rule (recursive helper)\n   * @private\n   */\n  private calculateRuleProbabilities(\n    ruleKey: string,\n    visited: Set<string>,\n    maxDepth: number,\n    maxOutcomes: number,\n    warnings: string[]\n  ): ProbabilityResult[] {\n    // Check for circular references and depth limits\n    if (visited.has(ruleKey)) {\n      warnings.push(`Circular reference detected for rule '${ruleKey}'`);\n      return [this.createProbabilityResult(ruleKey, 1.0)];\n    }\n    \n    if (visited.size >= maxDepth) {\n      warnings.push(`Maximum depth (${maxDepth}) reached for rule '${ruleKey}'`);\n      return [this.createProbabilityResult(ruleKey, 1.0)];\n    }\n\n    const newVisited = new Set(visited);\n    newVisited.add(ruleKey);\n\n    const ruleType = this.ruleManager.getRuleType(ruleKey);\n    \n    switch (ruleType) {\n      case 'static':\n        return this.calculateStaticRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'weighted':\n        return this.calculateWeightedRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'range':\n        return this.calculateRangeRuleProbabilities(ruleKey);\n      case 'template':\n        return this.calculateTemplateRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'sequential':\n        return this.calculateSequentialRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'conditional':\n        return this.calculateConditionalRuleProbabilities(ruleKey, newVisited, maxDepth, maxOutcomes, warnings);\n      case 'function':\n        warnings.push(`Function rule '${ruleKey}' has dynamic outcomes - cannot calculate exact probabilities`);\n        return [this.createProbabilityResult(`[function:${ruleKey}]`, 1.0)];\n      default:\n        warnings.push(`Unknown rule type for '${ruleKey}'`);\n        return [this.createProbabilityResult(ruleKey, 1.0)];\n    }\n  }\n\n  /**\n   * Calculate probabilities for static rules\n   * @private\n   */\n  private calculateStaticRuleProbabilities(\n    ruleKey: string,\n    visited: Set<string>,\n    maxDepth: number,\n    maxOutcomes: number,\n    warnings: string[]\n  ): ProbabilityResult[] {\n    const rule = this.ruleManager.getGrammar()[ruleKey];\n    if (!rule || rule.length === 0) {\n      return [];\n    }\n\n    const outcomes: ProbabilityResult[] = [];\n    const baseProb = 1.0 / rule.length; // Equal probability for each value\n\n    for (const value of rule) {\n      const variables = this.variableExpander.findVariables(value);\n      \n      if (variables.length === 0) {\n        // Simple literal value\n        outcomes.push(this.createProbabilityResult(value, baseProb));\n      } else {\n        // Expand variables with probabilities\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          value, variables, baseProb, visited, maxDepth, maxOutcomes, warnings\n        );\n        outcomes.push(...expandedOutcomes);\n      }\n\n      if (outcomes.length >= maxOutcomes) {\n        warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n        break;\n      }\n    }\n\n    return outcomes;\n  }\n\n  // Placeholder methods for other rule types\n  private calculateWeightedRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getWeightedRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const totalWeight = rule.weights.reduce((sum: number, weight: number) => sum + weight, 0);\n    \n    for (let i = 0; i < rule.values.length; i++) {\n      const value = rule.values[i];\n      const weight = rule.weights[i];\n      const probability = weight / totalWeight;\n      \n      const variables = this.variableExpander.findVariables(value);\n      \n      if (variables.length === 0) {\n        outcomes.push(this.createProbabilityResult(value, probability));\n      } else {\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          value, variables, probability, visited, maxDepth, maxOutcomes, warnings\n        );\n        outcomes.push(...expandedOutcomes);\n      }\n      \n      if (outcomes.length >= maxOutcomes) {\n        warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n        break;\n      }\n    }\n    \n    return outcomes;\n  }\n\n  private calculateRangeRuleProbabilities(ruleKey: string): ProbabilityResult[] {\n    const rule = this.ruleManager.getRangeRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const step = rule.step || 1;\n    const possibleValues = Math.floor((rule.max - rule.min) / step) + 1;\n    const probability = 1.0 / possibleValues;\n    \n    for (let value = rule.min; value <= rule.max; value += step) {\n      const outcome = rule.type === 'integer' ? value.toString() : value.toFixed(2);\n      outcomes.push(this.createProbabilityResult(outcome, probability));\n    }\n    \n    return outcomes;\n  }\n\n  private calculateTemplateRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getTemplateRuleData(ruleKey);\n    if (!rule) return [];\n    \n    // Start with the template\n    let currentOutcomes = [{ value: rule.template, probability: 1.0 }];\n    \n    // Expand each variable in the template\n    for (const [varName, values] of Object.entries(rule.variables) as [string, string[]][]) {\n      const newOutcomes: { value: string; probability: number }[] = [];\n      const valueProbability = 1.0 / values.length;\n      \n      for (const currentOutcome of currentOutcomes) {\n        for (const value of values) {\n          // Replace the variable in the template\n          const expandedValue = currentOutcome.value.replace(\n            new RegExp(`%${varName}%`, 'g'), \n            value\n          );\n          \n          // Check if this value has nested variables\n          const nestedVariables = this.variableExpander.findVariables(value);\n          if (nestedVariables.length > 0) {\n            // Recursively expand nested variables\n            const nestedOutcomes = this.expandVariablesWithProbabilities(\n              expandedValue, nestedVariables, currentOutcome.probability * valueProbability,\n              visited, maxDepth, maxOutcomes, warnings\n            );\n            for (const nestedOutcome of nestedOutcomes) {\n              newOutcomes.push({\n                value: nestedOutcome.outcome,\n                probability: nestedOutcome.probability\n              });\n            }\n          } else {\n            newOutcomes.push({\n              value: expandedValue,\n              probability: currentOutcome.probability * valueProbability\n            });\n          }\n          \n          if (newOutcomes.length >= maxOutcomes) {\n            warnings.push(`Maximum outcomes (${maxOutcomes}) reached for template rule '${ruleKey}'`);\n            break;\n          }\n        }\n        if (newOutcomes.length >= maxOutcomes) break;\n      }\n      \n      currentOutcomes = newOutcomes;\n      if (currentOutcomes.length >= maxOutcomes) break;\n    }\n    \n    // Handle any remaining variables that aren't in the local variables object\n    const remainingVariables = this.variableExpander.findVariables(currentOutcomes[0]?.value || '');\n    if (remainingVariables.length > 0) {\n      const finalOutcomes: { value: string; probability: number }[] = [];\n      \n      for (const outcome of currentOutcomes) {\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          outcome.value, remainingVariables, outcome.probability,\n          visited, maxDepth, maxOutcomes, warnings\n        );\n        for (const expanded of expandedOutcomes) {\n          finalOutcomes.push({\n            value: expanded.outcome,\n            probability: expanded.probability\n          });\n        }\n        \n        if (finalOutcomes.length >= maxOutcomes) break;\n      }\n      \n      currentOutcomes = finalOutcomes;\n    }\n    \n    // Convert to ProbabilityResult format\n    return currentOutcomes.map(outcome => \n      this.createProbabilityResult(outcome.value, outcome.probability)\n    );\n  }\n\n  private calculateSequentialRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getSequentialRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const baseProb = 1.0 / rule.values.length;\n    \n    for (const value of rule.values) {\n      const variables = this.variableExpander.findVariables(value);\n      \n      if (variables.length === 0) {\n        outcomes.push(this.createProbabilityResult(value, baseProb));\n      } else {\n        const expandedOutcomes = this.expandVariablesWithProbabilities(\n          value, variables, baseProb, visited, maxDepth, maxOutcomes, warnings\n        );\n        outcomes.push(...expandedOutcomes);\n      }\n      \n      if (outcomes.length >= maxOutcomes) {\n        warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n        break;\n      }\n    }\n    \n    return outcomes;\n  }\n\n  private calculateConditionalRuleProbabilities(ruleKey: string, visited: Set<string>, maxDepth: number, maxOutcomes: number, warnings: string[]): ProbabilityResult[] {\n    const rule = this.ruleManager.getConditionalRuleData(ruleKey);\n    if (!rule) return [];\n    \n    const outcomes: ProbabilityResult[] = [];\n    const conditionProbability = 1.0 / rule.conditions.length; // Equal probability for each condition\n    \n    for (const condition of rule.conditions) {\n      const values = condition.then || condition.default || [];\n      const valueProbability = conditionProbability / values.length;\n      \n      for (const value of values) {\n        const variables = this.variableExpander.findVariables(value);\n        \n        if (variables.length === 0) {\n          outcomes.push(this.createProbabilityResult(value, valueProbability));\n        } else {\n          const expandedOutcomes = this.expandVariablesWithProbabilities(\n            value, variables, valueProbability, visited, maxDepth, maxOutcomes, warnings\n          );\n          outcomes.push(...expandedOutcomes);\n        }\n        \n        if (outcomes.length >= maxOutcomes) {\n          warnings.push(`Maximum outcomes (${maxOutcomes}) reached for rule '${ruleKey}'`);\n          break;\n        }\n      }\n      \n      if (outcomes.length >= maxOutcomes) break;\n    }\n    \n    return outcomes;\n  }\n\n  /**\n   * Expand variables in a value with probability calculations\n   * @private\n   */\n  private expandVariablesWithProbabilities(\n    value: string,\n    variables: string[],\n    baseProbability: number,\n    visited: Set<string>,\n    maxDepth: number,\n    maxOutcomes: number,\n    warnings: string[]\n  ): ProbabilityResult[] {\n    if (variables.length === 0) {\n      return [this.createProbabilityResult(value, baseProbability)];\n    }\n    \n    // Start with the original value and expand one variable at a time\n    let currentOutcomes: Array<{ \n      value: string; \n      probability: number; \n      probabilityTree?: ProbabilityNode[] \n    }> = [{ value, probability: baseProbability }];\n    \n    for (const variable of variables) {\n      const newOutcomes: Array<{ \n        value: string; \n        probability: number; \n        probabilityTree?: ProbabilityNode[] \n      }> = [];\n      \n      // Handle special cases\n      if (visited.has(variable)) {\n        warnings.push(`Circular reference detected for rule '${variable}'`);\n        // Replace with circular marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[circular:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      if (visited.size >= maxDepth) {\n        warnings.push(`Maximum depth (${maxDepth}) reached for rule '${variable}'`);\n        // Replace with max-depth marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[max-depth:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      if (!this.ruleManager.hasRule(variable)) {\n        warnings.push(`Missing rule '${variable}' referenced in expansion`);\n        // Replace with missing marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[missing:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      // Get probabilities for this variable\n      const ruleType = this.ruleManager.getRuleType(variable);\n      if (ruleType === 'function') {\n        warnings.push(`Function rule '${variable}' has dynamic outcomes - cannot calculate exact probabilities`);\n        // Replace with function marker\n        for (const outcome of currentOutcomes) {\n          newOutcomes.push({\n            value: outcome.value.replace(new RegExp(`%${variable}%`, 'g'), `[function:${variable}]`),\n            probability: outcome.probability\n          });\n        }\n        currentOutcomes = newOutcomes;\n        continue;\n      }\n      \n      // Recursively get probabilities for this variable\n      const variableProbabilities = this.calculateRuleProbabilities(\n        variable, new Set(visited), maxDepth, maxOutcomes, warnings\n      );\n      \n      // Expand each current outcome with each variable possibility\n      for (const currentOutcome of currentOutcomes) {\n        for (const varOutcome of variableProbabilities) {\n          const expandedValue = currentOutcome.value.replace(\n            new RegExp(`%${variable}%`, 'g'), \n            varOutcome.outcome\n          );\n          const combinedProbability = currentOutcome.probability * varOutcome.probability;\n          \n          // Create probability tree node for this variable expansion\n          const probabilityNode = {\n            ruleName: variable,\n            value: varOutcome.outcome,\n            probability: varOutcome.probability,\n            children: varOutcome.probabilityTree || []\n          };\n          \n          newOutcomes.push({\n            value: expandedValue,\n            probability: combinedProbability,\n            probabilityTree: [probabilityNode]\n          });\n          \n          if (newOutcomes.length >= maxOutcomes) {\n            warnings.push(`Maximum outcomes (${maxOutcomes}) reached during expansion`);\n            break;\n          }\n        }\n        if (newOutcomes.length >= maxOutcomes) break;\n      }\n      \n      currentOutcomes = newOutcomes;\n      if (currentOutcomes.length >= maxOutcomes) break;\n    }\n    \n    // Convert to ProbabilityResult format\n    return currentOutcomes.map(outcome => \n      this.createProbabilityResult(\n        outcome.value, \n        outcome.probability, \n        variables,\n        outcome.probabilityTree || []\n      )\n    );\n  }\n}","/**\n * Error handling and helpful error message generation\n */\nimport { ErrorContext } from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { GrammarValidator } from '../validation/GrammarValidator.js';\n\nexport class ErrorHandler {\n  constructor(\n    private ruleManager: RuleManager,\n    private validator: GrammarValidator\n  ) {}\n\n  /**\n   * Generate helpful error messages with contextual suggestions and debugging information\n   * \n   * This method analyzes parsing errors and provides intelligent suggestions for resolving\n   * common issues. It examines the error type, parsing context, and grammar state to offer\n   * specific, actionable advice for fixing problems.\n   * \n   * @param error - The error object that was thrown during parsing\n   * @param context - Optional additional context for better error analysis\n   * @returns Enhanced error message with suggestions, validation info, and debugging tips\n   */\n  public getHelpfulError(error: Error, context?: ErrorContext): string {\n    const lines: string[] = [];\n    \n    // Start with the original error message\n    lines.push(error.message);\n    lines.push('');\n    \n    // Analyze error type and provide specific suggestions\n    if (this.isRecursionError(error)) {\n      lines.push('Suggestions:');\n      lines.push(' Check for circular references in your grammar rules');\n      lines.push(' Use validate() method to detect circular dependencies');\n      lines.push(' Consider increasing maxDepth if your grammar is legitimately deep');\n      lines.push(' Try reducing the maxDepth with setMaxDepth()');\n      lines.push(' Use @variable syntax to reference previously generated values');\n      \n      // Add rule-specific context if available\n      if (context?.ruleName) {\n        lines.push('');\n        lines.push(`Rule name: ${context.ruleName}`);\n        lines.push(`The rule '${context.ruleName}' may be causing infinite recursion`);\n      }\n    } else if (this.isFunctionRuleError(error)) {\n      lines.push('Suggestions:');\n      lines.push(' Function rules must return string arrays');\n      lines.push(' Check that your function rule returns an array of strings');\n      lines.push(' Check your function rule implementation');\n      lines.push(' Ensure function doesn\\'t throw exceptions');\n      lines.push(' Add error handling within your function rule');\n      lines.push(' Test function rule independently before adding to parser');\n    } else if (this.isWeightError(error)) {\n      lines.push('Suggestions:');\n      lines.push(' Ensure all weights are positive numbers');\n      lines.push(' Verify that weights sum to exactly 1.0');\n      lines.push(' Ensure all weights in weighted rules add up to exactly 1.0');\n      lines.push(' Check that values and weights arrays have the same length');\n      lines.push(' Use helper: weights = [0.5, 0.3, 0.2] for three items');\n    } else if (this.isMissingRuleError(error)) {\n      lines.push('Suggestions:');\n      lines.push(' Check that all referenced rules are defined');\n      lines.push(' Use validate() method to find missing rules');\n      \n      // Try to identify missing rules\n      if (context?.text) {\n        const missingRules = this.validator.validateText(context.text);\n        if (missingRules.length > 0) {\n          lines.push(` Missing rules detected: ${missingRules.join(', ')}`);\n        }\n      }\n    } else {\n      // General suggestions for unknown errors\n      lines.push('Suggestions:');\n      lines.push(' Run validate() method to check for grammar issues');\n      lines.push(' Check that all referenced rules exist');\n      lines.push(' Ensure rule values are properly formatted');\n      lines.push(' Review recent changes to grammar rules');\n    }\n    \n    lines.push('');\n    \n    // Add validation information if available\n    const validation = this.validator.validate();\n    if (!validation.isValid) {\n      lines.push('Validation Issues:');\n      \n      if (validation.missingRules.length > 0) {\n        lines.push(` Missing rules: ${validation.missingRules.join(', ')}`);\n      }\n      \n      if (validation.circularReferences.length > 0) {\n        lines.push(` Circular references: ${validation.circularReferences.join(', ')}`);\n      }\n      \n      if (validation.emptyRules.length > 0) {\n        lines.push(` Empty rules: ${validation.emptyRules.join(', ')}`);\n      }\n      \n      lines.push('');\n    }\n    \n    // Add context information if provided\n    if (context) {\n      if (context.text) {\n        lines.push(`Text being parsed: \"${context.text}\"`);\n      }\n      \n      if (context.ruleName) {\n        lines.push(`Rule name: ${context.ruleName}`);\n        const ruleType = this.ruleManager.getRuleType(context.ruleName);\n        if (ruleType) {\n          lines.push(`Rule type: ${ruleType}`);\n        }\n      }\n    }\n    \n    return lines.join('\\n');\n  }\n\n  /**\n   * Check if error is related to recursion depth\n   * @private\n   */\n  private isRecursionError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('recursion') || \n           message.includes('circular') || \n           message.includes('depth') ||\n           message.includes('maximum call stack');\n  }\n\n  /**\n   * Check if error is related to function rules\n   * @private\n   */\n  private isFunctionRuleError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('function rule') || \n           message.includes('function') && message.includes('failed') ||\n           message.includes('function must return');\n  }\n\n  /**\n   * Check if error is related to weighted rule weights\n   * @private\n   */\n  private isWeightError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('weight') || \n           message.includes('sum to 1') ||\n           message.includes('probability');\n  }\n\n  /**\n   * Check if error is related to missing rules\n   * @private\n   */\n  private isMissingRuleError(error: Error): boolean {\n    const message = error.message.toLowerCase();\n    return message.includes('rule') && message.includes('not found') ||\n           message.includes('rule') && message.includes('does not exist') ||\n           message.includes('missing rule') ||\n           message.includes('undefined rule');\n  }\n\n  /**\n   * Create a standardized error for missing rules\n   */\n  public createMissingRuleError(ruleName: string): Error {\n    return new Error(`Rule '${ruleName}' does not exist. Use addRule() to define it first.`);\n  }\n\n  /**\n   * Create a standardized error for circular references\n   */\n  public createCircularReferenceError(ruleName: string): Error {\n    return new Error(`Circular reference detected in rule '${ruleName}'. This creates infinite recursion.`);\n  }\n\n  /**\n   * Create a standardized error for function rule failures\n   */\n  public createFunctionRuleError(ruleName: string, originalError: Error): Error {\n    return new Error(`Function rule '${ruleName}' failed: ${originalError.message}`);\n  }\n\n  /**\n   * Create a standardized error for weight validation\n   */\n  public createWeightValidationError(message: string): Error {\n    return new Error(`Weight validation failed: ${message}`);\n  }\n\n  /**\n   * Create a standardized error for recursion depth\n   */\n  public createRecursionDepthError(maxDepth: number): Error {\n    return new Error(`Maximum recursion depth of ${maxDepth} exceeded. This may indicate circular references in your grammar rules.`);\n  }\n}","/**\n * Variable expansion engine for processing %variable% placeholders\n */\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\n\nexport class VariableExpander {\n  private variablePattern = /%([^%]+)%/g;\n  private referenceValues: Map<string, string> = new Map();\n  private currentContext: { [key: string]: string } = {};\n  private maxDepth: number = 100;\n\n  constructor(\n    private ruleManager: RuleManager,\n    private random: SeededRandom\n  ) {}\n\n  /**\n   * Set maximum recursion depth\n   */\n  public setMaxDepth(depth: number): void {\n    if (typeof depth !== 'number' || depth < 1) {\n      throw new Error('Max depth must be at least 1');\n    }\n    this.maxDepth = depth;\n  }\n\n  /**\n   * Get maximum recursion depth\n   */\n  public getMaxDepth(): number {\n    return this.maxDepth;\n  }\n\n  /**\n   * Clear context and reference values\n   */\n  public clearContext(): void {\n    this.currentContext = {};\n    this.referenceValues.clear();\n  }\n\n  /**\n   * Get current context\n   */\n  public getContext(): { [key: string]: string } {\n    return { ...this.currentContext };\n  }\n\n  /**\n   * Clear reference values and context\n   */\n  public clearReferences(): void {\n    this.referenceValues.clear();\n    this.currentContext = {};\n  }\n\n  /**\n   * Expand variables in text with recursive processing\n   * @param text - Text containing %variable% placeholders\n   * @param preserveContext - Whether to maintain context from previous expansions\n   * @returns Fully expanded text\n   */\n  public expandVariables(text: string, preserveContext: boolean = false): string {\n    if (!preserveContext) {\n      this.clearContext();\n    }\n    \n    return this.expandVariablesRecursive(text, 0);\n  }\n\n  /**\n   * Recursively expand variables with depth protection\n   * @private\n   */\n  private expandVariablesRecursive(text: string, depth: number): string {\n    if (depth >= this.maxDepth) {\n      throw new Error(`Maximum recursion depth of ${this.maxDepth} exceeded. This may indicate circular references in your grammar rules.`);\n    }\n\n    // Reset the regex lastIndex to ensure proper matching\n    this.variablePattern.lastIndex = 0;\n\n    return text.replace(this.variablePattern, (match, key) => {\n      // Handle reference variables (@variable syntax)\n      if (key.startsWith('@')) {\n        const refKey = key.substring(1);\n        const refValue = this.referenceValues.get(refKey);\n        if (refValue !== undefined) {\n          return refValue;\n        }\n        // If reference doesn't exist, fall through to generate new value\n        key = refKey;\n      }\n\n      // Try to generate value from rule manager\n      const value = this.ruleManager.generateValue(key, this.currentContext, this.random);\n      \n      if (value === null) {\n        // Rule not found - return original placeholder\n        return match;\n      }\n\n      // Store in context and references\n      this.currentContext[key] = value;\n      this.referenceValues.set(key, value);\n\n      // Recursively expand the generated value\n      return this.expandVariablesRecursive(value, depth + 1);\n    });\n  }\n\n  /**\n   * Find all variable names in text\n   * @param text - Text to analyze\n   * @returns Array of unique variable names\n   */\n  public findVariables(text: string): string[] {\n    const variables = new Set<string>();\n    const regex = new RegExp(this.variablePattern.source, 'g');\n    let match;\n    \n    while ((match = regex.exec(text)) !== null) {\n      variables.add(match[1]);\n    }\n    \n    return Array.from(variables);\n  }\n\n  /**\n   * Validate that all variables in text have corresponding rules\n   * @param text - Text to validate\n   * @returns Array of missing variable names\n   */\n  public findMissingVariables(text: string): string[] {\n    const variables = this.findVariables(text);\n    const missing: string[] = [];\n    \n    for (const variable of variables) {\n      // Skip reference variables\n      if (variable.startsWith('@')) {\n        continue;\n      }\n      \n      if (!this.ruleManager.hasRule(variable)) {\n        missing.push(variable);\n      }\n    }\n    \n    return missing;\n  }\n\n  /**\n   * Check for circular references in grammar rules\n   * @param startRule - Rule to start checking from\n   * @param visited - Set of already visited rules\n   * @returns Array of circular reference chains found\n   */\n  public findCircularReferences(startRule?: string, visited: Set<string> = new Set()): string[] {\n    const circular: string[] = [];\n    \n    if (startRule) {\n      this.checkRuleForCircularReferences(startRule, visited, circular);\n    } else {\n      // Check all rules\n      const allKeys = this.ruleManager.getAllKeys();\n      for (const key of allKeys) {\n        this.checkRuleForCircularReferences(key, new Set(), circular);\n      }\n    }\n    \n    return circular;\n  }\n\n  /**\n   * Check a specific rule for circular references\n   * @private\n   */\n  private checkRuleForCircularReferences(\n    ruleName: string, \n    visited: Set<string>, \n    circular: string[]\n  ): void {\n    if (visited.has(ruleName)) {\n      circular.push(ruleName);\n      return;\n    }\n    \n    visited.add(ruleName);\n    \n    // Get a sample value from the rule to check its variables  \n    const sampleValue = this.ruleManager.generateValue(ruleName, {}, this.random);\n    if (sampleValue) {\n      const variables = this.findVariables(sampleValue);\n      for (const variable of variables) {\n        if (!variable.startsWith('@') && this.ruleManager.hasRule(variable)) {\n          this.checkRuleForCircularReferences(variable, new Set(visited), circular);\n        }\n      }\n    }\n    \n    visited.delete(ruleName);\n  }\n}","/**\n * Story Grammar - A combinatorial grammar for narrative-based projects\n */\n\n// Core Parser and all types\nexport { Parser } from './Parser.js';\n\n// Export all types and interfaces\nexport * from './types.js';\n\n// New Modifiers namespace\nexport * as Modifiers from './modifiers/index.js';\n\n// English modifiers (backward compatibility) - use comprehensive implementation\nexport {\n  EnglishArticleModifier,\n  EnglishPluralizationModifier,\n  EnglishOrdinalModifier,\n  EnglishCapitalizationModifier,\n  EnglishPossessiveModifier,\n  EnglishVerbAgreementModifier,\n  PunctuationCleanupModifier,\n  AllEnglishModifiers,\n  BasicEnglishModifiers\n} from './EnglishModifiers.js';\n\n// Re-export for backward compatibility\nexport { Parser as StoryGrammar } from './Parser.js';","/**\n * English article modifier (a/an correction)\n * Converts \"a\" to \"an\" before vowel sounds\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const ArticleModifier: Modifier = {\n  name: 'englishArticles',\n  condition: (text: string) => {\n    return /\\ba\\s+[aeiouAEIOU]/.test(text);\n  },\n  transform: (text: string) => {\n    // More precise regex to handle vowel sounds at word boundaries\n    return text.replace(/\\ba(\\s+)([aeiouAEIOU][a-z]*)/gi, 'an$1$2');\n  },\n  priority: 10\n};","/**\n * English capitalization modifier\n * Capitalizes words after sentence-ending punctuation\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const CapitalizationModifier: Modifier = {\n  name: 'englishCapitalization',\n  condition: (text: string) => {\n    // Look for lowercase letters after sentence endings\n    return /[.!?]\\s+[a-z]/.test(text);\n  },\n  transform: (text: string) => {\n    // Capitalize first letter of sentences\n    return text.replace(/([.!?]\\s+)([a-z])/g, (match, punctuation, letter) => {\n      return punctuation + letter.toUpperCase();\n    });\n  },\n  priority: 7\n};","/**\n * English ordinal modifier\n * Converts cardinal numbers to ordinal format (1 -> 1st, 2 -> 2nd, etc.)\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const OrdinalModifier: Modifier = {\n  name: 'englishOrdinals',\n  condition: (text: string) => {\n    // Look for standalone numbers (digits)\n    return /\\b\\d+\\b/.test(text);\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(\\d+)\\b/g, (match, num) => {\n      const number = parseInt(num, 10);\n      \n      // Get the last digit and last two digits\n      const lastDigit = number % 10;\n      const lastTwoDigits = number % 100;\n      \n      // Exception: numbers ending in 11, 12, 13 use 'th'\n      if (lastTwoDigits === 11 || lastTwoDigits === 12 || lastTwoDigits === 13) {\n        return num + 'th';\n      }\n      \n      // Apply ordinal rules based on last digit\n      switch (lastDigit) {\n        case 1:\n          return num + 'st';\n        case 2:\n          return num + 'nd';\n        case 3:\n          return num + 'rd';\n        default:\n          return num + 'th';\n      }\n    });\n  },\n  priority: 8\n};","/**\n * English pluralization modifier\n * Handles comprehensive pluralization patterns including irregular forms\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const PluralizationModifier: Modifier = {\n  name: 'englishPluralization',\n  condition: (text: string) => {\n    // Look for plural indicators: numbers > 1, \"many\", \"several\", \"multiple\", etc.\n    return /\\b(many|several|multiple|some|few|all|both|various|numerous|[2-9]\\d*|\\d*[02-9])\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(zero|no)\\s+[a-zA-Z]+/i.test(text); // Zero/no also takes plural\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(many|several|multiple|some|few|all|both|various|numerous|zero|no|[2-9]\\d*|\\d*[02-9]|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+([a-zA-Z]+)\\b/gi, \n      (match, quantifier, noun) => {\n        const pluralNoun = pluralize(noun);\n        return `${quantifier} ${pluralNoun}`;\n      }\n    );\n  },\n  priority: 4\n};\n\n/**\n * Convert a singular noun to its plural form\n * @param noun - The singular noun to pluralize\n * @returns The plural form of the noun\n */\nfunction pluralize(noun: string): string {\n  const lowerNoun = noun.toLowerCase();\n  \n  // Irregular plurals mapping\n  const irregularPlurals: { [key: string]: string } = {\n    'addendum': 'addenda',\n    'aircraft': 'aircraft',\n    'alumna': 'alumnae',\n    'alumnus': 'alumni',\n    'analysis': 'analyses',\n    'antenna': 'antennae',\n    'antithesis': 'antitheses',\n    'apex': 'apices',\n    'appendix': 'appendices',\n    'axis': 'axes',\n    'bacillus': 'bacilli',\n    'bacterium': 'bacteria',\n    'basis': 'bases',\n    'beau': 'beaux',\n    'bison': 'bison',\n    'bureau': 'bureaux',\n    'cactus': 'cacti',\n    'chteau': 'chteaux',\n    'child': 'children',\n    'codex': 'codices',\n    'concerto': 'concerti',\n    'corpus': 'corpora',\n    'crisis': 'crises',\n    'criterion': 'criteria',\n    'curriculum': 'curricula',\n    'datum': 'data',\n    'deer': 'deer',\n    'diagnosis': 'diagnoses',\n    'die': 'dice',\n    'dwarf': 'dwarves',\n    'ellipsis': 'ellipses',\n    'erratum': 'errata',\n    'fez': 'fezzes',\n    'fish': 'fish',\n    'focus': 'foci',\n    'foot': 'feet',\n    'formula': 'formulae',\n    'fungus': 'fungi',\n    'genus': 'genera',\n    'goose': 'geese',\n    'graffito': 'graffiti',\n    'grouse': 'grouse',\n    'half': 'halves',\n    'hoof': 'hooves',\n    'hypothesis': 'hypotheses',\n    'index': 'indices',\n    'larva': 'larvae',\n    'libretto': 'libretti',\n    'loaf': 'loaves',\n    'locus': 'loci',\n    'louse': 'lice',\n    'man': 'men',\n    'matrix': 'matrices',\n    'medium': 'media',\n    'memorandum': 'memoranda',\n    'minutia': 'minutiae',\n    'moose': 'moose',\n    'mouse': 'mice',\n    'nebula': 'nebulae',\n    'nucleus': 'nuclei',\n    'oasis': 'oases',\n    'offspring': 'offspring',\n    'opus': 'opera',\n    'ovum': 'ova',\n    'ox': 'oxen',\n    'parenthesis': 'parentheses',\n    'person': 'people',\n    'phenomenon': 'phenomena',\n    'phylum': 'phyla',\n    'quiz': 'quizzes',\n    'radius': 'radii',\n    'referendum': 'referenda',\n    'salmon': 'salmon',\n    'scarf': 'scarves',\n    'self': 'selves',\n    'series': 'series',\n    'sheep': 'sheep',\n    'shrimp': 'shrimp',\n    'species': 'species',\n    'stimulus': 'stimuli',\n    'stratum': 'strata',\n    'swine': 'swine',\n    'syllabus': 'syllabi',\n    'symposium': 'symposia',\n    'synopsis': 'synopses',\n    'tableau': 'tableaux',\n    'thesis': 'theses',\n    'thief': 'thieves',\n    'tooth': 'teeth',\n    'trout': 'trout',\n    'tuna': 'tuna',\n    'vertebra': 'vertebrae',\n    'vertex': 'vertices',\n    'vita': 'vitae',\n    'vortex': 'vortices',\n    'wharf': 'wharves',\n    'wife': 'wives',\n    'wolf': 'wolves',\n    'woman': 'women'\n  };\n  \n  // Check for irregular plurals first\n  if (irregularPlurals[lowerNoun]) {\n    const irregularPlural = irregularPlurals[lowerNoun];\n    // Preserve original case pattern\n    return preserveCase(noun, irregularPlural);\n  }\n  \n  // Apply regular pluralization rules in order of specificity\n  \n  // 1. Words ending in -s, -ss, -sh, -ch, -x, -z: add -es\n  if (/[sxz]$/.test(lowerNoun) || /[sc]h$/.test(lowerNoun)) {\n    return noun + 'es';\n  }\n  \n  // 2. Words ending in consonant + y: change y to ies\n  if (/[bcdfghjklmnpqrstvwxz]y$/i.test(lowerNoun)) {\n    return noun.slice(0, -1) + 'ies';\n  }\n  \n  // 3. Words ending in vowel + y: just add -s\n  if (/[aeiou]y$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 4. Words ending in -f or -fe: change to -ves (with exceptions)\n  if (/fe?$/i.test(lowerNoun)) {\n    // Exceptions that just add -s\n    const fExceptions = ['belief', 'chief', 'cliff', 'proof', 'roof', 'safe', 'chef', 'handkerchief'];\n    if (fExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun.replace(/fe?$/i, 'ves');\n  }\n  \n  // 5. Words ending in consonant + o: add -es (with common exceptions)\n  if (/[bcdfghjklmnpqrstvwxz]o$/i.test(lowerNoun)) {\n    // Common exceptions that just add -s\n    const oExceptions = [\n      'photo', 'piano', 'halo', 'disco', 'studio', 'radio', 'video', \n      'auto', 'memo', 'pro', 'casino', 'patio', 'portfolio', 'logo',\n      'commando', 'solo', 'soprano', 'alto', 'kimono'\n    ];\n    if (oExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun + 'es';\n  }\n  \n  // 6. Words ending in vowel + o: just add -s\n  if (/[aeiou]o$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 7. Default case: add -s\n  return noun + 's';\n}\n\n/**\n * Preserve the case pattern of the original word in the plural form\n * @param original - The original word with its case pattern\n * @param plural - The lowercase plural form\n * @returns The plural with preserved case pattern\n */\nfunction preserveCase(original: string, plural: string): string {\n  // If original is all uppercase, make plural all uppercase\n  if (original === original.toUpperCase()) {\n    return plural.toUpperCase();\n  }\n  \n  // If original starts with uppercase, capitalize the plural\n  if (original[0] === original[0].toUpperCase()) {\n    return plural.charAt(0).toUpperCase() + plural.slice(1);\n  }\n  \n  // Otherwise, return lowercase plural\n  return plural;\n}","/**\n * English possessive modifier\n * Adds possessive apostrophes to words ending with \"POSSESSIVE\"\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const PossessiveModifier: Modifier = {\n  name: 'englishPossessive',\n  condition: (text: string) => text.includes('POSSESSIVE'),\n  transform: (text: string) => {\n    return text.replace(/(\\w+)POSSESSIVE/g, (match, word) => {\n      if (word.endsWith('s')) {\n        return word + \"'\";\n      } else {\n        return word + \"'s\";\n      }\n    });\n  },\n  priority: 6\n};","/**\n * English punctuation cleanup modifier\n * Cleans up spacing around punctuation marks\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const PunctuationCleanupModifier: Modifier = {\n  name: 'englishPunctuationCleanup',\n  condition: (text: string) => {\n    // Look for spacing issues around punctuation\n    return /\\s+[,.!?;:]|\\s{2,}/.test(text);\n  },\n  transform: (text: string) => {\n    // Fix spacing before punctuation\n    text = text.replace(/\\s+([,.!?;:])/g, '$1');\n    \n    // Fix multiple spaces\n    text = text.replace(/\\s{2,}/g, ' ');\n    \n    // Ensure space after sentence-ending punctuation\n    text = text.replace(/([.!?])([A-Z])/g, '$1 $2');\n    \n    return text;\n  },\n  priority: 9\n};","/**\n * English verb agreement modifier\n * Handles subject-verb agreement for \"is/are\" constructions\n */\n\nimport { Modifier } from '../../types.js';\n\nexport const VerbAgreementModifier: Modifier = {\n  name: 'englishVerbAgreement',\n  condition: (text: string) => {\n    // Look for patterns that need verb agreement\n    return /\\b(he|she|it|\\w+(?:ing|ed))\\s+are\\b/i.test(text) ||\n           /\\b(they|we|you|\\w+s)\\s+is\\b/i.test(text);\n  },\n  transform: (text: string) => {\n    // Fix singular subjects with \"are\"\n    text = text.replace(/\\b(he|she|it)\\s+are\\b/gi, '$1 is');\n    \n    // Fix plural subjects with \"is\" (basic heuristic)\n    text = text.replace(/\\b(they|we|you)\\s+is\\b/gi, '$1 are');\n    \n    return text;\n  },\n  priority: 5\n};","/**\n * English Modifiers Namespace\n * Collection of text modifiers for English language processing\n */\n\nexport { ArticleModifier } from './ArticleModifier.js';\nexport { PluralizationModifier } from './PluralizationModifier.js';\nexport { OrdinalModifier } from './OrdinalModifier.js';\nexport { CapitalizationModifier } from './CapitalizationModifier.js';\nexport { PossessiveModifier } from './PossessiveModifier.js';\nexport { VerbAgreementModifier } from './VerbAgreementModifier.js';\nexport { PunctuationCleanupModifier } from './PunctuationCleanupModifier.js';\n\n// Convenience export of all English modifiers as an array\nimport { ArticleModifier } from './ArticleModifier.js';\nimport { PluralizationModifier } from './PluralizationModifier.js';\nimport { OrdinalModifier } from './OrdinalModifier.js';\nimport { CapitalizationModifier } from './CapitalizationModifier.js';\nimport { PossessiveModifier } from './PossessiveModifier.js';\nimport { VerbAgreementModifier } from './VerbAgreementModifier.js';\nimport { PunctuationCleanupModifier } from './PunctuationCleanupModifier.js';\n\nexport const AllEnglishModifiers = [\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier,\n  CapitalizationModifier,\n  PossessiveModifier,\n  VerbAgreementModifier,\n  PunctuationCleanupModifier\n];\n\nexport const BasicEnglishModifiers = [\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier\n];","/**\n * Modifiers Namespace\n * Organized collection of text modifiers by language\n */\n\n// English modifiers namespace\nexport * as English from './english/index.js';\n\n// Re-export individual English modifiers for convenience\nexport {\n  ArticleModifier,\n  PluralizationModifier,\n  OrdinalModifier,\n  CapitalizationModifier,\n  PossessiveModifier,\n  VerbAgreementModifier,\n  PunctuationCleanupModifier,\n  AllEnglishModifiers\n} from './english/index.js';","/**\n * Advanced rule managers for conditional, sequential, range, and template rules\n */\nimport { \n  ConditionalRule, \n  SequentialRule, \n  RangeRule, \n  TemplateRule \n} from '../types.js';\nimport { BaseRuleManager } from './BaseRuleManager.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\n\n/**\n * Manager for conditional rules that select values based on context\n */\nexport class ConditionalRuleManager extends BaseRuleManager<ConditionalRule> {\n  /**\n   * Add a conditional rule\n   * @param key - Rule identifier\n   * @param rule - Conditional rule configuration\n   */\n  public addRule(key: string, rule: ConditionalRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (!rule || !Array.isArray(rule.conditions)) {\n      throw new Error('Conditional rule must have a conditions array');\n    }\n    if (rule.conditions.length === 0) {\n      throw new Error('Conditions array cannot be empty');\n    }\n\n    // Validate conditions\n    let hasDefault = false;\n    for (const condition of rule.conditions) {\n      if ('default' in condition) {\n        if (hasDefault) {\n          throw new Error('Only one default condition is allowed');\n        }\n        hasDefault = true;\n        if (!Array.isArray(condition.default) || condition.default.length === 0) {\n          throw new Error('Default condition must have an array of values');\n        }\n      } else if ('if' in condition && 'then' in condition) {\n        if (typeof condition.if !== 'function') {\n          throw new Error('Condition \"if\" must be a function');\n        }\n        if (!Array.isArray(condition.then) || condition.then.length === 0) {\n          throw new Error('Condition \"then\" must be an array of values');\n        }\n      } else {\n        throw new Error('Each condition must have either \"if/then\" or \"default\"');\n      }\n    }\n\n    this.rules.set(key, {\n      conditions: rule.conditions.map(c => ({ ...c }))\n    });\n  }\n\n  /**\n   * Generate a value from a conditional rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context\n   * @param random - Random number generator\n   * @returns Context-appropriate value or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    for (const condition of rule.conditions) {\n      if ('default' in condition && condition.default) {\n        return random.randomChoice(condition.default);\n      } else if (condition.if && condition.if(context)) {\n        return random.randomChoice(condition.then);\n      }\n    }\n    \n    throw new Error('No matching condition found and no default provided');\n  }\n}\n\n/**\n * Manager for sequential rules that cycle through values in order\n */\nexport class SequentialRuleManager extends BaseRuleManager<SequentialRule> {\n  /**\n   * Add a sequential rule\n   * @param key - Rule identifier\n   * @param values - Array of values to cycle through\n   * @param options - Configuration options\n   */\n  public addRule(key: string, values: string[], options: { cycle: boolean } = { cycle: true }): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!Array.isArray(values) || values.length === 0) {\n      throw new Error('Values must be a non-empty array');\n    }\n\n    this.rules.set(key, {\n      values: [...values],\n      index: 0,\n      cycle: options.cycle\n    });\n  }\n\n  /**\n   * Generate a value from a sequential rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for sequential rules)\n   * @param random - Random number generator (unused for sequential rules)\n   * @returns Next value in sequence or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _context: { [key: string]: string }, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    if (rule.index >= rule.values.length) {\n      if (rule.cycle) {\n        rule.index = 0;\n      } else {\n        return rule.values[rule.values.length - 1];\n      }\n    }\n    \n    const value = rule.values[rule.index];\n    rule.index++;\n    return value;\n  }\n\n  /**\n   * Reset a sequential rule to start from the beginning\n   * @param key - Rule identifier\n   * @returns True if rule was reset, false if it doesn't exist\n   */\n  public resetRule(key: string): boolean {\n    const rule = this.rules.get(key);\n    if (rule) {\n      rule.index = 0;\n      return true;\n    }\n    return false;\n  }\n}\n\n/**\n * Manager for range rules that generate numeric values\n */\nexport class RangeRuleManager extends BaseRuleManager<RangeRule> {\n  /**\n   * Add a range rule\n   * @param key - Rule identifier\n   * @param config - Range configuration\n   */\n  public addRule(key: string, config: { min: number; max: number; step?: number; type: 'integer' | 'float' }): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (typeof config.min !== 'number' || typeof config.max !== 'number') {\n      throw new Error('Min and max must be numbers');\n    }\n    if (config.min >= config.max) {\n      throw new Error('Min must be less than max');\n    }\n    if (config.step !== undefined && (typeof config.step !== 'number' || config.step <= 0)) {\n      throw new Error('Step must be a positive number');\n    }\n    if (!['integer', 'float'].includes(config.type)) {\n      throw new Error('Type must be \"integer\" or \"float\"');\n    }\n\n    this.rules.set(key, {\n      min: config.min,\n      max: config.max,\n      step: config.step,\n      type: config.type\n    });\n  }\n\n  /**\n   * Generate a value from a range rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for range rules)\n   * @param random - Random number generator\n   * @returns Generated numeric value as string or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    _context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    const { min, max, step, type } = rule;\n    \n    if (step !== undefined) {\n      // Generate stepped values\n      const steps = Math.floor((max - min) / step);\n      const randomStep = random.randomInt(0, steps + 1);\n      const value = min + (randomStep * step);\n      return type === 'integer' ? Math.floor(value).toString() : value.toString();\n    } else {\n      // Generate continuous values\n      const randomValue = min + (random.random() * (max - min));\n      return type === 'integer' ? Math.floor(randomValue).toString() : randomValue.toString();\n    }\n  }\n}\n\n/**\n * Manager for template rules with embedded variables\n */\nexport class TemplateRuleManager extends BaseRuleManager<TemplateRule> {\n  /**\n   * Add a template rule\n   * @param key - Rule identifier\n   * @param rule - Template rule configuration\n   */\n  public addRule(key: string, rule: TemplateRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!rule.template || typeof rule.template !== 'string') {\n      throw new Error('Template must be a non-empty string');\n    }\n    if (!rule.variables || typeof rule.variables !== 'object') {\n      throw new Error('Variables must be an object');\n    }\n\n    // Validate that all variables in template exist in variables object\n    const templateVars = this.findVariables(rule.template);\n    for (const variable of templateVars) {\n      if (!(variable in rule.variables)) {\n        throw new Error(`Template variable '${variable}' not found in variables object`);\n      }\n      if (!Array.isArray(rule.variables[variable]) || rule.variables[variable].length === 0) {\n        throw new Error(`Variable '${variable}' must be an array`);\n      }\n    }\n\n    this.rules.set(key, {\n      template: rule.template,\n      variables: { ...rule.variables }\n    });\n  }\n\n  /**\n   * Generate a value from a template rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context\n   * @param random - Random number generator\n   * @returns Generated template value or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    _context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n\n    // Expand template using its own variables\n    let result = rule.template;\n    const templateVars = this.findVariables(result);\n    \n    for (const variable of templateVars) {\n      const values = rule.variables[variable];\n      if (values && values.length > 0) {\n        const value = random.randomChoice(values);\n        result = result.replace(new RegExp(`%${variable}%`, 'g'), value);\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Find all variables in a text string\n   * @param text - Text to analyze\n   * @returns Array of unique variable names\n   */\n  private findVariables(text: string): string[] {\n    const variablePattern = /%([^%]+)%/g;\n    const variables = new Set<string>();\n    let match;\n    while ((match = variablePattern.exec(text)) !== null) {\n      variables.add(match[1]);\n    }\n    return Array.from(variables);\n  }\n}","/**\n * Base class for managing different types of grammar rules\n */\nimport {\n  Grammar,\n  FunctionRule,\n  WeightedRule\n} from '../types.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\n\nexport abstract class BaseRuleManager<T> {\n  protected rules: Map<string, T> = new Map();\n\n  /**\n   * Add a rule to the manager\n   * @param key - Rule identifier\n   * @param ...args - Rule configuration arguments (varies by implementation)\n   */\n  public abstract addRule(key: string, ...args: unknown[]): void;\n\n  /**\n   * Remove a rule from the manager\n   * @param key - Rule identifier\n   * @returns True if rule was removed\n   */\n  public removeRule(key: string): boolean {\n    return this.rules.delete(key);\n  }\n\n  /**\n   * Check if a rule exists\n   * @param key - Rule identifier\n   * @returns True if rule exists\n   */\n  public hasRule(key: string): boolean {\n    return this.rules.has(key);\n  }\n\n  /**\n   * Get a rule by key\n   * @param key - Rule identifier\n   * @returns Rule or undefined\n   */\n  public getRule(key: string): T | undefined {\n    return this.rules.get(key);\n  }\n\n  /**\n   * Clear all rules\n   */\n  public clear(): void {\n    this.rules.clear();\n  }\n\n  /**\n   * Get all rule keys\n   * @returns Array of rule keys\n   */\n  public getKeys(): string[] {\n    return Array.from(this.rules.keys());\n  }\n\n  /**\n   * Get the number of rules\n   * @returns Number of rules\n   */\n  public size(): number {\n    return this.rules.size;\n  }\n\n  /**\n   * Get rule data for analysis (protected method for analyzers)\n   * @param key - Rule identifier\n   * @returns Rule data or undefined\n   */\n  public getRuleData(key: string): T | undefined {\n    return this.rules.get(key);\n  }\n\n  /**\n   * Generate a value from the rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context\n   * @param random - Random number generator\n   * @returns Generated value or null if rule doesn't exist\n   */\n  public abstract generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null;\n}\n\n/**\n * Manager for static grammar rules\n */\nexport class StaticRuleManager extends BaseRuleManager<string[]> {\n  /**\n   * Add a static rule\n   * @param key - Rule identifier\n   * @param values - Array of possible values\n   */\n  public addRule(key: string, values: string[]): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (!Array.isArray(values)) {\n      throw new Error('Rule values must be an array');\n    }\n    this.rules.set(key, [...values]); // Create a copy to avoid external mutation\n  }\n\n  /**\n   * Add multiple static rules\n   * @param grammar - Object containing key-value pairs of rules\n   */\n  public addRules(grammar: Grammar): void {\n    for (const [key, values] of Object.entries(grammar)) {\n      this.addRule(key, values);\n    }\n  }\n\n  /**\n   * Generate a value from a static rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for static rules)\n   * @param random - Random number generator\n   * @returns Random value from rule or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n    if (rule.length === 0) {\n      return '';\n    }\n    return random.randomChoice(rule);\n  }\n\n  /**\n   * Get all static rules as a Grammar object\n   * @returns Copy of all static rules\n   */\n  public getGrammar(): Grammar {\n    const grammar: Grammar = {};\n    for (const [key, values] of this.rules.entries()) {\n      grammar[key] = [...values];\n    }\n    return grammar;\n  }\n}\n\n/**\n * Manager for function-based rules\n */\nexport class FunctionRuleManager extends BaseRuleManager<FunctionRule> {\n  /**\n   * Add a function rule\n   * @param key - Rule identifier\n   * @param fn - Function that returns an array of possible values\n   */\n  public addRule(key: string, fn: FunctionRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (typeof fn !== 'function') {\n      throw new Error('Rule function must be a function');\n    }\n    this.rules.set(key, fn);\n  }\n\n  /**\n   * Generate a value from a function rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for function rules)\n   * @param random - Random number generator\n   * @returns Random value from function result or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n    \n    try {\n      const values = rule();\n      if (!Array.isArray(values)) {\n        throw new Error(`Function rule '${key}' must return an array`);\n      }\n      if (values.length === 0) {\n        return null; // This will cause the variable to remain unchanged\n      }\n      return random.randomChoice(values);\n    } catch (error) {\n      throw new Error(`Error executing function rule '${key}': ${(error as Error).message}`);\n    }\n  }\n}\n\n/**\n * Manager for weighted rules\n */\nexport class WeightedRuleManager extends BaseRuleManager<WeightedRule> {\n  /**\n   * Add a weighted rule\n   * @param key - Rule identifier\n   * @param values - Array of possible values\n   * @param weights - Array of probability weights (must sum to 1.0)\n   */\n  public addRule(key: string, values: string[], weights: number[]): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Rule key must be a non-empty string');\n    }\n    if (!Array.isArray(values)) {\n      throw new Error('Rule values must be an array');\n    }\n    if (!Array.isArray(weights)) {\n      throw new Error('Rule weights must be an array');\n    }\n    if (values.length !== weights.length) {\n      throw new Error('Values and weights arrays must have the same length');\n    }\n    if (values.length === 0) {\n      throw new Error('Values array cannot be empty');\n    }\n    \n    // Validate weights\n    for (const weight of weights) {\n      if (typeof weight !== 'number' || weight < 0) {\n        throw new Error('All weights must be non-negative numbers');\n      }\n    }\n    \n    const weightSum = weights.reduce((sum, weight) => sum + weight, 0);\n    if (Math.abs(weightSum - 1.0) > 0.0001) {\n      throw new Error(`Weights must sum to 1.0, got ${weightSum}`);\n    }\n    \n    // Calculate cumulative weights for efficient sampling\n    const cumulativeWeights: number[] = [];\n    let cumSum = 0;\n    for (const weight of weights) {\n      cumSum += weight;\n      cumulativeWeights.push(cumSum);\n    }\n    \n    this.rules.set(key, {\n      values: [...values],\n      weights: [...weights],\n      cumulativeWeights\n    });\n  }\n\n  /**\n   * Generate a value from a weighted rule\n   * @param key - Rule identifier\n   * @param context - Current parsing context (unused for weighted rules)\n   * @param random - Random number generator\n   * @returns Weighted random value or null if rule doesn't exist\n   */\n  public generateValue(\n    key: string, \n    context: { [key: string]: string }, \n    random: SeededRandom\n  ): string | null {\n    const rule = this.rules.get(key);\n    if (!rule) {\n      return null;\n    }\n    \n    return random.weightedChoice(rule.values, rule.cumulativeWeights);\n  }\n}","/**\n * Unified rule manager that coordinates all rule types\n */\nimport { \n  Grammar, \n  FunctionRule, \n  ConditionalRule, \n  TemplateRule,\n  WeightedRule,\n  SequentialRule,\n  RangeRule\n} from '../types.js';\nimport { SeededRandom } from '../utils/SeededRandom.js';\nimport { \n  StaticRuleManager, \n  FunctionRuleManager, \n  WeightedRuleManager \n} from './BaseRuleManager.js';\nimport { \n  ConditionalRuleManager, \n  SequentialRuleManager, \n  RangeRuleManager, \n  TemplateRuleManager \n} from './AdvancedRuleManagers.js';\n\n/**\n * Unified manager for all rule types with priority-based resolution\n */\nexport class RuleManager {\n  private staticRules = new StaticRuleManager();\n  private functionRules = new FunctionRuleManager();\n  private weightedRules = new WeightedRuleManager();\n  private conditionalRules = new ConditionalRuleManager();\n  private sequentialRules = new SequentialRuleManager();\n  private rangeRules = new RangeRuleManager();\n  private templateRules = new TemplateRuleManager();\n\n  // Rule resolution priority (first match wins)\n  private readonly ruleManagers = [\n    { name: 'function', manager: this.functionRules },\n    { name: 'conditional', manager: this.conditionalRules },\n    { name: 'sequential', manager: this.sequentialRules },\n    { name: 'range', manager: this.rangeRules },\n    { name: 'template', manager: this.templateRules },\n    { name: 'weighted', manager: this.weightedRules },\n    { name: 'static', manager: this.staticRules }\n  ];\n\n  /**\n   * Add static rules\n   */\n  public addRule(key: string, values: string[]): void {\n    this.staticRules.addRule(key, values);\n  }\n\n  public addRules(grammar: Grammar): void {\n    this.staticRules.addRules(grammar);\n  }\n\n  /**\n   * Add function rule\n   */\n  public addFunctionRule(key: string, fn: FunctionRule): void {\n    this.functionRules.addRule(key, fn);\n  }\n\n  /**\n   * Add weighted rule\n   */\n  public addWeightedRule(key: string, values: string[], weights: number[]): void {\n    this.weightedRules.addRule(key, values, weights);\n  }\n\n  /**\n   * Add conditional rule\n   */\n  public addConditionalRule(key: string, rule: ConditionalRule): void {\n    this.conditionalRules.addRule(key, rule);\n  }\n\n  /**\n   * Add sequential rule\n   */\n  public addSequentialRule(key: string, values: string[], options?: { cycle: boolean }): void {\n    this.sequentialRules.addRule(key, values, options);\n  }\n\n  /**\n   * Add range rule\n   */\n  public addRangeRule(key: string, config: { min: number; max: number; step?: number; type: 'integer' | 'float' }): void {\n    this.rangeRules.addRule(key, config);\n  }\n\n  /**\n   * Add template rule\n   */\n  public addTemplateRule(key: string, rule: TemplateRule): void {\n    this.templateRules.addRule(key, rule);\n  }\n\n  /**\n   * Check if a rule exists (any type)\n   */\n  public hasRule(key: string): boolean {\n    return this.ruleManagers.some(({ manager }) => manager.hasRule(key));\n  }\n\n  /**\n   * Remove a rule (from all managers)\n   */\n  public removeRule(key: string): boolean {\n    let removed = false;\n    for (const { manager } of this.ruleManagers) {\n      if (manager.removeRule(key)) {\n        removed = true;\n      }\n    }\n    return removed;\n  }\n\n  /**\n   * Generate a value from any rule type\n   * Uses priority order: function  conditional  sequential  range  template  weighted  static\n   */\n  public generateValue(key: string, context: { [key: string]: string }, random: SeededRandom): string | null {\n    for (const { manager } of this.ruleManagers) {\n      if (manager.hasRule(key)) {\n        return manager.generateValue(key, context, random);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get rule type for a given key\n   */\n  public getRuleType(key: string): string | null {\n    for (const { name, manager } of this.ruleManagers) {\n      if (manager.hasRule(key)) {\n        return name;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Clear all rules\n   */\n  public clear(): void {\n    for (const { manager } of this.ruleManagers) {\n      manager.clear();\n    }\n  }\n\n  /**\n   * Clear specific rule types\n   */\n  public clearStaticRules(): void { this.staticRules.clear(); }\n  public clearFunctionRules(): void { this.functionRules.clear(); }\n  public clearWeightedRules(): void { this.weightedRules.clear(); }\n  public clearConditionalRules(): void { this.conditionalRules.clear(); }\n  public clearSequentialRules(): void { this.sequentialRules.clear(); }\n  public clearRangeRules(): void { this.rangeRules.clear(); }\n  public clearTemplateRules(): void { this.templateRules.clear(); }\n\n  /**\n   * Get statistics about rules\n   */\n  public getStats(): { [key: string]: number } {\n    return {\n      static: this.staticRules.size(),\n      function: this.functionRules.size(),\n      weighted: this.weightedRules.size(),\n      conditional: this.conditionalRules.size(),\n      sequential: this.sequentialRules.size(),\n      range: this.rangeRules.size(),\n      template: this.templateRules.size(),\n      total: this.ruleManagers.reduce((sum, { manager }) => sum + manager.size(), 0)\n    };\n  }\n\n  /**\n   * Get all rule keys\n   */\n  public getAllKeys(): string[] {\n    const keys = new Set<string>();\n    for (const { manager } of this.ruleManagers) {\n      for (const key of manager.getKeys()) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys);\n  }\n\n  /**\n   * Reset sequential rule\n   */\n  public resetSequentialRule(key: string): boolean {\n    return this.sequentialRules.resetRule(key);\n  }\n\n  /**\n   * Get static grammar\n   */\n  public getGrammar(): Grammar {\n    return this.staticRules.getGrammar();\n  }\n\n  /**\n   * Get rule data for analysis purposes\n   */\n  public getWeightedRuleData(key: string): WeightedRule | undefined {\n    return this.weightedRules.getRuleData(key);\n  }\n\n  public getConditionalRuleData(key: string): ConditionalRule | undefined {\n    return this.conditionalRules.getRuleData(key);\n  }\n\n  public getSequentialRuleData(key: string): SequentialRule | undefined {\n    return this.sequentialRules.getRuleData(key);\n  }\n\n  public getRangeRuleData(key: string): RangeRule | undefined {\n    return this.rangeRules.getRuleData(key);\n  }\n\n  public getTemplateRuleData(key: string): TemplateRule | undefined {\n    return this.templateRules.getRuleData(key);\n  }\n\n  /**\n   * Check specific rule types\n   */\n  public hasFunctionRule(key: string): boolean { return this.functionRules.hasRule(key); }\n  public hasWeightedRule(key: string): boolean { return this.weightedRules.hasRule(key); }\n  public hasConditionalRule(key: string): boolean { return this.conditionalRules.hasRule(key); }\n  public hasSequentialRule(key: string): boolean { return this.sequentialRules.hasRule(key); }\n  public hasRangeRule(key: string): boolean { return this.rangeRules.hasRule(key); }\n  public hasTemplateRule(key: string): boolean { return this.templateRules.hasRule(key); }\n\n  /**\n   * Remove specific rule types\n   */\n  public removeFunctionRule(key: string): boolean { return this.functionRules.removeRule(key); }\n  public removeWeightedRule(key: string): boolean { return this.weightedRules.removeRule(key); }\n  public removeConditionalRule(key: string): boolean { return this.conditionalRules.removeRule(key); }\n  public removeSequentialRule(key: string): boolean { return this.sequentialRules.removeRule(key); }\n  public removeRangeRule(key: string): boolean { return this.rangeRules.removeRule(key); }\n  public removeTemplateRule(key: string): boolean { return this.templateRules.removeRule(key); }\n}","/**\n * Seeded random number generator using Linear Congruential Generator (LCG)\n * Provides deterministic pseudo-random numbers for reproducible text generation\n */\nexport class SeededRandom {\n  private seed: number | null = null;\n  private currentSeed: number = 0;\n\n  /**\n   * Set a seed for deterministic random generation\n   * @param seed - Integer seed value\n   */\n  public setSeed(seed: number): void {\n    if (!Number.isInteger(seed)) {\n      throw new Error('Seed must be an integer');\n    }\n    this.seed = Math.abs(seed) >>> 0; // Convert to 32-bit unsigned integer\n    this.currentSeed = this.seed;\n  }\n\n  /**\n   * Clear the seed and return to using Math.random()\n   */\n  public clearSeed(): void {\n    this.seed = null;\n    this.currentSeed = 0;\n  }\n\n  /**\n   * Get the current seed value\n   * @returns Current seed or null if using Math.random()\n   */\n  public getSeed(): number | null {\n    return this.seed;\n  }\n\n  /**\n   * Generate a random number between 0 and 1\n   * Uses LCG when seed is set, Math.random() otherwise\n   * @returns Random number between 0 and 1\n   */\n  public random(): number {\n    if (this.seed === null) {\n      return Math.random();\n    }\n    \n    // Linear Congruential Generator (LCG)\n    // Using parameters from Numerical Recipes: a=1664525, c=1013904223, m=2^32\n    this.currentSeed = (this.currentSeed * 1664525 + 1013904223) >>> 0;\n    return this.currentSeed / 0x100000000; // Convert to 0-1 range\n  }\n\n  /**\n   * Get a random integer between min (inclusive) and max (exclusive)\n   * @param min - Minimum value (inclusive)\n   * @param max - Maximum value (exclusive)\n   * @returns Random integer\n   */\n  public randomInt(min: number, max: number): number {\n    return Math.floor(this.random() * (max - min)) + min;\n  }\n\n  /**\n   * Get a random element from an array\n   * @param array - Array to choose from\n   * @returns Random element from array\n   */\n  public randomChoice<T>(array: T[]): T {\n    if (array.length === 0) {\n      throw new Error('Cannot choose from empty array');\n    }\n    const index = this.randomInt(0, array.length);\n    return array[index];\n  }\n\n  /**\n   * Get a weighted random element from arrays of values and weights\n   * @param values - Array of values\n   * @param cumulativeWeights - Array of cumulative weights\n   * @returns Weighted random value\n   */\n  public weightedChoice<T>(values: T[], cumulativeWeights: number[]): T {\n    if (values.length !== cumulativeWeights.length) {\n      throw new Error('Values and weights arrays must have same length');\n    }\n    if (values.length === 0) {\n      throw new Error('Cannot choose from empty arrays');\n    }\n\n    const random = this.random();\n    \n    // Find the first cumulative weight that is greater than our random number\n    for (let i = 0; i < cumulativeWeights.length; i++) {\n      if (random <= cumulativeWeights[i]) {\n        return values[i];\n      }\n    }\n    \n    // Fallback to last value (should not happen with proper weights)\n    return values[values.length - 1];\n  }\n}","/**\n * Grammar validation functionality\n */\nimport { ValidationResult } from '../types.js';\nimport { RuleManager } from '../rules/RuleManager.js';\nimport { VariableExpander } from '../core/VariableExpander.js';\n\nexport class GrammarValidator {\n  constructor(\n    private ruleManager: RuleManager,\n    private variableExpander: VariableExpander\n  ) {}\n\n  /**\n   * Perform comprehensive grammar validation to detect potential issues\n   * \n   * This method analyzes the entire grammar structure to identify problems that could\n   * cause parsing failures or unexpected behavior. It checks for missing references,\n   * circular dependencies, empty rules, and provides warnings for potential issues.\n   * \n   * @returns Comprehensive validation results object\n   */\n  public validate(): ValidationResult {\n    const missingRules: string[] = [];\n    const circularReferences: string[] = [];\n    const emptyRules: string[] = [];\n    const unreachableRules: string[] = [];\n    const warnings: string[] = [];\n\n    const allRules = this.ruleManager.getAllKeys();\n    const referencedRules = new Set<string>();\n\n    // Check each rule for issues\n    for (const ruleKey of allRules) {\n      // Check if rule is empty\n      if (this.isRuleEmpty(ruleKey)) {\n        emptyRules.push(ruleKey);\n      }\n\n      // Find all variables referenced by this rule and check if they exist\n      const referencedVariables = this.findRuleReferences(ruleKey);\n      for (const variable of referencedVariables) {\n        referencedRules.add(variable);\n        if (!this.ruleManager.hasRule(variable)) {\n          if (!missingRules.includes(variable)) {\n            missingRules.push(variable);\n          }\n        }\n      }\n    }\n\n    // Find unreachable rules (rules that exist but are never referenced)\n    for (const ruleKey of allRules) {\n      if (!referencedRules.has(ruleKey) && !this.isRootRule(ruleKey)) {\n        unreachableRules.push(ruleKey);\n      }\n    }\n\n    // Check for circular references\n    const circularRefs = this.variableExpander.findCircularReferences();\n    circularReferences.push(...circularRefs);\n\n    // Generate warnings\n    if (emptyRules.length > 0) {\n      warnings.push(`Found ${emptyRules.length} empty rules that may cause issues`);\n    }\n    if (unreachableRules.length > 5) {\n      warnings.push(`Found ${unreachableRules.length} unreachable rules - consider cleanup`);\n    }\n    if (allRules.length > 100) {\n      warnings.push(`Large grammar with ${allRules.length} rules - consider organizing into groups`);\n    }\n\n    const isValid = missingRules.length === 0 && \n                   circularReferences.length === 0 && \n                   emptyRules.length === 0;\n\n    return {\n      isValid,\n      missingRules,\n      circularReferences,\n      emptyRules,\n      unreachableRules,\n      warnings\n    };\n  }\n\n  /**\n   * Check if a rule is empty (has no values or only empty values)\n   * @private\n   */\n  private isRuleEmpty(ruleKey: string): boolean {\n    const ruleType = this.ruleManager.getRuleType(ruleKey);\n    \n    switch (ruleType) {\n      case 'static': {\n        const staticRule = this.ruleManager.getGrammar()[ruleKey];\n        return !staticRule || staticRule.length === 0 || \n               staticRule.every(value => !value || value.trim() === '');\n      }\n      \n      case 'function':\n        // Function rules can't be easily checked for emptiness\n        return false;\n        \n      case 'weighted':\n      case 'conditional':\n      case 'sequential':\n      case 'template':\n      case 'range':\n        // These rule types are handled by their respective managers\n        // and should have validation in place during creation\n        return false;\n        \n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Find all variables referenced by a rule\n   * @private\n   */\n  private findRuleReferences(ruleKey: string): string[] {\n    const references: string[] = [];\n    const ruleType = this.ruleManager.getRuleType(ruleKey);\n    \n    switch (ruleType) {\n      case 'static': {\n        const staticRule = this.ruleManager.getGrammar()[ruleKey];\n        if (staticRule) {\n          for (const value of staticRule) {\n            const variables = this.variableExpander.findVariables(value);\n            references.push(...variables.filter(v => !v.startsWith('@')));\n          }\n        }\n        break;\n      }\n        \n      case 'function':\n        // Function rules are dynamic, can't analyze statically\n        break;\n        \n      // Other rule types would need specific analysis\n      // This is a simplified implementation\n    }\n    \n    // Remove duplicates\n    return Array.from(new Set(references));\n  }\n\n  /**\n   * Check if a rule is likely a root rule (commonly used entry points)\n   * @private\n   */\n  private isRootRule(ruleKey: string): boolean {\n    const rootPatterns = [\n      /^(main|start|root|entry|begin)$/i,\n      /^(sentence|story|text|output)$/i,\n      /^(template|pattern|format)$/i\n    ];\n    \n    return rootPatterns.some(pattern => pattern.test(ruleKey));\n  }\n\n  /**\n   * Validate a specific text string for missing variables\n   * @param text - Text to validate\n   * @returns Array of missing variable names\n   */\n  public validateText(text: string): string[] {\n    return this.variableExpander.findMissingVariables(text);\n  }\n\n  /**\n   * Quick validation check - returns true if grammar is valid\n   * @returns True if grammar passes basic validation\n   */\n  public isValid(): boolean {\n    const result = this.validate();\n    return result.isValid;\n  }\n\n  /**\n   * Get validation summary as a readable string\n   * @returns Human-readable validation summary\n   */\n  public getValidationSummary(): string {\n    const result = this.validate();\n    const lines: string[] = [];\n    \n    if (result.isValid) {\n      lines.push(' Grammar validation passed');\n    } else {\n      lines.push(' Grammar validation failed');\n    }\n    \n    if (result.missingRules.length > 0) {\n      lines.push(`Missing rules: ${result.missingRules.join(', ')}`);\n    }\n    \n    if (result.circularReferences.length > 0) {\n      lines.push(`Circular references: ${result.circularReferences.join(', ')}`);\n    }\n    \n    if (result.emptyRules.length > 0) {\n      lines.push(`Empty rules: ${result.emptyRules.join(', ')}`);\n    }\n    \n    if (result.unreachableRules.length > 0) {\n      lines.push(`Unreachable rules: ${result.unreachableRules.slice(0, 5).join(', ')}${result.unreachableRules.length > 5 ? '...' : ''}`);\n    }\n    \n    if (result.warnings.length > 0) {\n      lines.push('Warnings:');\n      for (const warning of result.warnings) {\n        lines.push(`  - ${warning}`);\n      }\n    }\n    \n    return lines.join('\\n');\n  }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n"],"names":["root","factory","exports","module","define","amd","this","EnglishArticleModifier","name","condition","text","test","transform","replace","priority","EnglishPluralizationModifier","match","quantifier","noun","pluralNoun","lowerNoun","toLowerCase","irregularPlurals","plural","original","toUpperCase","charAt","slice","includes","pluralize","EnglishOrdinalModifier","num","number","parseInt","lastTwoDigits","EnglishCapitalizationModifier","punctuation","letter","EnglishPossessiveModifier","word","endsWith","EnglishVerbAgreementModifier","PunctuationCleanupModifier","trim","AllEnglishModifiers","BasicEnglishModifiers","Parser","constructor","modifiers","Map","random","SeededRandom","ruleManager","RuleManager","variableExpander","VariableExpander","complexityAnalyzer","ComplexityAnalyzer","probabilityAnalyzer","ProbabilityAnalyzer","validator","GrammarValidator","errorHandler","ErrorHandler","addRule","key","values","addRules","rules","addFunctionRule","fn","addWeightedRule","weights","addConditionalRule","rule","addSequentialRule","options","cycle","addRangeRule","config","addTemplateRule","hasRule","removeRule","clear","hasFunctionRule","hasWeightedRule","hasConditionalRule","hasSequentialRule","hasRangeRule","hasTemplateRule","removeFunctionRule","removeWeightedRule","removeConditionalRule","removeSequentialRule","removeRangeRule","removeTemplateRule","clearFunctionRules","clearWeightedRules","clearConditionalRules","clearSequentialRules","clearRangeRules","clearTemplateRules","resetSequentialRule","getGrammar","addModifier","modifier","Error","set","removeModifier","delete","hasModifier","has","getModifiers","Array","from","sort","a","b","loadModifier","loadModifiers","clearModifiers","clearAll","parse","preserveContext","expanded","expandVariables","applyModifiers","originalText","parseWithTiming","startTime","Date","now","expansionStart","expansionEnd","modifierStart","result","modifierEnd","timing","totalMs","expansionMs","modifierMs","safeParse","validateFirst","maxAttempts","attempts","validation","validate","isValid","error","missingRules","length","join","success","getHelpfulError","currentDepth","getMaxDepth","setMaxDepth","Math","max","floor","context","modifiedText","sortedModifiers","parseBatch","texts","isArray","results","i","shouldPreserve","push","generateVariations","count","seed","Number","isInteger","variations","originalSeed","getSeed","undefined","setSeed","clearSeed","depth","setRandomSeed","clearRandomSeed","getRandomSeed","clearReferences","getContext","calculateRuleComplexity","ruleKey","visited","Set","maxDepth","calculateTotalComplexity","calculateProbabilities","maxOutcomes","getMostProbableOutcome","getLeastProbableOutcome","findVariables","getStats","ruleStats","totalRules","total","rulesByType","static","function","weighted","conditional","sequential","range","template","totalModifiers","size","hasRandomSeed","clone","cloned","grammar","exportConfig","map","m","settings","randomSeed","optimize","warnings","suggestions","concat","circularReferences","optimized","analyzeRules","ruleName","complexity","totalComplexity","averageDepth","mostComplex","ruleDetails","type","ruleType","variables","Object","keys","averageComplexity","mostComplexRules","r","isFinite","newVisited","add","getRuleType","calculateStaticRuleComplexity","calculateWeightedRuleComplexity","POSITIVE_INFINITY","calculateConditionalRuleComplexity","calculateSequentialRuleComplexity","calculateRangeRuleComplexity","calculateTemplateRuleComplexity","allRuleKeys","getAllKeys","complexityByRule","some","w","uniqueWarnings","uniqueCircularRefs","filter","finiteRules","reduce","sum","ruleCount","value","valueVariables","valueComplexity","variable","varResult","getWeightedRuleData","getConditionalRuleData","conditions","conditionComplexity","then","default","getSequentialRuleData","getRangeRuleData","step","min","getTemplateRuleData","templateVariables","variableComplexity","nestedVariable","createProbabilityResult","outcome","probability","probabilityTree","outcomes","calculateRuleProbabilities","totalOutcomes","mostProbable","leastProbable","averageProbability","entropy","sortedOutcomes","log2","reverse","o","calculateStaticRuleProbabilities","calculateWeightedRuleProbabilities","calculateRangeRuleProbabilities","calculateTemplateRuleProbabilities","calculateSequentialRuleProbabilities","calculateConditionalRuleProbabilities","baseProb","expandedOutcomes","expandVariablesWithProbabilities","totalWeight","weight","toString","toFixed","currentOutcomes","varName","entries","newOutcomes","valueProbability","currentOutcome","expandedValue","RegExp","nestedVariables","nestedOutcomes","nestedOutcome","remainingVariables","finalOutcomes","conditionProbability","baseProbability","variableProbabilities","varOutcome","combinedProbability","probabilityNode","children","lines","message","isRecursionError","isFunctionRuleError","isWeightError","isMissingRuleError","validateText","emptyRules","createMissingRuleError","createCircularReferenceError","createFunctionRuleError","originalError","createWeightValidationError","createRecursionDepthError","variablePattern","referenceValues","currentContext","clearContext","expandVariablesRecursive","lastIndex","startsWith","refKey","substring","refValue","get","generateValue","regex","source","exec","findMissingVariables","missing","findCircularReferences","startRule","circular","checkRuleForCircularReferences","allKeys","sampleValue","ArticleModifier","CapitalizationModifier","OrdinalModifier","PluralizationModifier","PossessiveModifier","VerbAgreementModifier","ConditionalRuleManager","BaseRuleManager","hasDefault","if","c","randomChoice","SequentialRuleManager","index","_context","_random","resetRule","RangeRuleManager","steps","randomInt","randomValue","TemplateRuleManager","templateVars","getRule","getKeys","getRuleData","weightSum","abs","cumulativeWeights","cumSum","weightedChoice","staticRules","StaticRuleManager","functionRules","FunctionRuleManager","weightedRules","WeightedRuleManager","conditionalRules","sequentialRules","rangeRules","templateRules","ruleManagers","manager","removed","clearStaticRules","currentSeed","array","unreachableRules","allRules","referencedRules","isRuleEmpty","referencedVariables","findRuleReferences","isRootRule","circularRefs","staticRule","every","references","v","pattern","getValidationSummary","warning","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}