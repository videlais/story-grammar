{"version":3,"file":"story-grammar.bundle.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAsB,aAAID,IAE1BD,EAAmB,aAAIC,GACxB,CATD,CASGK,KAAM,I,qHCgBT,6BACU,KAAAC,QAAmB,CAAC,EACpB,KAAAC,UAAmC,IAAIC,IACvC,KAAAC,gBAAkB,aAClB,KAAAC,SAAW,GAwZrB,CAjZS,OAAAC,CAAQC,EAAaC,GAC1B,IAAKD,GAAsB,iBAARA,EACjB,MAAM,IAAIE,MAAM,kCAElB,IAAKC,MAAMC,QAAQH,GACjB,MAAM,IAAIC,MAAM,2BAElBT,KAAKC,QAAQM,GAAO,IAAIC,EAC1B,CAMO,QAAAI,CAASC,GACd,IAAK,MAAON,EAAKC,KAAWM,OAAOC,QAAQF,GACzCb,KAAKM,QAAQC,EAAKC,EAEtB,CAMO,WAAAQ,CAAYC,G,MACjB,IAAKA,GAAgC,iBAAbA,EACtB,MAAM,IAAIR,MAAM,8BAElB,IAAKQ,EAASC,MAAiC,iBAAlBD,EAASC,KACpC,MAAM,IAAIT,MAAM,6BAElB,GAAkC,mBAAvBQ,EAASE,UAClB,MAAM,IAAIV,MAAM,2CAElB,GAAkC,mBAAvBQ,EAASG,UAClB,MAAM,IAAIX,MAAM,2CAGlBT,KAAKE,UAAUmB,IAAIJ,EAASC,KAAM,OAAF,wBAC3BD,GAAQ,CACXK,SAA2B,QAAjB,EAAAL,EAASK,gBAAQ,QAAI,IAEnC,CAOO,cAAAC,CAAeL,GACpB,OAAOlB,KAAKE,UAAUsB,OAAON,EAC/B,CAOO,WAAAO,CAAYP,GACjB,OAAOlB,KAAKE,UAAUwB,IAAIR,EAC5B,CAMO,YAAAS,GACL,OAAOjB,MAAMkB,KAAK5B,KAAKE,UAAUM,UAAUqB,KAAK,CAACC,EAAGC,KAAK,QAAC,OAAW,QAAV,EAAAA,EAAET,gBAAQ,QAAI,IAAgB,QAAV,EAAAQ,EAAER,gBAAQ,QAAI,IAC/F,CAKO,yBAAAU,GACLhC,KAAKgB,YAAY,CACfE,KAAM,kBACNC,UAAYc,GACH,qBAAqBC,KAAKD,GAEnCb,UAAYa,GAEHA,EAAKE,QAAQ,iCAAkC,UAExDb,SAAU,IAEd,CAMO,+BAAAc,GACLpC,KAAKgB,YAAY,CACfE,KAAM,uBACNC,UAAYc,GAEH,wEAAwEC,KAAKD,IAC7E,gEAAgEC,KAAKD,GAE9Eb,UAAYa,IAEV,MAAMI,EAA8C,CAClD,MAAS,WACT,OAAU,SACV,IAAO,MACP,MAAS,QACT,MAAS,OACT,KAAQ,OACR,MAAS,QACT,MAAS,QACT,GAAM,OACN,MAAS,QACT,KAAQ,OACR,KAAQ,QAGV,OAAOJ,EAAKE,QAAQ,0HAClB,CAACG,EAAOC,EAAYC,KAClB,MAAMC,EAAYD,EAAKE,cAGvB,GAAIL,EAAiBI,GACnB,MAAO,GAAGF,KAAcF,EAAiBI,KAI3C,IAAIE,EAAaH,EA6BjB,OAzBEG,EADE,gBAAgBT,KAAKO,GACVD,EAAO,KAGb,4BAA4BN,KAAKM,GAC3BA,EAAKI,MAAM,GAAI,GAAK,MAG1B,QAAQV,KAAKM,GACPA,EAAKL,QAAQ,QAAS,OAG5B,4BAA4BD,KAAKM,GAEpB,CAAC,QAAS,QAAS,OAAQ,SAC/BK,SAASJ,GACVD,EAAO,IAEPA,EAAO,KAKTA,EAAO,IAGf,GAAGD,KAAcI,OAI9BrB,SAAU,GAEd,CAMO,yBAAAwB,GACL9C,KAAKgB,YAAY,CACfE,KAAM,kBACNC,UAAYc,GAEH,UAAUC,KAAKD,GAExBb,UAAYa,GACHA,EAAKE,QAAQ,aAAc,CAACG,EAAOS,KACxC,MAAMC,EAASC,SAASF,EAAK,IAIvBG,EAAgBF,EAAS,IAG/B,GAAsB,KAAlBE,GAA0C,KAAlBA,GAA0C,KAAlBA,EAClD,OAAOH,EAAM,KAIf,OATkBC,EAAS,IAUzB,KAAK,EACH,OAAOD,EAAM,KACf,KAAK,EACH,OAAOA,EAAM,KACf,KAAK,EACH,OAAOA,EAAM,KACf,QACE,OAAOA,EAAM,QAIrBzB,SAAU,GAEd,CAMO,UAAA6B,GACL,MAAMC,EAAuB,CAAC,EAC9B,IAAK,MAAO7C,EAAKC,KAAWM,OAAOC,QAAQf,KAAKC,SAC9CmD,EAAY7C,GAAO,IAAIC,GAEzB,OAAO4C,CACT,CAOO,KAAAC,CAAMpB,GACX,GAAoB,iBAATA,EACT,MAAM,IAAIxB,MAAM,yBAElB,MAAM6C,EAAWtD,KAAKuD,gBAAgBtB,EAAM,GAC5C,OAAOjC,KAAKwD,eAAeF,EAAU,CAAEG,aAAcxB,GACvD,CAQQ,eAAAsB,CAAgBtB,EAAcyB,GACpC,GAAIA,GAAS1D,KAAKK,SAChB,MAAM,IAAII,MAAM,+EAMlB,OAFAT,KAAKI,gBAAgBuD,UAAY,EAE1B1B,EAAKE,QAAQnC,KAAKI,gBAAiB,CAACkC,EAAO/B,KAChD,MAAMC,EAASR,KAAKC,QAAQM,GAE5B,IAAKC,GAA4B,IAAlBA,EAAOoD,OAEpB,OAAOtB,EAIT,MAAMuB,EAAgB7D,KAAK8D,eAAetD,GAG1C,OAAOR,KAAKuD,gBAAgBM,EAAeH,EAAQ,IAEvD,CAQQ,cAAAF,CAAevB,EAAc8B,GACnC,IAAIC,EAAe/B,EAGnB,MAAMgC,EAAkBjE,KAAK2B,eAE7B,IAAK,MAAMV,KAAYgD,EACjBhD,EAASE,UAAU6C,EAAcD,KACnCC,EAAe/C,EAASG,UAAU4C,EAAcD,IAIpD,OAAOC,CACT,CAOQ,cAAAF,CAAetD,GAErB,OAAOA,EADa0D,KAAKC,MAAMD,KAAKE,SAAW5D,EAAOoD,QAExD,CAOO,OAAAS,CAAQ9D,GACb,OAAOA,KAAOP,KAAKC,OACrB,CAOO,UAAAqE,CAAW/D,GAChB,QAAIP,KAAKqE,QAAQ9D,YACRP,KAAKC,QAAQM,IACb,EAGX,CAKO,KAAAgE,GACLvE,KAAKC,QAAU,CAAC,CAClB,CAKO,cAAAuE,GACLxE,KAAKE,UAAUqE,OACjB,CAKO,QAAAE,GACLzE,KAAKuE,QACLvE,KAAKwE,gBACP,CAOO,aAAAE,CAAczC,GACnB,MAAM0C,EAAyB,IAAIC,IAGnC,IAAItC,EACJ,IAHAtC,KAAKI,gBAAgBuD,UAAY,EAGoB,QAA7CrB,EAAQtC,KAAKI,gBAAgByE,KAAK5C,KACxC0C,EAAUG,IAAIxC,EAAM,IAGtB,OAAO5B,MAAMkB,KAAK+C,EACpB,CAMO,QAAAI,GACL,MAAMC,EAA4B,IAAIJ,IAChCK,EAAkC,IAAIL,IAE5C,IAAK,MAAOrE,EAAKC,KAAWM,OAAOC,QAAQf,KAAKC,SAC9C,IAAK,MAAMiF,KAAS1E,EAAQ,CAC1B,MAAMmE,EAAY3E,KAAK0E,cAAcQ,GAErC,IAAK,MAAMC,KAAYR,EAChB3E,KAAKqE,QAAQc,IAChBH,EAAaF,IAAIK,GAIfA,IAAa5E,GACf0E,EAAmBH,IAAIvE,EAG7B,CAGF,MAAO,CACL6E,QAA+B,IAAtBJ,EAAaK,MAA0C,IAA5BJ,EAAmBI,KACvDL,aAActE,MAAMkB,KAAKoD,GACzBC,mBAAoBvE,MAAMkB,KAAKqD,GAEnC,CAMO,WAAAK,CAAY5B,GACjB,GAAIA,EAAQ,EACV,MAAM,IAAIjD,MAAM,gCAElBT,KAAKK,SAAWqD,CAClB,CAMO,WAAA6B,GACL,OAAOvF,KAAKK,QACd,E,GCnbEmF,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAa/F,QAGrB,IAAIC,EAAS2F,EAAyBE,GAAY,CAGjD9F,QAAS,CAAC,GAOX,OAHAiG,EAAoBH,GAAU7F,EAAQA,EAAOD,QAAS6F,GAG/C5F,EAAOD,OACf,C,6GClBA,2BACE,wEAAAkG,MAAM,IAQR,2BAAS,8EAAAA,MAAM,G","sources":["webpack://StoryGrammar/webpack/universalModuleDefinition","webpack://StoryGrammar/./src/Parser.ts","webpack://StoryGrammar/webpack/bootstrap","webpack://StoryGrammar/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StoryGrammar\"] = factory();\n\telse\n\t\troot[\"StoryGrammar\"] = factory();\n})(this, () => {\nreturn ","/**\n * Parser for combinatorial grammar with variable expansion\n */\n\nexport interface Grammar {\n  [key: string]: string[];\n}\n\nexport interface ModifierFunction {\n  (text: string, context?: ModifierContext): string;\n}\n\nexport interface ModifierContext {\n  ruleName?: string;\n  originalText?: string;\n  variables?: { [key: string]: string };\n}\n\nexport interface Modifier {\n  name: string;\n  condition: (text: string, context?: ModifierContext) => boolean;\n  transform: ModifierFunction;\n  priority?: number;\n}\n\nexport class Parser {\n  private grammar: Grammar = {};\n  private modifiers: Map<string, Modifier> = new Map();\n  private variablePattern = /%([^%]+)%/g;\n  private maxDepth = 100; // Prevent infinite recursion\n\n  /**\n   * Add a rule to the grammar\n   * @param key - The key to define\n   * @param values - Array of possible values for this key\n   */\n  public addRule(key: string, values: string[]): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!Array.isArray(values)) {\n      throw new Error('Values must be an array');\n    }\n    this.grammar[key] = [...values]; // Create a copy to avoid external mutation\n  }\n\n  /**\n   * Add multiple rules to the grammar\n   * @param rules - Object containing key-value pairs of rules\n   */\n  public addRules(rules: Grammar): void {\n    for (const [key, values] of Object.entries(rules)) {\n      this.addRule(key, values);\n    }\n  }\n\n  /**\n   * Add a modifier to the grammar\n   * @param modifier - The modifier to add\n   */\n  public addModifier(modifier: Modifier): void {\n    if (!modifier || typeof modifier !== 'object') {\n      throw new Error('Modifier must be an object');\n    }\n    if (!modifier.name || typeof modifier.name !== 'string') {\n      throw new Error('Modifier must have a name');\n    }\n    if (typeof modifier.condition !== 'function') {\n      throw new Error('Modifier must have a condition function');\n    }\n    if (typeof modifier.transform !== 'function') {\n      throw new Error('Modifier must have a transform function');\n    }\n    \n    this.modifiers.set(modifier.name, {\n      ...modifier,\n      priority: modifier.priority ?? 0\n    });\n  }\n\n  /**\n   * Remove a modifier from the grammar\n   * @param name - The name of the modifier to remove\n   * @returns True if the modifier was removed, false if it didn't exist\n   */\n  public removeModifier(name: string): boolean {\n    return this.modifiers.delete(name);\n  }\n\n  /**\n   * Check if a modifier exists\n   * @param name - The name of the modifier to check\n   * @returns True if the modifier exists, false otherwise\n   */\n  public hasModifier(name: string): boolean {\n    return this.modifiers.has(name);\n  }\n\n  /**\n   * Get all modifiers\n   * @returns Array of all modifiers sorted by priority\n   */\n  public getModifiers(): Modifier[] {\n    return Array.from(this.modifiers.values()).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n  }\n\n  /**\n   * Add built-in English article modifier (a/an)\n   */\n  public addEnglishArticleModifier(): void {\n    this.addModifier({\n      name: 'englishArticles',\n      condition: (text: string) => {\n        return /\\ba\\s+[aeiouAEIOU]/.test(text);\n      },\n      transform: (text: string) => {\n        // More precise regex to handle vowel sounds at word boundaries\n        return text.replace(/\\ba(\\s+)([aeiouAEIOU][a-z]*)/gi, 'an$1$2');\n      },\n      priority: 10\n    });\n  }\n\n  /**\n   * Add built-in English pluralization modifier\n   * Handles common pluralization patterns and irregular forms\n   */\n  public addEnglishPluralizationModifier(): void {\n    this.addModifier({\n      name: 'englishPluralization',\n      condition: (text: string) => {\n        // Look for plural indicators: numbers > 1, \"many\", \"several\", \"multiple\", etc.\n        return /\\b(many|several|multiple|some|few|\\d*[2-9]\\d*|\\d+[02-9])\\s+[a-zA-Z]+/i.test(text) ||\n               /\\b(two|three|four|five|six|seven|eight|nine|ten)\\s+[a-zA-Z]+/i.test(text);\n      },\n      transform: (text: string) => {\n        // Irregular plurals mapping\n        const irregularPlurals: { [key: string]: string } = {\n          'child': 'children',\n          'person': 'people',\n          'man': 'men',\n          'woman': 'women',\n          'mouse': 'mice',\n          'foot': 'feet',\n          'tooth': 'teeth',\n          'goose': 'geese',\n          'ox': 'oxen',\n          'sheep': 'sheep',\n          'deer': 'deer',\n          'fish': 'fish'\n        };\n\n        return text.replace(/\\b(many|several|multiple|some|few|\\d*[2-9]\\d*|\\d+[02-9]|two|three|four|five|six|seven|eight|nine|ten)\\s+([a-zA-Z]+)\\b/gi, \n          (match, quantifier, noun) => {\n            const lowerNoun = noun.toLowerCase();\n            \n            // Check for irregular plurals first\n            if (irregularPlurals[lowerNoun]) {\n              return `${quantifier} ${irregularPlurals[lowerNoun]}`;\n            }\n            \n            // Apply regular pluralization rules\n            let pluralNoun = noun;\n            \n            // Words ending in s, ss, sh, ch, x, z: add -es\n            if (/[sxz]$|[sc]h$/.test(lowerNoun)) {\n              pluralNoun = noun + 'es';\n            }\n            // Words ending in consonant + y: change y to ies\n            else if (/[bcdfghjklmnpqrstvwxz]y$/i.test(noun)) {\n              pluralNoun = noun.slice(0, -1) + 'ies';\n            }\n            // Words ending in f or fe: change to ves\n            else if (/fe?$/i.test(noun)) {\n              pluralNoun = noun.replace(/fe?$/i, 'ves');\n            }\n            // Words ending in o: usually add -es (with some exceptions)\n            else if (/[bcdfghjklmnpqrstvwxz]o$/i.test(noun)) {\n              // Common exceptions that just add -s\n              const oExceptions = ['photo', 'piano', 'halo', 'disco'];\n              if (oExceptions.includes(lowerNoun)) {\n                pluralNoun = noun + 's';\n              } else {\n                pluralNoun = noun + 'es';\n              }\n            }\n            // Default: add -s\n            else {\n              pluralNoun = noun + 's';\n            }\n            \n            return `${quantifier} ${pluralNoun}`;\n          }\n        );\n      },\n      priority: 9\n    });\n  }\n\n  /**\n   * Add built-in English ordinal modifier\n   * Converts cardinal numbers to ordinal format (1 -> 1st, 2 -> 2nd, etc.)\n   */\n  public addEnglishOrdinalModifier(): void {\n    this.addModifier({\n      name: 'englishOrdinals',\n      condition: (text: string) => {\n        // Look for standalone numbers (digits)\n        return /\\b\\d+\\b/.test(text);\n      },\n      transform: (text: string) => {\n        return text.replace(/\\b(\\d+)\\b/g, (match, num) => {\n          const number = parseInt(num, 10);\n          \n          // Get the last digit and last two digits\n          const lastDigit = number % 10;\n          const lastTwoDigits = number % 100;\n          \n          // Exception: numbers ending in 11, 12, 13 use 'th'\n          if (lastTwoDigits === 11 || lastTwoDigits === 12 || lastTwoDigits === 13) {\n            return num + 'th';\n          }\n          \n          // Apply ordinal rules based on last digit\n          switch (lastDigit) {\n            case 1:\n              return num + 'st';\n            case 2:\n              return num + 'nd';\n            case 3:\n              return num + 'rd';\n            default:\n              return num + 'th';\n          }\n        });\n      },\n      priority: 8\n    });\n  }\n\n  /**\n   * Get all grammar rules\n   * @returns Copy of all grammar rules\n   */\n  public getGrammar(): Grammar {\n    const grammarCopy: Grammar = {};\n    for (const [key, values] of Object.entries(this.grammar)) {\n      grammarCopy[key] = [...values];\n    }\n    return grammarCopy;\n  }\n\n  /**\n   * Parse a text string and expand all variables\n   * @param text - The text to parse\n   * @returns Parsed text with variables expanded\n   */\n  public parse(text: string): string {\n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    const expanded = this.expandVariables(text, 0);\n    return this.applyModifiers(expanded, { originalText: text });\n  }\n\n  /**\n   * Recursively expand variables in text\n   * @param text - The text to expand\n   * @param depth - Current recursion depth\n   * @returns Text with variables expanded\n   */\n  private expandVariables(text: string, depth: number): string {\n    if (depth >= this.maxDepth) {\n      throw new Error('Maximum recursion depth exceeded. Check for circular references in grammar.');\n    }\n\n    // Reset the regex lastIndex to ensure proper matching\n    this.variablePattern.lastIndex = 0;\n\n    return text.replace(this.variablePattern, (match, key) => {\n      const values = this.grammar[key];\n      \n      if (!values || values.length === 0) {\n        // Return the original variable if no rule is found\n        return match;\n      }\n\n      // Randomly select a value\n      const selectedValue = this.getRandomValue(values);\n      \n      // Recursively expand variables in the selected value\n      return this.expandVariables(selectedValue, depth + 1);\n    });\n  }\n\n  /**\n   * Apply all applicable modifiers to text\n   * @param text - The text to modify\n   * @param context - Optional context for modifier application\n   * @returns Modified text\n   */\n  private applyModifiers(text: string, context?: ModifierContext): string {\n    let modifiedText = text;\n    \n    // Get modifiers sorted by priority (higher priority first)\n    const sortedModifiers = this.getModifiers();\n    \n    for (const modifier of sortedModifiers) {\n      if (modifier.condition(modifiedText, context)) {\n        modifiedText = modifier.transform(modifiedText, context);\n      }\n    }\n    \n    return modifiedText;\n  }\n\n  /**\n   * Get a random value from an array\n   * @param values - Array of values to choose from\n   * @returns A random value from the array\n   */\n  private getRandomValue(values: string[]): string {\n    const randomIndex = Math.floor(Math.random() * values.length);\n    return values[randomIndex];\n  }\n\n  /**\n   * Check if a key exists in the grammar\n   * @param key - The key to check\n   * @returns True if the key exists, false otherwise\n   */\n  public hasRule(key: string): boolean {\n    return key in this.grammar;\n  }\n\n  /**\n   * Remove a rule from the grammar\n   * @param key - The key to remove\n   * @returns True if the rule was removed, false if it didn't exist\n   */\n  public removeRule(key: string): boolean {\n    if (this.hasRule(key)) {\n      delete this.grammar[key];\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Clear all rules from the grammar\n   */\n  public clear(): void {\n    this.grammar = {};\n  }\n\n  /**\n   * Clear all modifiers\n   */\n  public clearModifiers(): void {\n    this.modifiers.clear();\n  }\n\n  /**\n   * Clear all rules and modifiers\n   */\n  public clearAll(): void {\n    this.clear();\n    this.clearModifiers();\n  }\n\n  /**\n   * Get all variable names found in a text string\n   * @param text - The text to analyze\n   * @returns Array of unique variable names found\n   */\n  public findVariables(text: string): string[] {\n    const variables: Set<string> = new Set();\n    this.variablePattern.lastIndex = 0;\n    \n    let match;\n    while ((match = this.variablePattern.exec(text)) !== null) {\n      variables.add(match[1]);\n    }\n    \n    return Array.from(variables);\n  }\n\n  /**\n   * Validate that all variables in the grammar can be resolved\n   * @returns Object containing validation results\n   */\n  public validate(): { isValid: boolean; missingRules: string[]; circularReferences: string[] } {\n    const missingRules: Set<string> = new Set();\n    const circularReferences: Set<string> = new Set();\n\n    for (const [key, values] of Object.entries(this.grammar)) {\n      for (const value of values) {\n        const variables = this.findVariables(value);\n        \n        for (const variable of variables) {\n          if (!this.hasRule(variable)) {\n            missingRules.add(variable);\n          }\n          \n          // Simple circular reference detection (direct self-reference)\n          if (variable === key) {\n            circularReferences.add(key);\n          }\n        }\n      }\n    }\n\n    return {\n      isValid: missingRules.size === 0 && circularReferences.size === 0,\n      missingRules: Array.from(missingRules),\n      circularReferences: Array.from(circularReferences)\n    };\n  }\n\n  /**\n   * Set the maximum recursion depth for variable expansion\n   * @param depth - Maximum depth (default: 100)\n   */\n  public setMaxDepth(depth: number): void {\n    if (depth < 1) {\n      throw new Error('Max depth must be at least 1');\n    }\n    this.maxDepth = depth;\n  }\n\n  /**\n   * Get the current maximum recursion depth\n   * @returns Current maximum depth\n   */\n  public getMaxDepth(): number {\n    return this.maxDepth;\n  }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Story Grammar - A combinatorial grammar for narrative-based projects\n */\n\nexport { \n  Parser, \n  type Grammar, \n  type Modifier, \n  type ModifierFunction, \n  type ModifierContext \n} from './Parser.js';\n\n// Re-export for backward compatibility\nexport { Parser as StoryGrammar } from './Parser.js';"],"names":["root","factory","exports","module","define","amd","this","grammar","modifiers","Map","variablePattern","maxDepth","addRule","key","values","Error","Array","isArray","addRules","rules","Object","entries","addModifier","modifier","name","condition","transform","set","priority","removeModifier","delete","hasModifier","has","getModifiers","from","sort","a","b","addEnglishArticleModifier","text","test","replace","addEnglishPluralizationModifier","irregularPlurals","match","quantifier","noun","lowerNoun","toLowerCase","pluralNoun","slice","includes","addEnglishOrdinalModifier","num","number","parseInt","lastTwoDigits","getGrammar","grammarCopy","parse","expanded","expandVariables","applyModifiers","originalText","depth","lastIndex","length","selectedValue","getRandomValue","context","modifiedText","sortedModifiers","Math","floor","random","hasRule","removeRule","clear","clearModifiers","clearAll","findVariables","variables","Set","exec","add","validate","missingRules","circularReferences","value","variable","isValid","size","setMaxDepth","getMaxDepth","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","Parser"],"sourceRoot":""}