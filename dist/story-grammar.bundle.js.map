{"version":3,"file":"story-grammar.bundle.js","mappings":"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","sources":["webpack://StoryGrammar/webpack/universalModuleDefinition","webpack://StoryGrammar/./src/EnglishModifiers.ts","webpack://StoryGrammar/./src/Parser.ts","webpack://StoryGrammar/./src/ParserCore.ts","webpack://StoryGrammar/./src/index.ts","webpack://StoryGrammar/webpack/bootstrap","webpack://StoryGrammar/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StoryGrammar\"] = factory();\n\telse\n\t\troot[\"StoryGrammar\"] = factory();\n})(this, () => {\nreturn ","/**\n * English language modifiers for the Story Grammar Parser\n */\n\nimport { Modifier } from './Parser';\n\n/**\n * English article modifier (a/an correction)\n * Converts \"a\" to \"an\" before vowel sounds\n */\nexport const EnglishArticleModifier: Modifier = {\n  name: 'englishArticles',\n  condition: (text: string) => {\n    return /\\ba\\s+[aeiouAEIOU]/.test(text);\n  },\n  transform: (text: string) => {\n    // More precise regex to handle vowel sounds at word boundaries\n    return text.replace(/\\ba(\\s+)([aeiouAEIOU][a-z]*)/gi, 'an$1$2');\n  },\n  priority: 10\n};\n\n/**\n * English pluralization modifier\n * Handles comprehensive pluralization patterns including irregular forms\n */\nexport const EnglishPluralizationModifier: Modifier = {\n  name: 'englishPluralization',\n  condition: (text: string) => {\n    // Look for plural indicators: numbers > 1, \"many\", \"several\", \"multiple\", etc.\n    return /\\b(many|several|multiple|some|few|all|both|various|numerous|[2-9]\\d*|\\d*[02-9])\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+[a-zA-Z]+/i.test(text) ||\n           /\\b(zero|no)\\s+[a-zA-Z]+/i.test(text); // Zero/no also takes plural\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(many|several|multiple|some|few|all|both|various|numerous|zero|no|[2-9]\\d*|\\d*[02-9]|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty)\\s+([a-zA-Z]+)\\b/gi, \n      (match, quantifier, noun) => {\n        const pluralNoun = pluralize(noun);\n        return `${quantifier} ${pluralNoun}`;\n      }\n    );\n  },\n  priority: 9\n};\n\n/**\n * English ordinal modifier\n * Converts cardinal numbers to ordinal format (1 -> 1st, 2 -> 2nd, etc.)\n */\nexport const EnglishOrdinalModifier: Modifier = {\n  name: 'englishOrdinals',\n  condition: (text: string) => {\n    // Look for standalone numbers (digits)\n    return /\\b\\d+\\b/.test(text);\n  },\n  transform: (text: string) => {\n    return text.replace(/\\b(\\d+)\\b/g, (match, num) => {\n      const number = parseInt(num, 10);\n      \n      // Get the last digit and last two digits\n      const lastDigit = number % 10;\n      const lastTwoDigits = number % 100;\n      \n      // Exception: numbers ending in 11, 12, 13 use 'th'\n      if (lastTwoDigits === 11 || lastTwoDigits === 12 || lastTwoDigits === 13) {\n        return num + 'th';\n      }\n      \n      // Apply ordinal rules based on last digit\n      switch (lastDigit) {\n        case 1:\n          return num + 'st';\n        case 2:\n          return num + 'nd';\n        case 3:\n          return num + 'rd';\n        default:\n          return num + 'th';\n      }\n    });\n  },\n  priority: 8\n};\n\n/**\n * English capitalization modifier\n * Capitalizes words after sentence-ending punctuation\n */\nexport const EnglishCapitalizationModifier: Modifier = {\n  name: 'englishCapitalization',\n  condition: (text: string) => {\n    // Look for lowercase letters after sentence endings\n    return /[.!?]\\s+[a-z]/.test(text);\n  },\n  transform: (text: string) => {\n    // Capitalize first letter of sentences\n    return text.replace(/([.!?]\\s+)([a-z])/g, (match, punctuation, letter) => {\n      return punctuation + letter.toUpperCase();\n    });\n  },\n  priority: 7\n};\n\n/**\n * English possessive modifier\n * Handles English possessive forms ('s and s')\n */\nexport const EnglishPossessiveModifier: Modifier = {\n  name: 'englishPossessives',\n  condition: (text: string) => {\n    // Look for possessive patterns: word + possessive marker\n    return /\\b\\w+\\s+possessive\\b/i.test(text) || /\\b\\w+'s?\\s+\\w/.test(text);\n  },\n  transform: (text: string) => {\n    // Handle explicit possessive marker\n    text = text.replace(/\\b(\\w+)\\s+possessive\\b/gi, (match, word) => {\n      return word.endsWith('s') ? word + \"'\" : word + \"'s\";\n    });\n    \n    // Fix double possessives (word's's -> word's)\n    text = text.replace(/(\\w+)'s's/g, \"$1's\");\n    \n    return text;\n  },\n  priority: 6\n};\n\n/**\n * English verb agreement modifier\n * Handles basic subject-verb agreement for common verbs\n */\nexport const EnglishVerbAgreementModifier: Modifier = {\n  name: 'englishVerbAgreement',\n  condition: (text: string) => {\n    // Look for agreement issues\n    return /\\b(he|she|it)\\s+are\\b/i.test(text) || \n           /\\b(they|many|several|few|all|both)\\s+is\\b/i.test(text) ||\n           /\\b(he|she|it)\\s+have\\b/i.test(text) ||\n           /\\b(they|many|several|few|all|both)\\s+has\\b/i.test(text);\n  },\n  transform: (text: string) => {\n    // Fix is/are agreement for singular subjects\n    text = text.replace(/\\b(he|she|it)\\s+are\\b/gi, '$1 is');\n    \n    // Fix is/are agreement for plural subjects and quantifiers\n    text = text.replace(/\\b(they|many|several|few|all|both)\\s+is\\b/gi, '$1 are');\n    \n    // Fix has/have agreement for singular subjects\n    text = text.replace(/\\b(he|she|it)\\s+have\\b/gi, '$1 has');\n    \n    // Fix has/have agreement for plural subjects and quantifiers\n    text = text.replace(/\\b(they|many|several|few|all|both)\\s+has\\b/gi, '$1 have');\n    \n    return text;\n  },\n  priority: 5\n};\n\n/**\n * Punctuation cleanup modifier\n * Fixes common punctuation issues like double spaces and spacing around punctuation\n */\nexport const PunctuationCleanupModifier: Modifier = {\n  name: 'punctuationCleanup',\n  condition: (text: string) => {\n    // Look for punctuation spacing issues\n    return /\\s{2,}/.test(text) || /\\s[.!?,:;]/.test(text) || /[.!?,:;]\\S/.test(text);\n  },\n  transform: (text: string) => {\n    // Fix multiple spaces\n    text = text.replace(/\\s{2,}/g, ' ');\n    \n    // Fix space before punctuation\n    text = text.replace(/\\s([.!?,:;])/g, '$1');\n    \n    // Add space after punctuation if missing (except at end)\n    text = text.replace(/([.!?,:;])([A-Za-z])/g, '$1 $2');\n    \n    // Trim leading/trailing whitespace\n    text = text.trim();\n    \n    return text;\n  },\n  priority: 1\n};\n\n// Helper functions\n\n/**\n * Convert a singular noun to its plural form\n * @param noun - The singular noun to pluralize\n * @returns The plural form of the noun\n */\nfunction pluralize(noun: string): string {\n  const lowerNoun = noun.toLowerCase();\n  \n  // Irregular plurals mapping\n  const irregularPlurals: { [key: string]: string } = {\n    'addendum': 'addenda',\n    'aircraft': 'aircraft',\n    'alumna': 'alumnae',\n    'alumnus': 'alumni',\n    'analysis': 'analyses',\n    'antenna': 'antennae',\n    'antithesis': 'antitheses',\n    'apex': 'apices',\n    'appendix': 'appendices',\n    'axis': 'axes',\n    'bacillus': 'bacilli',\n    'bacterium': 'bacteria',\n    'basis': 'bases',\n    'beau': 'beaux',\n    'bison': 'bison',\n    'bureau': 'bureaux',\n    'cactus': 'cacti',\n    'château': 'châteaux',\n    'child': 'children',\n    'codex': 'codices',\n    'concerto': 'concerti',\n    'corpus': 'corpora',\n    'crisis': 'crises',\n    'criterion': 'criteria',\n    'curriculum': 'curricula',\n    'datum': 'data',\n    'deer': 'deer',\n    'diagnosis': 'diagnoses',\n    'die': 'dice',\n    'dwarf': 'dwarves',\n    'ellipsis': 'ellipses',\n    'erratum': 'errata',\n    'fez': 'fezzes',\n    'fish': 'fish',\n    'focus': 'foci',\n    'foot': 'feet',\n    'formula': 'formulae',\n    'fungus': 'fungi',\n    'genus': 'genera',\n    'goose': 'geese',\n    'graffito': 'graffiti',\n    'grouse': 'grouse',\n    'half': 'halves',\n    'hoof': 'hooves',\n    'hypothesis': 'hypotheses',\n    'index': 'indices',\n    'larva': 'larvae',\n    'libretto': 'libretti',\n    'loaf': 'loaves',\n    'locus': 'loci',\n    'louse': 'lice',\n    'man': 'men',\n    'matrix': 'matrices',\n    'medium': 'media',\n    'memorandum': 'memoranda',\n    'minutia': 'minutiae',\n    'moose': 'moose',\n    'mouse': 'mice',\n    'nebula': 'nebulae',\n    'nucleus': 'nuclei',\n    'oasis': 'oases',\n    'offspring': 'offspring',\n    'opus': 'opera',\n    'ovum': 'ova',\n    'ox': 'oxen',\n    'parenthesis': 'parentheses',\n    'person': 'people',\n    'phenomenon': 'phenomena',\n    'phylum': 'phyla',\n    'quiz': 'quizzes',\n    'radius': 'radii',\n    'referendum': 'referenda',\n    'salmon': 'salmon',\n    'scarf': 'scarves',\n    'self': 'selves',\n    'series': 'series',\n    'sheep': 'sheep',\n    'shrimp': 'shrimp',\n    'species': 'species',\n    'stimulus': 'stimuli',\n    'stratum': 'strata',\n    'swine': 'swine',\n    'syllabus': 'syllabi',\n    'symposium': 'symposia',\n    'synopsis': 'synopses',\n    'tableau': 'tableaux',\n    'thesis': 'theses',\n    'thief': 'thieves',\n    'tooth': 'teeth',\n    'trout': 'trout',\n    'tuna': 'tuna',\n    'vertebra': 'vertebrae',\n    'vertex': 'vertices',\n    'vita': 'vitae',\n    'vortex': 'vortices',\n    'wharf': 'wharves',\n    'wife': 'wives',\n    'wolf': 'wolves',\n    'woman': 'women'\n  };\n  \n  // Check for irregular plurals first\n  if (irregularPlurals[lowerNoun]) {\n    const irregularPlural = irregularPlurals[lowerNoun];\n    // Preserve original case pattern\n    return preserveCase(noun, irregularPlural);\n  }\n  \n  // Apply regular pluralization rules in order of specificity\n  \n  // 1. Words ending in -s, -ss, -sh, -ch, -x, -z: add -es\n  if (/[sxz]$/.test(lowerNoun) || /[sc]h$/.test(lowerNoun)) {\n    return noun + 'es';\n  }\n  \n  // 2. Words ending in consonant + y: change y to ies\n  if (/[bcdfghjklmnpqrstvwxz]y$/i.test(lowerNoun)) {\n    return noun.slice(0, -1) + 'ies';\n  }\n  \n  // 3. Words ending in vowel + y: just add -s\n  if (/[aeiou]y$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 4. Words ending in -f or -fe: change to -ves (with exceptions)\n  if (/fe?$/i.test(lowerNoun)) {\n    // Exceptions that just add -s\n    const fExceptions = ['belief', 'chief', 'cliff', 'proof', 'roof', 'safe', 'chef', 'handkerchief'];\n    if (fExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun.replace(/fe?$/i, 'ves');\n  }\n  \n  // 5. Words ending in consonant + o: add -es (with common exceptions)\n  if (/[bcdfghjklmnpqrstvwxz]o$/i.test(lowerNoun)) {\n    // Common exceptions that just add -s\n    const oExceptions = [\n      'photo', 'piano', 'halo', 'disco', 'studio', 'radio', 'video', \n      'auto', 'memo', 'pro', 'casino', 'patio', 'portfolio', 'logo',\n      'commando', 'solo', 'soprano', 'alto', 'kimono'\n    ];\n    if (oExceptions.includes(lowerNoun)) {\n      return noun + 's';\n    }\n    return noun + 'es';\n  }\n  \n  // 6. Words ending in vowel + o: just add -s\n  if (/[aeiou]o$/i.test(lowerNoun)) {\n    return noun + 's';\n  }\n  \n  // 7. Default case: add -s\n  return noun + 's';\n}\n\n/**\n * Preserve the case pattern of the original word in the plural form\n * @param original - The original word with its case pattern\n * @param plural - The lowercase plural form\n * @returns The plural with preserved case pattern\n */\nfunction preserveCase(original: string, plural: string): string {\n  // If original is all uppercase, make plural all uppercase\n  if (original === original.toUpperCase()) {\n    return plural.toUpperCase();\n  }\n  \n  // If original starts with uppercase, capitalize the plural\n  if (original[0] === original[0].toUpperCase()) {\n    return plural.charAt(0).toUpperCase() + plural.slice(1);\n  }\n  \n  // Otherwise, return lowercase plural\n  return plural;\n}\n\n/**\n * Collection of all English modifiers for convenience\n */\nexport const AllEnglishModifiers = [\n  EnglishArticleModifier,\n  EnglishPluralizationModifier,\n  EnglishOrdinalModifier,\n  EnglishCapitalizationModifier,\n  EnglishPossessiveModifier,\n  EnglishVerbAgreementModifier,\n  PunctuationCleanupModifier\n];\n\n/**\n * Basic English modifiers (articles, pluralization, ordinals)\n */\nexport const BasicEnglishModifiers = [\n  EnglishArticleModifier,\n  EnglishPluralizationModifier,\n  EnglishOrdinalModifier\n];","/**\n * Parser for combinatorial grammar with variable expansion\n * \n * This file re-exports the core Parser class and all types for backward compatibility.\n * The actual implementation has been moved to separate files for better modularity.\n */\n\n// Re-export all types and interfaces\nexport * from './types';\n\n// Re-export the core Parser class\nexport { Parser } from './ParserCore';","/**\n * Core Parser class for combinatorial grammar with variable expansion\n * \n * This class provides a comprehensive text generation system using grammar rules\n * with variable substitution, modifiers, and multiple rule types including:\n * - Static rules: Simple string arrays\n * - Function rules: Dynamic generation using functions\n * - Weighted rules: Probability-based selection\n * - Conditional rules: Context-dependent selection\n * - Sequential rules: Ordered cycling through values\n * - Range rules: Numeric value generation\n * - Template rules: Structured text with variable substitution\n * \n * @example\n * ```typescript\n * const parser = new Parser();\n * \n * // Add basic grammar rules\n * parser.addRules({\n *   greeting: ['Hello', 'Hi', 'Hey'],\n *   name: ['Alice', 'Bob', 'Charlie'],\n *   sentence: ['%greeting% there, %name%!']\n * });\n * \n * // Generate text\n * const result = parser.parse('%sentence%');\n * // Possible output: \"Hello there, Alice!\"\n * \n * // Add weighted rules for probability control\n * parser.addWeightedRule('mood', \n *   ['happy', 'excited', 'calm'], \n *   [0.5, 0.3, 0.2]\n * );\n * \n * // Add conditional rules for context-aware generation\n * parser.addConditionalRule('response', {\n *   conditions: [\n *     {\n *       if: (ctx) => ctx.mood === 'happy',\n *       then: ['Great!', 'Wonderful!', 'Fantastic!']\n *     },\n *     {\n *       default: ['Okay', 'Sure', 'Alright']\n *     }\n *   ]\n * });\n * ```\n * \n * @since 1.0.0\n * @author Story Grammar Parser Team\n */\n\nimport {\n  Grammar,\n  Modifier,\n  ModifierContext,\n  FunctionRule,\n  WeightedRule,\n  ConditionalRule,\n  SequentialRule,\n  RangeRule,\n  TemplateRule,\n  ParseOptions,\n  ParseResult,\n  ValidationResult,\n  ParseTimingResult,\n  ParserStats,\n  ParserConfig,\n  OptimizationReport,\n  RuleAnalysis,\n  ErrorContext\n} from './types';\n\nexport class Parser {\n  /** Core static grammar rules mapping rule names to arrays of possible values */\n  private grammar: Grammar = {};\n  \n  /** Dynamic function-based rules that generate values at runtime */\n  private functionRules: Map<string, FunctionRule> = new Map();\n  \n  /** Rules with weighted probability distributions for more control over randomness */\n  private weightedRules: Map<string, WeightedRule> = new Map();\n  \n  /** Context-aware rules that select values based on current parsing state */\n  private conditionalRules: Map<string, ConditionalRule> = new Map();\n  \n  /** Rules that cycle through values in sequential order with optional looping */\n  private sequentialRules: Map<string, SequentialRule> = new Map();\n  \n  /** Numeric range rules for generating integer or floating-point values */\n  private rangeRules: Map<string, RangeRule> = new Map();\n  \n  /** Template-based rules for structured text generation with variable substitution */\n  private templateRules: Map<string, TemplateRule> = new Map();\n  \n  /** Cache of previously generated values for reference and consistency */\n  private referenceValues: Map<string, string> = new Map();\n  \n  /** Text transformation modifiers applied after variable expansion */\n  private modifiers: Map<string, Modifier> = new Map();\n  \n  /** Regular expression pattern for matching variables in %variable% format */\n  private variablePattern = /%([^%]+)%/g;\n  \n  /** Maximum recursion depth to prevent infinite loops in circular references */\n  private maxDepth = 100;\n  \n  /** Optional seed for deterministic pseudo-random generation */\n  private randomSeed: number | null = null;\n  \n  /** Current state of the Linear Congruential Generator for seeded randomness */\n  private currentSeed: number = 0;\n  \n  /** Current parsing context containing generated variable values */\n  private currentContext: { [key: string]: string } = {};\n\n  /**\n   * Add a static rule to the grammar\n   * \n   * Static rules are the most basic rule type, containing arrays of possible values\n   * that can be randomly selected during text generation.\n   * \n   * @param key - The unique identifier for this rule (must be non-empty string)\n   * @param values - Array of possible string values for this rule\n   * \n   * @throws {Error} If key is not a non-empty string\n   * @throws {Error} If values is not an array\n   * \n   * @example\n   * ```typescript\n   * parser.addRule('color', ['red', 'blue', 'green']);\n   * parser.addRule('animal', ['cat', 'dog', 'bird']);\n   * parser.addRule('sentence', ['The %color% %animal% is sleeping.']);\n   * \n   * const result = parser.parse('%sentence%');\n   * // Possible: \"The blue cat is sleeping.\"\n   * ```\n   * \n   * @since 1.0.0\n   */\n  public addRule(key: string, values: string[]): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!Array.isArray(values)) {\n      throw new Error('Values must be an array');\n    }\n    this.grammar[key] = [...values]; // Create a copy to avoid external mutation\n  }\n\n  /**\n   * Add multiple rules to the grammar\n   * @param rules - Object containing key-value pairs of rules\n   */\n  public addRules(rules: Grammar): void {\n    for (const [key, values] of Object.entries(rules)) {\n      this.addRule(key, values);\n    }\n  }\n\n  /**\n   * Add a function rule to the grammar\n   * @param key - The key to define\n   * @param fn - Function that returns an array of possible values\n   */\n  public addFunctionRule(key: string, fn: FunctionRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (typeof fn !== 'function') {\n      throw new Error('Value must be a function');\n    }\n    this.functionRules.set(key, fn);\n  }\n\n  /**\n   * Remove a function rule\n   * @param key - Rule key to remove\n   * @returns True if the rule was removed, false if it didn't exist\n   */\n  public removeFunctionRule(key: string): boolean {\n    return this.functionRules.delete(key);\n  }\n\n  /**\n   * Check if a function rule exists\n   * @param key - Rule key to check\n   * @returns True if the function rule exists\n   */\n  public hasFunctionRule(key: string): boolean {\n    return this.functionRules.has(key);\n  }\n\n  /**\n   * Clear all function rules\n   */\n  public clearFunctionRules(): void {\n    this.functionRules.clear();\n  }\n\n  /**\n   * Add a weighted rule for probability-controlled random selection\n   * \n   * Weighted rules allow you to control the probability of each value being selected.\n   * This is useful for creating more realistic or biased text generation where some\n   * options should appear more frequently than others.\n   * \n   * @param key - The unique identifier for this rule\n   * @param values - Array of possible string values\n   * @param weights - Array of probability weights (must sum to exactly 1.0)\n   * \n   * @throws {Error} If key is not a non-empty string\n   * @throws {Error} If values or weights are not arrays\n   * @throws {Error} If arrays have different lengths\n   * @throws {Error} If any weight is negative\n   * @throws {Error} If weights don't sum to 1.0 (within 0.0001 tolerance)\n   * \n   * @example\n   * ```typescript\n   * // Common colors appear more frequently than rare ones\n   * parser.addWeightedRule('rarity', \n   *   ['common', 'uncommon', 'rare', 'legendary'],\n   *   [0.6, 0.25, 0.12, 0.03]\n   * );\n   * \n   * // Weather patterns with seasonal bias\n   * parser.addWeightedRule('weather',\n   *   ['sunny', 'cloudy', 'rainy', 'stormy'],\n   *   [0.5, 0.3, 0.15, 0.05]\n   * );\n   * ```\n   * \n   * @since 1.0.0\n   */\n  public addWeightedRule(key: string, values: string[], weights: number[]): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!Array.isArray(values)) {\n      throw new Error('Values must be an array');\n    }\n    if (!Array.isArray(weights)) {\n      throw new Error('Weights must be an array');\n    }\n    if (values.length !== weights.length) {\n      throw new Error('Values and weights arrays must have the same length');\n    }\n    if (values.length === 0) {\n      throw new Error('Values array cannot be empty');\n    }\n    \n    // Validate weights\n    for (const weight of weights) {\n      if (typeof weight !== 'number' || weight < 0) {\n        throw new Error('All weights must be non-negative numbers');\n      }\n    }\n    \n    const weightSum = weights.reduce((sum, weight) => sum + weight, 0);\n    if (Math.abs(weightSum - 1.0) > 0.0001) {\n      throw new Error(`Weights must sum to 1.0, but sum to ${weightSum}`);\n    }\n    \n    // Calculate cumulative weights for efficient sampling\n    const cumulativeWeights: number[] = [];\n    let cumSum = 0;\n    for (const weight of weights) {\n      cumSum += weight;\n      cumulativeWeights.push(cumSum);\n    }\n    \n    this.weightedRules.set(key, {\n      values: [...values],\n      weights: [...weights],\n      cumulativeWeights\n    });\n  }\n\n  /**\n   * Remove a weighted rule\n   * @param key - Rule key to remove\n   * @returns True if the rule was removed, false if it didn't exist\n   */\n  public removeWeightedRule(key: string): boolean {\n    return this.weightedRules.delete(key);\n  }\n\n  /**\n   * Check if a weighted rule exists\n   * @param key - Rule key to check\n   * @returns True if the weighted rule exists\n   */\n  public hasWeightedRule(key: string): boolean {\n    return this.weightedRules.has(key);\n  }\n\n  /**\n   * Clear all weighted rules\n   */\n  public clearWeightedRules(): void {\n    this.weightedRules.clear();\n  }\n\n  /**\n   * Add a context-aware conditional rule for dynamic value selection\n   * \n   * Conditional rules evaluate the current parsing context to select appropriate values.\n   * This enables sophisticated text generation that adapts based on previously generated\n   * content, creating more coherent and contextually appropriate output.\n   * \n   * @param key - The unique identifier for this rule\n   * @param rule - Configuration object containing conditions array\n   * @param rule.conditions - Array of condition objects with if/then logic or default values\n   * \n   * @throws {Error} If key is not a non-empty string\n   * @throws {Error} If rule doesn't have a conditions array\n   * @throws {Error} If conditions array is empty\n   * @throws {Error} If multiple default conditions are provided\n   * @throws {Error} If condition structure is invalid\n   * \n   * @example\n   * ```typescript\n   * // Character dialogue based on personality\n   * parser.addRule('personality', ['brave', 'cautious', 'aggressive']);\n   * \n   * parser.addConditionalRule('dialogue', {\n   *   conditions: [\n   *     {\n   *       if: (ctx) => ctx.personality === 'brave',\n   *       then: ['Let\\'s charge ahead!', 'I\\'ll lead the way!']\n   *     },\n   *     {\n   *       if: (ctx) => ctx.personality === 'cautious',\n   *       then: ['Let\\'s think about this...', 'Maybe we should be careful.']\n   *     },\n   *     {\n   *       default: ['What do you think?', 'I\\'m not sure.']\n   *     }\n   *   ]\n   * });\n   * \n   * // Time-based greetings\n   * parser.addConditionalRule('greeting', {\n   *   conditions: [\n   *     {\n   *       if: (ctx) => new Date().getHours() < 12,\n   *       then: ['Good morning!', 'Morning!']\n   *     },\n   *     {\n   *       if: (ctx) => new Date().getHours() >= 18,\n   *       then: ['Good evening!', 'Evening!']\n   *     },\n   *     {\n   *       default: ['Hello!', 'Hi there!']\n   *     }\n   *   ]\n   * });\n   * ```\n   * \n   * @since 1.0.0\n   */\n  public addConditionalRule(key: string, rule: ConditionalRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!rule || !Array.isArray(rule.conditions)) {\n      throw new Error('Rule must have a conditions array');\n    }\n    if (rule.conditions.length === 0) {\n      throw new Error('Conditions array cannot be empty');\n    }\n\n    // Validate conditions\n    let hasDefault = false;\n    for (const condition of rule.conditions) {\n      if ('default' in condition) {\n        if (hasDefault) {\n          throw new Error('Only one default condition is allowed');\n        }\n        hasDefault = true;\n        if (!Array.isArray(condition.default)) {\n          throw new Error('Default condition must have an array of values');\n        }\n      } else if ('if' in condition && 'then' in condition) {\n        if (typeof condition.if !== 'function') {\n          throw new Error('Condition \"if\" must be a function');\n        }\n        if (!Array.isArray(condition.then)) {\n          throw new Error('Condition \"then\" must be an array of values');\n        }\n      } else {\n        throw new Error('Each condition must have either \"if/then\" or \"default\"');\n      }\n    }\n\n    this.conditionalRules.set(key, {\n      conditions: rule.conditions.map(c => ({ ...c }))\n    });\n  }\n\n  /**\n   * Add a sequential rule for ordered value progression\n   * \n   * Sequential rules provide deterministic, ordered selection of values rather than\n   * random selection. They can either cycle back to the beginning (loop) or stick\n   * to the last value when reaching the end.\n   * \n   * @param key - The unique identifier for this rule\n   * @param values - Array of values to cycle through in order\n   * @param options - Configuration object\n   * @param options.cycle - If true, loops back to start; if false, repeats last value\n   * \n   * @throws {Error} If key is not a non-empty string\n   * @throws {Error} If values is not a non-empty array\n   * \n   * @example\n   * ```typescript\n   * // Days of the week that cycle\n   * parser.addSequentialRule('weekday', \n   *   ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n   *   { cycle: true }\n   * );\n   * \n   * // Story progression that doesn't repeat\n   * parser.addSequentialRule('chapter', \n   *   ['Introduction', 'Rising Action', 'Climax', 'Resolution'],\n   *   { cycle: false }\n   * );\n   * \n   * // Usage\n   * console.log(parser.parse('%weekday%')); // \"Monday\"\n   * console.log(parser.parse('%weekday%')); // \"Tuesday\"\n   * console.log(parser.parse('%weekday%')); // \"Wednesday\"\n   * \n   * // Reset to beginning if needed\n   * parser.resetSequentialRule('weekday');\n   * ```\n   * \n   * @since 1.0.0\n   */\n  public addSequentialRule(key: string, values: string[], options: { cycle: boolean } = { cycle: true }): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!Array.isArray(values) || values.length === 0) {\n      throw new Error('Values must be a non-empty array');\n    }\n\n    this.sequentialRules.set(key, {\n      values: [...values],\n      index: 0,\n      cycle: options.cycle\n    });\n  }\n\n  /**\n   * Add a numeric range rule for generating values within specified bounds\n   * \n   * Range rules generate numeric values within defined minimum and maximum bounds.\n   * They support both continuous (float) and discrete (integer) generation, with\n   * optional step sizes for creating specific numeric sequences.\n   * \n   * @param key - The unique identifier for this rule\n   * @param config - Range configuration object\n   * @param config.min - Minimum value (inclusive)\n   * @param config.max - Maximum value (exclusive for continuous, inclusive for stepped)\n   * @param config.step - Optional step size for discrete intervals\n   * @param config.type - Number type: 'integer' for whole numbers, 'float' for decimals\n   * \n   * @throws {Error} If key is not a non-empty string\n   * @throws {Error} If min or max are not numbers\n   * @throws {Error} If min >= max\n   * @throws {Error} If step is not a positive number\n   * @throws {Error} If type is not 'integer' or 'float'\n   * \n   * @example\n   * ```typescript\n   * // Random ages for characters\n   * parser.addRangeRule('age', {\n   *   min: 18,\n   *   max: 65,\n   *   type: 'integer'\n   * });\n   * \n   * // Temperature with decimal precision\n   * parser.addRangeRule('temperature', {\n   *   min: -10.0,\n   *   max: 35.0,\n   *   type: 'float'\n   * });\n   * \n   * // Dice rolls with step\n   * parser.addRangeRule('d6', {\n   *   min: 1,\n   *   max: 6,\n   *   step: 1,\n   *   type: 'integer'\n   * });\n   * \n   * // Usage in text\n   * parser.addRule('character', ['%name% is %age% years old']);\n   * // Output: \"Alice is 34 years old\"\n   * ```\n   * \n   * @since 1.0.0\n   */\n  public addRangeRule(key: string, config: { min: number; max: number; step?: number; type: 'integer' | 'float' }): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (typeof config.min !== 'number' || typeof config.max !== 'number') {\n      throw new Error('Min and max must be numbers');\n    }\n    if (config.min >= config.max) {\n      throw new Error('Min must be less than max');\n    }\n    if (config.step !== undefined && (typeof config.step !== 'number' || config.step <= 0)) {\n      throw new Error('Step must be a positive number');\n    }\n    if (!['integer', 'float'].includes(config.type)) {\n      throw new Error('Type must be \"integer\" or \"float\"');\n    }\n\n    this.rangeRules.set(key, {\n      min: config.min,\n      max: config.max,\n      step: config.step,\n      type: config.type\n    });\n  }\n\n  /**\n   * Add a template rule for structured text generation with embedded variables\n   * \n   * Template rules define reusable text structures with embedded variable placeholders.\n   * They provide their own variable scope, making them ideal for creating consistent\n   * formats like addresses, names, or structured data without affecting global context.\n   * \n   * @param key - The unique identifier for this rule\n   * @param rule - Template configuration object\n   * @param rule.template - Template string with %variable% placeholders\n   * @param rule.variables - Object mapping variable names to arrays of possible values\n   * \n   * @throws {Error} If key is not a non-empty string\n   * @throws {Error} If template is not a non-empty string\n   * @throws {Error} If variables is not an object\n   * @throws {Error} If template references undefined variables\n   * @throws {Error} If any variable value is not an array\n   * \n   * @example\n   * ```typescript\n   * // Address template\n   * parser.addTemplateRule('address', {\n   *   template: '%number% %street% %type%, %city%, %state% %zip%',\n   *   variables: {\n   *     number: ['123', '456', '789', '1001'],\n   *     street: ['Oak', 'Pine', 'Maple', 'Cedar'],\n   *     type: ['Street', 'Avenue', 'Boulevard', 'Lane'],\n   *     city: ['Springfield', 'Riverside', 'Franklin'],\n   *     state: ['CA', 'NY', 'TX', 'FL'],\n   *     zip: ['12345', '67890', '54321']\n   *   }\n   * });\n   * \n   * // Character name template\n   * parser.addTemplateRule('fullName', {\n   *   template: '%title% %first% %middle% %last%',\n   *   variables: {\n   *     title: ['Mr.', 'Ms.', 'Dr.', 'Prof.'],\n   *     first: ['John', 'Jane', 'Michael', 'Sarah'],\n   *     middle: ['A.', 'B.', 'C.', 'D.'],\n   *     last: ['Smith', 'Johnson', 'Williams', 'Brown']\n   *   }\n   * });\n   * \n   * // Usage\n   * console.log(parser.parse('%address%'));\n   * // \"123 Oak Street, Springfield, CA 12345\"\n   * ```\n   * \n   * @since 1.0.0\n   */\n  public addTemplateRule(key: string, rule: TemplateRule): void {\n    if (!key || typeof key !== 'string') {\n      throw new Error('Key must be a non-empty string');\n    }\n    if (!rule.template || typeof rule.template !== 'string') {\n      throw new Error('Template must be a non-empty string');\n    }\n    if (!rule.variables || typeof rule.variables !== 'object') {\n      throw new Error('Variables must be an object');\n    }\n\n    // Validate that all variables in template exist in variables object\n    const templateVars = this.findVariables(rule.template);\n    for (const variable of templateVars) {\n      if (!(variable in rule.variables)) {\n        throw new Error(`Template variable '${variable}' not found in variables object`);\n      }\n      if (!Array.isArray(rule.variables[variable])) {\n        throw new Error(`Variable '${variable}' must be an array`);\n      }\n    }\n\n    this.templateRules.set(key, {\n      template: rule.template,\n      variables: { ...rule.variables }\n    });\n  }\n\n  /**\n   * Remove a conditional rule\n   */\n  public removeConditionalRule(key: string): boolean {\n    return this.conditionalRules.delete(key);\n  }\n\n  /**\n   * Remove a sequential rule\n   */\n  public removeSequentialRule(key: string): boolean {\n    return this.sequentialRules.delete(key);\n  }\n\n  /**\n   * Remove a range rule\n   */\n  public removeRangeRule(key: string): boolean {\n    return this.rangeRules.delete(key);\n  }\n\n  /**\n   * Remove a template rule\n   */\n  public removeTemplateRule(key: string): boolean {\n    return this.templateRules.delete(key);\n  }\n\n  /**\n   * Check if a conditional rule exists\n   */\n  public hasConditionalRule(key: string): boolean {\n    return this.conditionalRules.has(key);\n  }\n\n  /**\n   * Check if a sequential rule exists\n   */\n  public hasSequentialRule(key: string): boolean {\n    return this.sequentialRules.has(key);\n  }\n\n  /**\n   * Check if a range rule exists\n   */\n  public hasRangeRule(key: string): boolean {\n    return this.rangeRules.has(key);\n  }\n\n  /**\n   * Check if a template rule exists\n   */\n  public hasTemplateRule(key: string): boolean {\n    return this.templateRules.has(key);\n  }\n\n  /**\n   * Clear all conditional rules\n   */\n  public clearConditionalRules(): void {\n    this.conditionalRules.clear();\n  }\n\n  /**\n   * Clear all sequential rules\n   */\n  public clearSequentialRules(): void {\n    this.sequentialRules.clear();\n  }\n\n  /**\n   * Clear all range rules\n   */\n  public clearRangeRules(): void {\n    this.rangeRules.clear();\n  }\n\n  /**\n   * Clear all template rules\n   */\n  public clearTemplateRules(): void {\n    this.templateRules.clear();\n  }\n\n  /**\n   * Reset a sequential rule to start from the beginning\n   * @param key - The sequential rule key to reset\n   * @returns True if rule was reset, false if it doesn't exist\n   */\n  public resetSequentialRule(key: string): boolean {\n    const rule = this.sequentialRules.get(key);\n    if (rule) {\n      rule.index = 0;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Add a modifier to the grammar\n   * @param modifier - The modifier to add\n   */\n  public addModifier(modifier: Modifier): void {\n    if (!modifier || typeof modifier !== 'object') {\n      throw new Error('Modifier must be an object');\n    }\n    if (!modifier.name || typeof modifier.name !== 'string') {\n      throw new Error('Modifier must have a name');\n    }\n    if (typeof modifier.condition !== 'function') {\n      throw new Error('Modifier must have a condition function');\n    }\n    if (typeof modifier.transform !== 'function') {\n      throw new Error('Modifier must have a transform function');\n    }\n    \n    this.modifiers.set(modifier.name, {\n      ...modifier,\n      priority: modifier.priority ?? 0\n    });\n  }\n\n  /**\n   * Remove a modifier from the grammar\n   * @param name - The name of the modifier to remove\n   * @returns True if the modifier was removed, false if it didn't exist\n   */\n  public removeModifier(name: string): boolean {\n    return this.modifiers.delete(name);\n  }\n\n  /**\n   * Check if a modifier exists\n   * @param name - The name of the modifier to check\n   * @returns True if the modifier exists, false otherwise\n   */\n  public hasModifier(name: string): boolean {\n    return this.modifiers.has(name);\n  }\n\n  /**\n   * Get all modifiers\n   * @returns Array of all modifiers sorted by priority\n   */\n  public getModifiers(): Modifier[] {\n    return Array.from(this.modifiers.values()).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n  }\n\n  /**\n   * Load a modifier into the parser\n   * @param modifier - The modifier to load\n   */\n  public loadModifier(modifier: Modifier): void {\n    this.addModifier(modifier);\n  }\n\n  /**\n   * Load multiple modifiers into the parser\n   * @param modifiers - Array of modifiers to load\n   */\n  public loadModifiers(modifiers: Modifier[]): void {\n    for (const modifier of modifiers) {\n      this.addModifier(modifier);\n    }\n  }\n\n  /**\n   * Get all grammar rules\n   * @returns Copy of all grammar rules\n   */\n  public getGrammar(): Grammar {\n    const grammarCopy: Grammar = {};\n    for (const [key, values] of Object.entries(this.grammar)) {\n      grammarCopy[key] = [...values];\n    }\n    return grammarCopy;\n  }\n\n  /**\n   * Parse and expand variables in text using the configured grammar rules\n   * \n   * This is the core parsing method that processes text containing %variable% placeholders,\n   * replacing them with generated values according to the defined grammar rules. The parsing\n   * process includes variable expansion, modifier application, and context management.\n   * \n   * The parsing happens in several phases:\n   * 1. Context management (clear or preserve from previous calls)\n   * 2. Recursive variable expansion using grammar rules\n   * 3. Modifier application for text transformations\n   * \n   * @param text - Input text containing %variable% placeholders to expand\n   * @param preserveContext - If true, maintains variable values from previous parse calls;\n   *                         if false, starts with fresh context (default: false)\n   * \n   * @returns Fully expanded text with all variables replaced and modifiers applied\n   * \n   * @throws {Error} If text is not a string\n   * @throws {Error} If maximum recursion depth is exceeded (circular references)\n   * @throws {Error} If function rules throw errors during execution\n   * \n   * @example\n   * ```typescript\n   * parser.addRules({\n   *   greeting: ['Hello', 'Hi', 'Hey'],\n   *   name: ['Alice', 'Bob', 'Charlie'],\n   *   punctuation: ['!', '.', '?']\n   * });\n   * \n   * // Basic parsing\n   * const result1 = parser.parse('%greeting%, %name%%punctuation%');\n   * // Possible: \"Hi, Alice!\"\n   * \n   * // Context preservation\n   * const result2 = parser.parse('My name is %name%.');\n   * const result3 = parser.parse('Nice to meet you, %name%!', true);\n   * // result3 will use the same name as result2\n   * \n   * // Nested variables\n   * parser.addRule('sentence', ['%greeting% there, %name%!']);\n   * const result4 = parser.parse('%sentence%');\n   * // \"Hello there, Bob!\"\n   * ```\n   * \n   * @see {@link safeParse} for error-handling version\n   * @see {@link parseWithTiming} for performance monitoring\n   * @see {@link parseBatch} for multiple text processing\n   * \n   * @since 1.0.0\n   */\n  public parse(text: string, preserveContext: boolean = false): string {\n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    \n    // Clear context unless explicitly preserving it\n    if (!preserveContext) {\n      this.currentContext = {};\n      this.referenceValues.clear();\n    }\n    \n    const expanded = this.expandVariables(text, 0);\n    return this.applyModifiers(expanded, { originalText: text });\n  }\n\n  /**\n   * Parse text with performance timing\n   * @param text - The text to parse\n   * @param preserveContext - Whether to preserve context\n   * @returns Object with result and timing information\n   */\n  public parseWithTiming(text: string, preserveContext: boolean = false): ParseTimingResult {\n    const startTime = Date.now();\n    \n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    \n    // Clear context unless explicitly preserving it\n    if (!preserveContext) {\n      this.currentContext = {};\n      this.referenceValues.clear();\n    }\n    \n    const expansionStart = Date.now();\n    const expanded = this.expandVariables(text, 0);\n    const expansionEnd = Date.now();\n    \n    const modifierStart = Date.now();\n    const result = this.applyModifiers(expanded, { originalText: text });\n    const modifierEnd = Date.now();\n    \n    const totalEnd = Date.now();\n    \n    return {\n      result,\n      timing: {\n        totalMs: totalEnd - startTime,\n        expansionMs: expansionEnd - expansionStart,\n        modifierMs: modifierEnd - modifierStart\n      }\n    };\n  }\n\n  /**\n   * Recursively expand variables in text with comprehensive rule type support\n   * \n   * This private method handles the core variable expansion logic, processing %variable%\n   * placeholders and replacing them with values from the appropriate rule types. It follows\n   * a specific priority order for rule resolution and includes recursion protection.\n   * \n   * Rule Resolution Priority (first match wins):\n   * 1. Reference rules (@variable syntax) - cached previous values\n   * 2. Function rules - dynamic generation via JavaScript functions\n   * 3. Conditional rules - context-aware value selection\n   * 4. Sequential rules - ordered cycling through values\n   * 5. Range rules - numeric value generation\n   * 6. Template rules - structured text with embedded variables\n   * 7. Weighted rules - probability-based selection\n   * 8. Static rules - simple random selection from arrays\n   * \n   * @param text - Input text containing %variable% placeholders\n   * @param depth - Current recursion depth (used to prevent infinite loops)\n   * \n   * @returns Text with one level of variable expansion completed\n   * \n   * @throws {Error} If recursion depth exceeds maxDepth (prevents circular references)\n   * @throws {Error} If function rules fail during execution\n   * \n   * @private\n   * @since 1.0.0\n   */\n  private expandVariables(text: string, depth: number): string {\n    if (depth >= this.maxDepth) {\n      throw new Error('Maximum recursion depth exceeded. Check for circular references in grammar.');\n    }\n\n    // Reset the regex lastIndex to ensure proper matching\n    this.variablePattern.lastIndex = 0;\n\n    return text.replace(this.variablePattern, (match, key) => {\n      let selectedValue: string;\n      \n      // Handle reference rules first (syntax: @key)\n      if (key.startsWith('@')) {\n        const refKey = key.substring(1);\n        const refValue = this.referenceValues.get(refKey);\n        if (refValue !== undefined) {\n          return refValue;\n        }\n        return match; // Return original if reference not found\n      }\n      \n      // Check function rules\n      const functionRule = this.functionRules.get(key);\n      if (functionRule) {\n        try {\n          const values = functionRule();\n          if (!Array.isArray(values)) {\n            throw new Error(`Function rule '${key}' must return an array`);\n          }\n          if (values.length === 0) {\n            return match;\n          }\n          selectedValue = this.getRandomValue(values);\n        } catch (error) {\n          throw new Error(`Error executing function rule '${key}': ${error instanceof Error ? error.message : String(error)}`);\n        }\n      } else {\n        // Check conditional rules\n        const conditionalRule = this.conditionalRules.get(key);\n        if (conditionalRule) {\n          selectedValue = this.getConditionalValue(conditionalRule);\n        } else {\n          // Check sequential rules\n          const sequentialRule = this.sequentialRules.get(key);\n          if (sequentialRule) {\n            selectedValue = this.getSequentialValue(sequentialRule);\n          } else {\n            // Check range rules\n            const rangeRule = this.rangeRules.get(key);\n            if (rangeRule) {\n              selectedValue = this.getRangeValue(rangeRule);\n            } else {\n              // Check template rules\n              const templateRule = this.templateRules.get(key);\n              if (templateRule) {\n                selectedValue = this.getTemplateValue(templateRule);\n              } else {\n                // Check weighted rules\n                const weightedRule = this.weightedRules.get(key);\n                if (weightedRule) {\n                  selectedValue = this.getWeightedRandomValue(weightedRule);\n                } else {\n                  // Fall back to static rules\n                  const values = this.grammar[key];\n                  if (!values || values.length === 0) {\n                    // Return the original variable if no rule is found\n                    return match;\n                  }\n                  selectedValue = this.getRandomValue(values);\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      // Store value for potential reference and update context\n      this.referenceValues.set(key, selectedValue);\n      this.currentContext[key] = selectedValue;\n      \n      // Recursively expand variables in the selected value\n      return this.expandVariables(selectedValue, depth + 1);\n    });\n  }\n\n  /**\n   * Apply all applicable modifiers to text\n   * @param text - The text to modify\n   * @param context - Optional context for modifier application\n   * @returns Modified text\n   */\n  private applyModifiers(text: string, context?: ModifierContext): string {\n    let modifiedText = text;\n    \n    // Get modifiers sorted by priority (higher priority first)\n    const sortedModifiers = this.getModifiers();\n    \n    for (const modifier of sortedModifiers) {\n      if (modifier.condition(modifiedText, context)) {\n        modifiedText = modifier.transform(modifiedText, context);\n      }\n    }\n    \n    return modifiedText;\n  }\n\n  /**\n   * Get a value from a conditional rule based on current context\n   * @param conditionalRule - The conditional rule to evaluate\n   * @returns A value based on matching condition\n   */\n  private getConditionalValue(conditionalRule: ConditionalRule): string {\n    for (const condition of conditionalRule.conditions) {\n      if ('if' in condition && condition.if && condition.then) {\n        if (condition.if(this.currentContext)) {\n          return this.getRandomValue(condition.then);\n        }\n      } else if ('default' in condition && condition.default) {\n        return this.getRandomValue(condition.default);\n      }\n    }\n    throw new Error('No matching condition found and no default provided');\n  }\n\n  /**\n   * Get the next value from a sequential rule\n   * @param sequentialRule - The sequential rule to get value from\n   * @returns The next value in sequence\n   */\n  private getSequentialValue(sequentialRule: SequentialRule): string {\n    if (sequentialRule.index >= sequentialRule.values.length) {\n      if (sequentialRule.cycle) {\n        sequentialRule.index = 0;\n      } else {\n        return sequentialRule.values[sequentialRule.values.length - 1];\n      }\n    }\n    \n    const value = sequentialRule.values[sequentialRule.index];\n    sequentialRule.index++;\n    return value;\n  }\n\n  /**\n   * Generate a value from a range rule\n   * @param rangeRule - The range rule configuration\n   * @returns A value within the specified range\n   */\n  private getRangeValue(rangeRule: RangeRule): string {\n    const { min, max, step, type } = rangeRule;\n    \n    if (step !== undefined) {\n      // Generate stepped values\n      const numSteps = Math.floor((max - min) / step);\n      const stepIndex = Math.floor(this.getSeededRandom() * (numSteps + 1));\n      const value = min + (stepIndex * step);\n      return type === 'integer' ? Math.round(value).toString() : value.toString();\n    } else {\n      // Generate continuous values\n      const value = min + (this.getSeededRandom() * (max - min));\n      return type === 'integer' ? Math.floor(value).toString() : value.toString();\n    }\n  }\n\n  /**\n   * Generate a value from a template rule\n   * @param templateRule - The template rule configuration\n   * @returns A value with template variables expanded\n   */\n  private getTemplateValue(templateRule: TemplateRule): string {\n    // Create a temporary parser context for template variables\n    const tempContext = { ...this.currentContext };\n    \n    // Expand template using its own variables\n    let result = templateRule.template;\n    const templateVars = this.findVariables(result);\n    \n    for (const variable of templateVars) {\n      if (variable in templateRule.variables) {\n        const value = this.getRandomValue(templateRule.variables[variable]);\n        result = result.replace(new RegExp(`%${variable}%`, 'g'), value);\n        tempContext[variable] = value;\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Generate a seeded random number between 0 and 1\n   * Uses Linear Congruential Generator (LCG) when seed is set\n   * @returns Random number between 0 and 1\n   */\n  private getSeededRandom(): number {\n    if (this.randomSeed === null) {\n      return Math.random();\n    }\n    \n    // Linear Congruential Generator (LCG)\n    // Using parameters from Numerical Recipes: a=1664525, c=1013904223, m=2^32\n    this.currentSeed = (this.currentSeed * 1664525 + 1013904223) >>> 0;\n    return this.currentSeed / 0x100000000; // Convert to 0-1 range\n  }\n\n  /**\n   * Get a random value from an array\n   * @param values - Array of values to choose from\n   * @returns A random value from the array\n   */\n  private getRandomValue(values: string[]): string {\n    const randomIndex = Math.floor(this.getSeededRandom() * values.length);\n    return values[randomIndex];\n  }\n\n  /**\n   * Get a weighted random value from a weighted rule\n   * @param weightedRule - Weighted rule containing values and cumulative weights\n   * @returns A weighted random value\n   */\n  private getWeightedRandomValue(weightedRule: WeightedRule): string {\n    const random = this.getSeededRandom();\n    \n    // Find the first cumulative weight that is greater than our random number\n    for (let i = 0; i < weightedRule.cumulativeWeights.length; i++) {\n      if (random <= weightedRule.cumulativeWeights[i]) {\n        return weightedRule.values[i];\n      }\n    }\n    \n    // Fallback to last value (should not happen with proper weights)\n    return weightedRule.values[weightedRule.values.length - 1];\n  }\n\n  /**\n   * Check if a rule exists (any rule type)\n   * @param key - The key to check\n   * @returns True if the rule exists, false otherwise\n   */\n  public hasRule(key: string): boolean {\n    return this.functionRules.has(key) || \n           this.conditionalRules.has(key) ||\n           this.sequentialRules.has(key) ||\n           this.rangeRules.has(key) ||\n           this.templateRules.has(key) ||\n           this.weightedRules.has(key) || \n           key in this.grammar;\n  }\n\n  /**\n   * Remove a rule (any rule type)\n   * @param key - The key to remove\n   * @returns True if rule was removed, false if it didn't exist\n   */\n  public removeRule(key: string): boolean {\n    const removedFunction = this.functionRules.delete(key);\n    const removedConditional = this.conditionalRules.delete(key);\n    const removedSequential = this.sequentialRules.delete(key);\n    const removedRange = this.rangeRules.delete(key);\n    const removedTemplate = this.templateRules.delete(key);\n    const removedWeighted = this.weightedRules.delete(key);\n    const removedStatic = key in this.grammar ? (delete this.grammar[key], true) : false;\n    return removedFunction || removedConditional || removedSequential || removedRange || removedTemplate || removedWeighted || removedStatic;\n  }\n\n  /**\n   * Clear all rules (all rule types)\n   */\n  public clear(): void {\n    this.grammar = {};\n    this.functionRules.clear();\n    this.conditionalRules.clear();\n    this.sequentialRules.clear();\n    this.rangeRules.clear();\n    this.templateRules.clear();\n    this.weightedRules.clear();\n    this.referenceValues.clear();\n    this.currentContext = {};\n  }\n\n  /**\n   * Clear all modifiers\n   */\n  public clearModifiers(): void {\n    this.modifiers.clear();\n  }\n\n  /**\n   * Clear all rules and modifiers\n   */\n  public clearAll(): void {\n    this.clear();\n    this.clearModifiers();\n  }\n\n  /**\n   * Get all variable names found in a text string\n   * @param text - The text to analyze\n   * @returns Array of unique variable names found\n   */\n  public findVariables(text: string): string[] {\n    const variables: Set<string> = new Set();\n    this.variablePattern.lastIndex = 0;\n    \n    let match;\n    while ((match = this.variablePattern.exec(text)) !== null) {\n      variables.add(match[1]);\n    }\n    \n    return Array.from(variables);\n  }\n\n  /**\n   * Perform comprehensive grammar validation to detect potential issues\n   * \n   * This method analyzes the entire grammar structure to identify problems that could\n   * cause parsing failures or unexpected behavior. It checks for missing references,\n   * circular dependencies, empty rules, and provides warnings for potential issues.\n   * \n   * Validation Checks:\n   * - Missing rule references (variables that don't have corresponding rules)\n   * - Circular references (rules that reference themselves directly)\n   * - Empty rules (rules with no values or empty arrays)\n   * - Unreachable rules (rules that are never referenced by other rules)\n   * - Grammar completeness and consistency\n   * \n   * @returns Comprehensive validation results object\n   * @returns ValidationResult.isValid - Overall validation status (true if no critical errors)\n   * @returns ValidationResult.missingRules - Array of rule names that are referenced but not defined\n   * @returns ValidationResult.circularReferences - Array of rule names with direct self-references\n   * @returns ValidationResult.emptyRules - Array of rule names with no values\n   * @returns ValidationResult.unreachableRules - Array of defined rules that are never referenced\n   * @returns ValidationResult.warnings - Array of non-critical issues and suggestions\n   * \n   * @example\n   * ```typescript\n   * // Set up grammar with some issues\n   * parser.addRules({\n   *   greeting: ['Hello %name%'],     // references 'name' (missing)\n   *   recursive: ['%recursive%'],     // circular reference\n   *   empty: [],                      // empty rule\n   *   unused: ['never referenced']    // unreachable\n   * });\n   * \n   * const validation = parser.validate();\n   * console.log('Valid:', validation.isValid);  // false\n   * console.log('Missing:', validation.missingRules);  // ['name']\n   * console.log('Circular:', validation.circularReferences);  // ['recursive']\n   * console.log('Empty:', validation.emptyRules);  // ['empty']\n   * console.log('Unreachable:', validation.unreachableRules);  // ['unused']\n   * \n   * // Fix issues\n   * parser.addRule('name', ['Alice', 'Bob']);\n   * parser.removeRule('recursive');\n   * parser.removeRule('empty');\n   * \n   * const validation2 = parser.validate();\n   * console.log('Valid now:', validation2.isValid);  // true\n   * ```\n   * \n   * @see {@link safeParse} for validation integration\n   * @see {@link getHelpfulError} for error context\n   * \n   * @since 1.0.0\n   */\n  public validate(): ValidationResult {\n    const missingRules: Set<string> = new Set();\n    const circularReferences: Set<string> = new Set();\n    const emptyRules: string[] = [];\n    const referencedRules: Set<string> = new Set();\n    const warnings: string[] = [];\n\n    // Check static grammar rules\n    for (const [key, values] of Object.entries(this.grammar)) {\n      // Check for empty rules\n      if (!values || values.length === 0) {\n        emptyRules.push(key);\n        continue;\n      }\n      \n      for (const value of values) {\n        if (!value || typeof value !== 'string') {\n          warnings.push(`Rule '${key}' contains non-string value`);\n          continue;\n        }\n        \n        const variables = this.findVariables(value);\n        \n        for (const variable of variables) {\n          // Skip reference variables (@var)\n          if (variable.startsWith('@')) {\n            continue;\n          }\n          \n          referencedRules.add(variable);\n          \n          if (!this.hasRule(variable)) {\n            missingRules.add(variable);\n          }\n          \n          // Simple circular reference detection (direct self-reference)\n          if (variable === key) {\n            circularReferences.add(key);\n          }\n        }\n      }\n    }\n    \n    // Check for unreachable rules (rules that are never referenced)\n    const allRuleKeys = new Set([\n      ...Object.keys(this.grammar),\n      ...Array.from(this.functionRules.keys()),\n      ...Array.from(this.weightedRules.keys()),\n      ...Array.from(this.conditionalRules.keys()),\n      ...Array.from(this.sequentialRules.keys()),\n      ...Array.from(this.rangeRules.keys()),\n      ...Array.from(this.templateRules.keys())\n    ]);\n    \n    const unreachableRules = Array.from(allRuleKeys).filter(key => !referencedRules.has(key));\n    \n    // Additional warnings\n    if (this.modifiers.size === 0) {\n      warnings.push('No modifiers configured - consider adding English modifiers for better text quality');\n    }\n    \n    if (Object.keys(this.grammar).length === 0 && allRuleKeys.size === 0) {\n      warnings.push('No rules defined');\n    }\n\n    return {\n      isValid: missingRules.size === 0 && circularReferences.size === 0 && emptyRules.length === 0,\n      missingRules: Array.from(missingRules),\n      circularReferences: Array.from(circularReferences),\n      emptyRules,\n      unreachableRules,\n      warnings\n    };\n  }\n\n  /**\n   * Parse text with comprehensive error handling and retry logic\n   * \n   * This method provides a robust parsing interface that gracefully handles errors,\n   * validates grammar before parsing, and implements retry mechanisms for transient\n   * failures. It's the recommended method for production use where error handling\n   * is critical.\n   * \n   * Features:\n   * - Pre-parsing grammar validation (optional)\n   * - Automatic retry on recursion errors with depth reduction\n   * - Comprehensive error reporting with context\n   * - Attempt counting for debugging\n   * \n   * @param text - Input text to parse and expand\n   * @param options - Configuration options for parsing behavior\n   * @param options.preserveContext - Maintain context from previous calls (default: false)\n   * @param options.validateFirst - Run grammar validation before parsing (default: true)\n   * @param options.maxAttempts - Maximum retry attempts on recoverable errors (default: 3)\n   * \n   * @returns ParseResult object containing either success with result or failure with error details\n   * @returns ParseResult.success - Boolean indicating if parsing succeeded\n   * @returns ParseResult.result - Parsed text (only present on success)\n   * @returns ParseResult.error - Error message (only present on failure)\n   * @returns ParseResult.attempts - Number of attempts made\n   * @returns ParseResult.validation - Validation results (only present on validation failure)\n   * \n   * @example\n   * ```typescript\n   * // Basic safe parsing\n   * const result = parser.safeParse('%greeting% %name%!');\n   * if (result.success) {\n   *   console.log('Generated:', result.result);\n   * } else {\n   *   console.error('Parsing failed:', result.error);\n   * }\n   * \n   * // With custom options\n   * const result2 = parser.safeParse('%complex%', {\n   *   validateFirst: true,\n   *   maxAttempts: 5,\n   *   preserveContext: true\n   * });\n   * \n   * // Handle validation errors\n   * if (!result2.success && result2.validation) {\n   *   console.log('Missing rules:', result2.validation.missingRules);\n   *   console.log('Circular refs:', result2.validation.circularReferences);\n   * }\n   * ```\n   * \n   * @see {@link parse} for the basic parsing method\n   * @see {@link validate} for grammar validation details\n   * \n   * @since 1.0.0\n   */\n  public safeParse(text: string, options: ParseOptions = {}): ParseResult {\n    const { preserveContext = false, validateFirst = true, maxAttempts = 3 } = options;\n    \n    try {\n      // Validate if requested\n      if (validateFirst) {\n        const validation = this.validate();\n        if (!validation.isValid) {\n          return {\n            success: false,\n            error: `Validation failed: ${validation.missingRules.length} missing rules, ${validation.circularReferences.length} circular references`,\n            validation\n          };\n        }\n      }\n      \n      // Attempt parsing with retries\n      let lastError: Error | null = null;\n      for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n        try {\n          const result = this.parse(text, preserveContext);\n          return {\n            success: true,\n            result,\n            attempts: attempt\n          };\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n          \n          // If it's a recursion error, try reducing max depth temporarily\n          if (lastError.message.includes('recursion') && attempt < maxAttempts) {\n            const originalDepth = this.maxDepth;\n            this.setMaxDepth(Math.max(10, Math.floor(originalDepth / 2)));\n            try {\n              const result = this.parse(text, preserveContext);\n              this.setMaxDepth(originalDepth);\n              return {\n                success: true,\n                result,\n                attempts: attempt\n              };\n            } catch {\n              this.setMaxDepth(originalDepth);\n            }\n          }\n        }\n      }\n      \n      return {\n        success: false,\n        error: lastError?.message || 'Unknown parsing error',\n        attempts: maxAttempts\n      };\n      \n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Set the maximum recursion depth for variable expansion\n   * @param depth - Maximum depth (default: 100)\n   */\n  public setMaxDepth(depth: number): void {\n    if (depth < 1) {\n      throw new Error('Max depth must be at least 1');\n    }\n    this.maxDepth = depth;\n  }\n\n  /**\n   * Get the current maximum recursion depth\n   * @returns Current maximum depth\n   */\n  public getMaxDepth(): number {\n    return this.maxDepth;\n  }\n\n  /**\n   * Configure deterministic random number generation for reproducible results\n   * \n   * Setting a random seed enables completely predictable text generation, which is\n   * essential for:\n   * - Unit testing with consistent expected outputs\n   * - Reproducible content generation for version control\n   * - Debugging grammar issues with consistent test cases\n   * - A/B testing with controlled randomization\n   * \n   * Implementation Details:\n   * - Uses Linear Congruential Generator (LCG) algorithm\n   * - Parameters from Numerical Recipes: a=1664525, c=1013904223, m=2^32\n   * - Provides good statistical properties for text generation use cases\n   * - Seed is converted to 32-bit unsigned integer for consistency\n   * \n   * @param seed - Integer seed value (negative values converted to positive)\n   *               Will be converted to 32-bit unsigned integer for internal use\n   * \n   * @throws {Error} If seed is not an integer number\n   * \n   * @example\n   * ```typescript\n   * parser.addRules({\n   *   color: ['red', 'blue', 'green', 'yellow'],\n   *   animal: ['cat', 'dog', 'bird', 'fish']\n   * });\n   * \n   * // Set seed for reproducible results\n   * parser.setRandomSeed(12345);\n   * const result1 = parser.parse('%color% %animal%');\n   * \n   * // Reset to same seed\n   * parser.setRandomSeed(12345);\n   * const result2 = parser.parse('%color% %animal%');\n   * \n   * console.log(result1 === result2); // true - same result\n   * \n   * // Different seed produces different results\n   * parser.setRandomSeed(54321);\n   * const result3 = parser.parse('%color% %animal%');\n   * console.log(result1 === result3); // false - different result\n   * \n   * // Use in testing\n   * describe('Grammar Tests', () => {\n   *   beforeEach(() => {\n   *     parser.setRandomSeed(42); // Consistent test environment\n   *   });\n   *   \n   *   it('should generate expected greeting', () => {\n   *     expect(parser.parse('%greeting%')).toBe('Hello'); // Always passes\n   *   });\n   * });\n   * ```\n   * \n   * @see {@link clearRandomSeed} to return to non-deterministic behavior\n   * @see {@link getRandomSeed} to check current seed value\n   * @see {@link generateVariations} for seeded variation generation\n   * \n   * @since 1.0.0\n   */\n  public setRandomSeed(seed: number): void {\n    if (typeof seed !== 'number' || !Number.isInteger(seed)) {\n      throw new Error('Seed must be an integer');\n    }\n    // Convert to 32-bit unsigned integer\n    this.randomSeed = Math.abs(seed) >>> 0;\n    this.currentSeed = this.randomSeed;\n  }\n\n  /**\n   * Clear the random seed and return to using Math.random()\n   */\n  public clearRandomSeed(): void {\n    this.randomSeed = null;\n    this.currentSeed = 0;\n  }\n\n  /**\n   * Get the current random seed, if any\n   * @returns Current seed or null if using Math.random()\n   */\n  public getRandomSeed(): number | null {\n    return this.randomSeed;\n  }\n\n  /**\n   * Clear all reference values and reset context\n   * Useful for starting fresh generation without clearing rules\n   */\n  public clearReferences(): void {\n    this.referenceValues.clear();\n    this.currentContext = {};\n  }\n\n  /**\n   * Get the current context of generated values\n   * @returns Copy of current context\n   */\n  public getContext(): { [key: string]: string } {\n    return { ...this.currentContext };\n  }\n\n  /**\n   * Efficiently process multiple texts with optimized context management\n   * \n   * Batch processing is more efficient than individual parse() calls because it:\n   * - Minimizes context switching overhead\n   * - Enables smart context preservation across related texts\n   * - Reduces function call overhead for large datasets\n   * - Maintains consistency in multi-text scenarios\n   * \n   * Context Management:\n   * - First text always starts with fresh context\n   * - Subsequent texts preserve or reset context based on preserveContext parameter\n   * - Useful for generating coherent multi-part content (stories, conversations)\n   * \n   * @param texts - Array of input texts containing variables to expand\n   * @param preserveContext - If true, maintains variable values across texts;\n   *                         if false, each text starts with fresh context (default: true)\n   * \n   * @returns Array of parsed texts in the same order as input\n   * \n   * @throws {Error} If texts is not an array\n   * @throws {Error} If any parsing errors occur (errors include text index for debugging)\n   * \n   * @example\n   * ```typescript\n   * parser.addRules({\n   *   character: ['Alice', 'Bob', 'Charlie'],\n   *   action: ['walked', 'ran', 'jumped'],\n   *   location: ['forest', 'beach', 'city']\n   * });\n   * \n   * // Generate coherent story with consistent character\n   * const storyParts = [\n   *   '%character% %action% through the %location%.',\n   *   'Then %character% stopped to rest.',\n   *   'Finally, %character% continued the journey.'\n   * ];\n   * \n   * const coherentStory = parser.parseBatch(storyParts, true);\n   * console.log(coherentStory.join(' '));\n   * // \"Alice walked through the forest. Then Alice stopped to rest. Finally, Alice continued the journey.\"\n   * \n   * // Generate independent sentences\n   * const separateSentences = parser.parseBatch(storyParts, false);\n   * // Each sentence might use different character names\n   * \n   * // Process large datasets efficiently\n   * const templates = Array(1000).fill('%greeting% %name%, welcome to %location%!');\n   * const results = parser.parseBatch(templates, false);\n   * console.log(`Processed ${results.length} templates`);\n   * ```\n   * \n   * @see {@link parse} for single text processing\n   * @see {@link generateVariations} for multiple variations of same text\n   * \n   * @since 1.0.0\n   */\n  public parseBatch(texts: string[], preserveContext: boolean = true): string[] {\n    if (!Array.isArray(texts)) {\n      throw new Error('Texts must be an array');\n    }\n    \n    const results: string[] = [];\n    for (let i = 0; i < texts.length; i++) {\n      const shouldPreserve = preserveContext && i > 0;\n      results.push(this.parse(texts[i], shouldPreserve));\n    }\n    \n    return results;\n  }\n\n  /**\n   * Generate multiple unique variations of text for testing and content creation\n   * \n   * This method is particularly useful for:\n   * - Testing grammar coverage and variety\n   * - Generating content options for user selection\n   * - Creating reproducible test datasets\n   * - Exploring the full range of possible outputs\n   * \n   * The method temporarily manages random seeding to ensure variation diversity\n   * while preserving the parser's original random state after completion.\n   * \n   * @param text - Input text template containing variables to expand\n   * @param count - Number of different variations to generate (must be positive integer)\n   * @param seed - Optional base seed for reproducible results;\n   *               each variation uses seed + iteration for deterministic diversity\n   * \n   * @returns Array of generated text variations\n   * \n   * @throws {Error} If text is not a string\n   * @throws {Error} If count is not a positive integer\n   * \n   * @example\n   * ```typescript\n   * parser.addRules({\n   *   greeting: ['Hello', 'Hi', 'Hey', 'Greetings'],\n   *   name: ['Alice', 'Bob', 'Charlie', 'Diana'],\n   *   punctuation: ['!', '.', '?']\n   * });\n   * \n   * // Generate random variations\n   * const variations = parser.generateVariations('%greeting% %name%%punctuation%', 5);\n   * console.log(variations);\n   * // Possible output:\n   * // ['Hi Alice!', 'Hello Bob.', 'Hey Charlie?', 'Greetings Diana!', 'Hello Alice.']\n   * \n   * // Generate reproducible variations for testing\n   * const testVariations = parser.generateVariations('%greeting% %name%', 3, 12345);\n   * console.log(testVariations);\n   * // Always produces the same 3 variations when seed=12345\n   * \n   * // Use for A/B testing content\n   * const headlines = parser.generateVariations('%adjective% %product% for %audience%', 10);\n   * headlines.forEach((headline, i) => {\n   *   console.log(`Option ${i + 1}: ${headline}`);\n   * });\n   * ```\n   * \n   * @see {@link setRandomSeed} for controlling randomness\n   * @see {@link parseBatch} for processing multiple different texts\n   * \n   * @since 1.0.0\n   */\n  public generateVariations(text: string, count: number, seed?: number): string[] {\n    if (typeof text !== 'string') {\n      throw new Error('Text must be a string');\n    }\n    if (!Number.isInteger(count) || count < 1) {\n      throw new Error('Count must be a positive integer');\n    }\n    \n    const originalSeed = this.getRandomSeed();\n    const variations: string[] = [];\n    \n    try {\n      for (let i = 0; i < count; i++) {\n        if (seed !== undefined) {\n          this.setRandomSeed(seed + i);\n        }\n        variations.push(this.parse(text, false));\n      }\n    } finally {\n      // Restore original seed state\n      if (originalSeed !== null) {\n        this.setRandomSeed(originalSeed);\n      } else {\n        this.clearRandomSeed();\n      }\n    }\n    \n    return variations;\n  }\n\n  /**\n   * Get comprehensive performance statistics and configuration metrics\n   * \n   * This method provides a complete overview of the parser's current state,\n   * including rule counts by type, configuration settings, and performance-relevant\n   * information. Useful for monitoring, debugging, and optimization analysis.\n   * \n   * Statistics Categories:\n   * - Rule counts: Total rules and breakdown by type\n   * - Configuration: Current parser settings and limits\n   * - State information: Random seed usage, context state\n   * \n   * @returns Complete parser statistics object\n   * @returns ParserStats.totalRules - Total number of rules across all types\n   * @returns ParserStats.rulesByType - Breakdown of rule counts by type\n   * @returns ParserStats.rulesByType.static - Number of basic static rules\n   * @returns ParserStats.rulesByType.function - Number of dynamic function rules\n   * @returns ParserStats.rulesByType.weighted - Number of probability-weighted rules\n   * @returns ParserStats.rulesByType.conditional - Number of context-aware rules\n   * @returns ParserStats.rulesByType.sequential - Number of ordered cycling rules\n   * @returns ParserStats.rulesByType.range - Number of numeric range rules\n   * @returns ParserStats.rulesByType.template - Number of structured template rules\n   * @returns ParserStats.totalModifiers - Number of text transformation modifiers\n   * @returns ParserStats.maxDepth - Current maximum recursion depth setting\n   * @returns ParserStats.hasRandomSeed - Whether deterministic seed is configured\n   * \n   * @example\n   * ```typescript\n   * const stats = parser.getStats();\n   * \n   * console.log(`Total rules: ${stats.totalRules}`);\n   * console.log('Rule breakdown:');\n   * console.log(` - Static: ${stats.rulesByType.static}`);\n   * console.log(` - Function: ${stats.rulesByType.function}`);\n   * console.log(` - Weighted: ${stats.rulesByType.weighted}`);\n   * console.log(` - Conditional: ${stats.rulesByType.conditional}`);\n   * console.log(` - Sequential: ${stats.rulesByType.sequential}`);\n   * console.log(` - Range: ${stats.rulesByType.range}`);\n   * console.log(` - Template: ${stats.rulesByType.template}`);\n   * \n   * console.log(`Modifiers: ${stats.totalModifiers}`);\n   * console.log(`Max depth: ${stats.maxDepth}`);\n   * console.log(`Seeded random: ${stats.hasRandomSeed}`);\n   * \n   * // Performance monitoring\n   * if (stats.totalRules > 1000) {\n   *   console.warn('Large grammar detected - consider optimization');\n   * }\n   * \n   * if (stats.maxDepth > 50) {\n   *   console.warn('High recursion limit - may impact performance');\n   * }\n   * ```\n   * \n   * @see {@link analyzeRules} for complexity analysis\n   * @see {@link optimize} for performance optimization\n   * \n   * @since 1.0.0\n   */\n  public getStats(): ParserStats {\n    return {\n      totalRules: Object.keys(this.grammar).length + \n                  this.functionRules.size + \n                  this.weightedRules.size + \n                  this.conditionalRules.size + \n                  this.sequentialRules.size + \n                  this.rangeRules.size + \n                  this.templateRules.size,\n      rulesByType: {\n        static: Object.keys(this.grammar).length,\n        function: this.functionRules.size,\n        weighted: this.weightedRules.size,\n        conditional: this.conditionalRules.size,\n        sequential: this.sequentialRules.size,\n        range: this.rangeRules.size,\n        template: this.templateRules.size\n      },\n      totalModifiers: this.modifiers.size,\n      maxDepth: this.maxDepth,\n      hasRandomSeed: this.randomSeed !== null\n    };\n  }\n\n  /**\n   * Export the parser configuration as JSON\n   * @returns Serializable parser configuration\n   */\n  public exportConfig(): ParserConfig {\n    return {\n      grammar: this.getGrammar(),\n      modifiers: Array.from(this.modifiers.keys()),\n      settings: {\n        maxDepth: this.maxDepth,\n        randomSeed: this.randomSeed\n      }\n    };\n  }\n\n  /**\n   * Create a lightweight copy of the parser for parallel processing or experimentation\n   * \n   * This method creates a new Parser instance with the same basic configuration but\n   * independent state. It's useful for:\n   * - Creating isolated parser instances for different contexts\n   * - Experimenting with modifications without affecting the original\n   * - Parallel processing with separate parser states\n   * - Creating template parsers for different use cases\n   * \n   * What Gets Copied:\n   * - Static grammar rules (complete copy)\n   * - Parser settings (maxDepth, randomSeed)\n   * - Basic configuration\n   * \n   * What Doesn't Get Copied (Limitations):\n   * - Function rules (contain closures that can't be serialized)\n   * - Weighted rules (contain complex state)\n   * - Conditional rules (contain function references)\n   * - Sequential rules (contain mutable state)\n   * - Range rules (contain configuration objects)\n   * - Template rules (contain complex nested structures)\n   * - Modifiers (may contain function references)\n   * - Current parsing context and reference values\n   * \n   * @returns New Parser instance with copied static rules and settings\n   * \n   * @example\n   * ```typescript\n   * // Set up base parser\n   * const baseParser = new Parser();\n   * baseParser.addRules({\n   *   greeting: ['Hello', 'Hi', 'Hey'],\n   *   name: ['Alice', 'Bob', 'Charlie']\n   * });\n   * baseParser.setMaxDepth(50);\n   * baseParser.setRandomSeed(12345);\n   * \n   * // Create independent clone\n   * const clonedParser = baseParser.clone();\n   * \n   * // Modify clone without affecting original\n   * clonedParser.addRule('greeting', ['Greetings', 'Salutations']);\n   * clonedParser.setMaxDepth(25);\n   * \n   * // Original unchanged\n   * console.log(baseParser.getStats().maxDepth); // 50\n   * console.log(clonedParser.getStats().maxDepth); // 25\n   * \n   * // Use for parallel processing\n   * const workers = [];\n   * for (let i = 0; i < 4; i++) {\n   *   const workerParser = baseParser.clone();\n   *   workerParser.setRandomSeed(i * 1000); // Different seed per worker\n   *   workers.push(workerParser);\n   * }\n   * ```\n   * \n   * @remarks Function rules and other complex rule types are not cloned due to serialization limitations\n   * @see {@link exportConfig} for full serialization\n   * \n   * @since 1.0.0\n   */\n  public clone(): Parser {\n    const cloned = new Parser();\n    \n    // Copy static grammar\n    cloned.addRules(this.getGrammar());\n    \n    // Copy settings\n    cloned.setMaxDepth(this.maxDepth);\n    if (this.randomSeed !== null) {\n      cloned.setRandomSeed(this.randomSeed);\n    }\n    \n    // Note: Function rules, weighted rules, etc. are not cloned\n    // as they may contain closures that can't be serialized\n    \n    return cloned;\n  }\n\n  /**\n   * Optimize the parser for better performance\n   * Currently just validates and reports potential issues\n   * @returns Optimization report\n   */\n  public optimize(): OptimizationReport {\n    const warnings: string[] = [];\n    const suggestions: string[] = [];\n    \n    // Check for potential performance issues\n    const stats = this.getStats();\n    \n    if (stats.totalRules > 1000) {\n      warnings.push(`Large number of rules (${stats.totalRules}). Consider grouping related rules.`);\n    }\n    \n    if (stats.totalModifiers > 10) {\n      warnings.push(`Many modifiers (${stats.totalModifiers}). High-priority modifiers run first.`);\n    }\n    \n    if (stats.maxDepth > 20) {\n      suggestions.push('Consider reducing max depth for better performance.');\n    }\n    \n    // Check for unused rules (rules that don't reference other rules)\n    const allVariables = new Set<string>();\n    for (const values of Object.values(this.grammar)) {\n      for (const value of values) {\n        const vars = this.findVariables(value);\n        vars.forEach(v => allVariables.add(v));\n      }\n    }\n    \n    const unusedRules = Object.keys(this.grammar).filter(key => !allVariables.has(key));\n    if (unusedRules.length > 0) {\n      suggestions.push(`Consider removing unused rules: ${unusedRules.slice(0, 5).join(', ')}${unusedRules.length > 5 ? '...' : ''}`);\n    }\n    \n    return {\n      warnings,\n      suggestions,\n      optimized: warnings.length === 0 && suggestions.length === 0\n    };\n  }\n\n  /**\n   * Analyze grammar complexity, performance characteristics, and usage patterns\n   * \n   * This method provides insights into the complexity and structure of your grammar\n   * rules, helping identify performance bottlenecks, overly complex rules, and\n   * optimization opportunities. It calculates complexity scores based on variable\n   * usage, rule depth, and interconnectedness.\n   * \n   * Complexity Factors:\n   * - Number of variables referenced per rule\n   * - Depth of rule nesting (how many levels of references)\n   * - Length and complexity of rule values\n   * - Type-specific complexity (function rules = 5, weighted rules = values * 2, etc.)\n   * \n   * Analysis Thresholds:\n   * - Total complexity > 100: Suggests grammar simplification\n   * - Average depth > 5: May impact parsing performance\n   * - Rule count > 50: Consider organizing into groups\n   * \n   * @param ruleName - Optional specific rule name to analyze in detail;\n   *                   if provided, returns detailed analysis for that rule only\n   * \n   * @returns Comprehensive analysis results\n   * @returns RuleAnalysis.totalComplexity - Sum of all rule complexity scores\n   * @returns RuleAnalysis.averageDepth - Average nesting depth across all rules\n   * @returns RuleAnalysis.mostComplex - Array of most complex rules with scores\n   * @returns RuleAnalysis.suggestions - Array of optimization recommendations\n   * @returns RuleAnalysis.ruleDetails - Detailed analysis (only when ruleName specified)\n   * \n   * @example\n   * ```typescript\n   * // Analyze entire grammar\n   * const analysis = parser.analyzeRules();\n   * console.log('Total complexity:', analysis.totalComplexity);\n   * console.log('Average depth:', analysis.averageDepth);\n   * console.log('Most complex:', analysis.mostComplex);\n   * \n   * // Check for optimization suggestions\n   * if (analysis.suggestions.length > 0) {\n   *   console.log('Suggestions:');\n   *   analysis.suggestions.forEach(suggestion => {\n   *     console.log(' -', suggestion);\n   *   });\n   * }\n   * \n   * // Analyze specific rule\n   * const ruleAnalysis = parser.analyzeRules('complexRule');\n   * if (ruleAnalysis.ruleDetails) {\n   *   console.log('Rule type:', ruleAnalysis.ruleDetails.type);\n   *   console.log('Complexity:', ruleAnalysis.ruleDetails.complexity);\n   *   console.log('Variables:', ruleAnalysis.ruleDetails.variables);\n   *   console.log('Depth:', ruleAnalysis.ruleDetails.depth);\n   * }\n   * ```\n   * \n   * @see {@link optimize} for automated optimization\n   * @see {@link getStats} for performance statistics\n   * \n   * @since 1.0.0\n   */\n  public analyzeRules(ruleName?: string): RuleAnalysis {\n    const suggestions: string[] = [];\n    const complexityScores: Array<{ name: string; complexity: number; type: string }> = [];\n    \n    // Analyze static rules\n    for (const [key, values] of Object.entries(this.grammar)) {\n      if (ruleName && key !== ruleName) continue;\n      \n      let complexity = 0;\n      const allVariables = new Set<string>();\n      \n      for (const value of values) {\n        const variables = this.findVariables(value);\n        variables.forEach(v => allVariables.add(v));\n        complexity += variables.length + (value.length > 50 ? 2 : 0);\n      }\n      \n      complexityScores.push({ name: key, complexity, type: 'static' });\n      \n      if (ruleName === key) {\n        return {\n          totalComplexity: complexity,\n          averageDepth: this.calculateRuleDepth(key),\n          mostComplex: [key],\n          suggestions: complexity > 10 ? ['Consider splitting complex rule into smaller rules'] : [],\n          ruleDetails: {\n            name: key,\n            type: 'static',\n            complexity,\n            variables: Array.from(allVariables),\n            depth: this.calculateRuleDepth(key)\n          }\n        };\n      }\n    }\n    \n    // Add other rule types to complexity analysis\n    this.functionRules.forEach((_, key) => {\n      if (!ruleName || key === ruleName) {\n        complexityScores.push({ name: key, complexity: 5, type: 'function' });\n      }\n    });\n    \n    this.weightedRules.forEach((rule, key) => {\n      if (!ruleName || key === ruleName) {\n        const complexity = rule.values.length * 2;\n        complexityScores.push({ name: key, complexity, type: 'weighted' });\n      }\n    });\n    \n    this.conditionalRules.forEach((rule, key) => {\n      if (!ruleName || key === ruleName) {\n        const complexity = rule.conditions.length * 3;\n        complexityScores.push({ name: key, complexity, type: 'conditional' });\n      }\n    });\n    \n    this.templateRules.forEach((rule, key) => {\n      if (!ruleName || key === ruleName) {\n        const variables = this.findVariables(rule.template);\n        const complexity = variables.length * 2 + Object.keys(rule.variables).length;\n        complexityScores.push({ name: key, complexity, type: 'template' });\n      }\n    });\n    \n    const totalComplexity = complexityScores.reduce((sum, r) => sum + r.complexity, 0);\n    const averageDepth = complexityScores.length > 0 ? \n      complexityScores.reduce((sum, r) => sum + this.calculateRuleDepth(r.name), 0) / complexityScores.length : 0;\n    \n    // Sort by complexity and get top 5 most complex\n    complexityScores.sort((a, b) => b.complexity - a.complexity);\n    const mostComplex = complexityScores.slice(0, 5).map(r => `${r.name} (${r.type}: ${r.complexity})`);\n    \n    // Generate suggestions\n    if (totalComplexity > 100) {\n      suggestions.push('High total complexity - consider simplifying rules');\n    }\n    if (averageDepth > 5) {\n      suggestions.push('Deep rule nesting detected - may impact performance');\n    }\n    if (complexityScores.length > 50) {\n      suggestions.push('Large number of rules - consider organizing into groups');\n    }\n    \n    return {\n      totalComplexity,\n      averageDepth,\n      mostComplex,\n      suggestions\n    };\n  }\n\n  /**\n   * Calculate the maximum depth of rule references for a given rule\n   * @param ruleName - The rule to analyze\n   * @param visited - Set of visited rules to prevent infinite recursion\n   * @returns Maximum depth\n   */\n  private calculateRuleDepth(ruleName: string, visited: Set<string> = new Set()): number {\n    if (visited.has(ruleName)) {\n      return 0; // Circular reference\n    }\n    \n    visited.add(ruleName);\n    let maxDepth = 0;\n    \n    const values = this.grammar[ruleName];\n    if (values) {\n      for (const value of values) {\n        const variables = this.findVariables(value);\n        for (const variable of variables) {\n          if (this.hasRule(variable)) {\n            const depth = 1 + this.calculateRuleDepth(variable, new Set(visited));\n            maxDepth = Math.max(maxDepth, depth);\n          }\n        }\n      }\n    }\n    \n    visited.delete(ruleName);\n    return maxDepth;\n  }\n\n  /**\n   * Generate helpful error messages with contextual suggestions and debugging information\n   * \n   * This method analyzes parsing errors and provides intelligent suggestions for resolving\n   * common issues. It examines the error type, parsing context, and grammar state to offer\n   * specific, actionable advice for fixing problems.\n   * \n   * Error Analysis Capabilities:\n   * - Recursion depth issues with circular reference detection\n   * - Function rule execution failures with debugging tips\n   * - Weight validation errors with correction examples\n   * - Missing rule references with validation integration\n   * - Grammar validation issues with detailed breakdowns\n   * \n   * @param error - The error object that was thrown during parsing\n   * @param context - Optional additional context for better error analysis\n   * @param context.text - The text that was being parsed when error occurred\n   * @param context.ruleName - The specific rule that caused the error\n   * \n   * @returns Enhanced error message with suggestions, validation info, and debugging tips\n   * \n   * @example\n   * ```typescript\n   * try {\n   *   const result = parser.parse('%missing_rule%');\n   * } catch (error) {\n   *   const helpfulMessage = parser.getHelpfulError(error, {\n   *     text: '%missing_rule%',\n   *     ruleName: 'missing_rule'\n   *   });\n   *   \n   *   console.log(helpfulMessage);\n   *   // Output:\n   *   // \"Rule not found\n   *   // \n   *   // Suggestions:\n   *   // • Check that all referenced rules are defined\n   *   // • Use validate() method to find missing rules\n   *   // • Missing rules detected: missing_rule\n   *   // \n   *   // Validation Issues:\n   *   // • Missing rules: missing_rule\"\n   * }\n   * \n   * // Function rule error example\n   * parser.addFunctionRule('broken', () => {\n   *   throw new Error('Something went wrong');\n   * });\n   * \n   * try {\n   *   parser.parse('%broken%');\n   * } catch (error) {\n   *   const help = parser.getHelpfulError(error);\n   *   // Provides specific guidance for function rule debugging\n   * }\n   * ```\n   * \n   * @see {@link validate} for comprehensive grammar validation\n   * @see {@link safeParse} for error-handling parsing\n   * \n   * @since 1.0.0\n   */\n  public getHelpfulError(error: Error, context?: ErrorContext): string {\n    const baseMessage = error.message;\n    let helpfulMessage = baseMessage;\n    const suggestions: string[] = [];\n    \n    // Analyze error type and provide specific help\n    if (baseMessage.includes('Maximum recursion depth')) {\n      suggestions.push('Try reducing the maxDepth with setMaxDepth()');\n      suggestions.push('Check for circular references in your grammar rules');\n      if (context?.ruleName) {\n        suggestions.push(`The rule '${context.ruleName}' may be causing infinite recursion`);\n      }\n    }\n    \n    if (baseMessage.includes('must return an array')) {\n      suggestions.push('Function rules must return string arrays');\n      suggestions.push('Check your function rule implementation');\n    }\n    \n    if (baseMessage.includes('Weights must sum to 1.0')) {\n      suggestions.push('Ensure all weights in weighted rules add up to exactly 1.0');\n      suggestions.push('Use helper: weights = [0.5, 0.3, 0.2] for three items');\n    }\n    \n    if (baseMessage.includes('not found') || baseMessage.includes('undefined')) {\n      suggestions.push('Check that all referenced rules are defined');\n      suggestions.push('Use validate() method to find missing rules');\n      if (context?.text) {\n        const variables = this.findVariables(context.text);\n        const missing = variables.filter(v => !this.hasRule(v));\n        if (missing.length > 0) {\n          suggestions.push(`Missing rules detected: ${missing.join(', ')}`);\n        }\n      }\n    }\n    \n    if (suggestions.length > 0) {\n      helpfulMessage += '\\n\\nSuggestions:\\n' + suggestions.map(s => `• ${s}`).join('\\n');\n    }\n    \n    // Add validation info if relevant\n    if (context?.text) {\n      const validation = this.validate();\n      if (!validation.isValid) {\n        helpfulMessage += `\\n\\nValidation Issues:\\n`;\n        if (validation.missingRules.length > 0) {\n          helpfulMessage += `• Missing rules: ${validation.missingRules.join(', ')}\\n`;\n        }\n        if (validation.circularReferences.length > 0) {\n          helpfulMessage += `• Circular references: ${validation.circularReferences.join(', ')}\\n`;\n        }\n      }\n    }\n    \n    return helpfulMessage;\n  }\n}","/**\n * Story Grammar - A combinatorial grammar for narrative-based projects\n */\n\n// Core Parser and all types\nexport { Parser } from './Parser.js';\n\n// Export all types and interfaces\nexport * from './types.js';\n\n// English modifiers\nexport {\n  EnglishArticleModifier,\n  EnglishPluralizationModifier,\n  EnglishOrdinalModifier,\n  EnglishCapitalizationModifier,\n  EnglishPossessiveModifier,\n  EnglishVerbAgreementModifier,\n  PunctuationCleanupModifier,\n  AllEnglishModifiers,\n  BasicEnglishModifiers\n} from './EnglishModifiers.js';\n\n// Re-export for backward compatibility\nexport { Parser as StoryGrammar } from './Parser.js';","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n"],"names":["root","factory","exports","module","define","amd","this","EnglishArticleModifier","name","condition","text","test","transform","replace","priority","EnglishPluralizationModifier","match","quantifier","noun","pluralNoun","lowerNoun","toLowerCase","irregularPlurals","plural","original","toUpperCase","charAt","slice","includes","pluralize","EnglishOrdinalModifier","num","number","parseInt","lastTwoDigits","EnglishCapitalizationModifier","punctuation","letter","EnglishPossessiveModifier","word","endsWith","EnglishVerbAgreementModifier","PunctuationCleanupModifier","trim","AllEnglishModifiers","BasicEnglishModifiers","Parser","grammar","functionRules","Map","weightedRules","conditionalRules","sequentialRules","rangeRules","templateRules","referenceValues","modifiers","variablePattern","maxDepth","randomSeed","currentSeed","currentContext","addRule","key","values","Error","Array","isArray","addRules","rules","Object","entries","addFunctionRule","fn","set","removeFunctionRule","delete","hasFunctionRule","has","clearFunctionRules","clear","addWeightedRule","weights","length","weight","weightSum","reduce","sum","Math","abs","cumulativeWeights","cumSum","push","removeWeightedRule","hasWeightedRule","clearWeightedRules","addConditionalRule","rule","conditions","hasDefault","default","if","then","map","c","addSequentialRule","options","cycle","index","addRangeRule","config","min","max","undefined","step","type","addTemplateRule","template","variables","templateVars","findVariables","variable","removeConditionalRule","removeSequentialRule","removeRangeRule","removeTemplateRule","hasConditionalRule","hasSequentialRule","hasRangeRule","hasTemplateRule","clearConditionalRules","clearSequentialRules","clearRangeRules","clearTemplateRules","resetSequentialRule","get","addModifier","modifier","removeModifier","hasModifier","getModifiers","from","sort","a","b","loadModifier","loadModifiers","getGrammar","grammarCopy","parse","preserveContext","expanded","expandVariables","applyModifiers","originalText","parseWithTiming","startTime","Date","now","expansionStart","expansionEnd","modifierStart","result","modifierEnd","timing","totalMs","expansionMs","modifierMs","depth","lastIndex","selectedValue","startsWith","refKey","substring","refValue","functionRule","getRandomValue","error","message","String","conditionalRule","getConditionalValue","sequentialRule","getSequentialValue","rangeRule","getRangeValue","templateRule","getTemplateValue","weightedRule","getWeightedRandomValue","context","modifiedText","sortedModifiers","value","numSteps","floor","getSeededRandom","round","toString","tempContext","RegExp","random","i","hasRule","removeRule","removedFunction","removedConditional","removedSequential","removedRange","removedTemplate","removedWeighted","removedStatic","clearModifiers","clearAll","Set","exec","add","validate","missingRules","circularReferences","emptyRules","referencedRules","warnings","allRuleKeys","keys","unreachableRules","filter","size","isValid","safeParse","validateFirst","maxAttempts","validation","success","lastError","attempt","attempts","originalDepth","setMaxDepth","getMaxDepth","setRandomSeed","seed","Number","isInteger","clearRandomSeed","getRandomSeed","clearReferences","getContext","parseBatch","texts","results","shouldPreserve","generateVariations","count","originalSeed","variations","getStats","totalRules","rulesByType","static","function","weighted","conditional","sequential","range","totalModifiers","hasRandomSeed","exportConfig","settings","clone","cloned","optimize","suggestions","stats","allVariables","forEach","v","unusedRules","join","optimized","analyzeRules","ruleName","complexityScores","complexity","totalComplexity","averageDepth","calculateRuleDepth","mostComplex","ruleDetails","_","r","visited","getHelpfulError","baseMessage","helpfulMessage","missing","s","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}