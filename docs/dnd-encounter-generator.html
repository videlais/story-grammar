<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Encounter Generator - Story Grammar Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #8B0000 0%, #DC143C 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 30px;
            text-align: center;
            background: rgba(139, 0, 0, 0.05);
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(135deg, #8B0000 0%, #DC143C 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 0, 0, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 0, 0, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .loading {
            display: none;
            color: #666;
            font-style: italic;
            margin: 20px 0;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }

        .encounters-section,
        .stats-section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: 1.4em;
            margin-bottom: 20px;
            color: #8B0000;
            border-bottom: 2px solid #DC143C;
            padding-bottom: 10px;
        }

        .encounter {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .encounter:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
        }

        .encounter-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #8B0000;
            margin-bottom: 10px;
        }

        .encounter-description {
            color: #444;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .encounter-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            font-size: 0.9em;
        }

        .detail-item {
            background: rgba(139, 0, 0, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
        }

        .detail-label {
            font-weight: bold;
            color: #8B0000;
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #8B0000;
            display: block;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .monster-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .monster-item {
            background: rgba(139, 0, 0, 0.05);
            margin: 5px 0;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cr-badge {
            background: #8B0000;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .button-group {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üêâ D&D Encounter Generator üé≤</h1>
            <p>Dynamic encounter generation powered by Story Grammar and real D&D monster data</p>
        </div>

        <div class="controls">
            <div class="button-group">
                <button id="generateOne">Generate One Encounter</button>
                <button id="generateFive">Generate 5 Encounters</button>
                <button id="clearAll">Clear All</button>
            </div>
            <div class="loading" id="loadingIndicator">
                üé≤ Rolling for encounters...
            </div>
        </div>

        <div class="content">
            <div class="encounters-section">
                <h2 class="section-title">Generated Encounters</h2>
                <div id="encountersContainer">
                    <p style="color: #666; text-align: center; font-style: italic;">
                        Click "Generate One Encounter" or "Generate 5 Encounters" to create dynamic D&D encounters!
                    </p>
                </div>
            </div>

            <div class="stats-section">
                <h2 class="section-title">Encounter Statistics</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-number" id="totalEncounters">0</span>
                        <div class="stat-label">Total Encounters</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="uniqueMonsters">0</span>
                        <div class="stat-label">Unique Monsters Used</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="avgChallengeRating">0</span>
                        <div class="stat-label">Avg Challenge Rating</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-number" id="favoriteDifficulty">-</span>
                        <div class="stat-label">Most Common Difficulty</div>
                    </div>
                </div>

                <div class="monster-list">
                    <h3 style="margin-bottom: 10px; color: #8B0000;">Monster Usage</h3>
                    <div id="monsterStats">
                        <p style="color: #666; text-align: center; font-style: italic;">
                            Generate encounters to see monster statistics
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Story Grammar from GitHub CDN -->
    <script src="https://cdn.jsdelivr.net/gh/videlais/story-grammar@main/dist/story-grammar.bundle.js"></script>
    
    <script>
        // Global variables
        let monsters = [];
        let encounters = [];
        let parser;
        let monsterUsage = new Map();

        // Initialize the application
        async function initializeApp() {
            try {
                // Fetch monster data from GitHub
                console.log('Fetching monster data...');
                const response = await fetch('https://raw.githubusercontent.com/nick-aschenbach/dnd-data/refs/heads/main/data/monsters.json');
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch monsters: ${response.status}`);
                }
                
                const data = await response.json();
                monsters = data;
                console.log(`Loaded ${monsters.length} monsters`);
                
                // Initialize Story Grammar parser
                parser = new StoryGrammar.Parser();
                setupGrammarRules();
                
                // Enable buttons
                document.getElementById('generateOne').disabled = false;
                document.getElementById('generateFive').disabled = false;
                
            } catch (error) {
                console.error('Error initializing app:', error);
                document.getElementById('encountersContainer').innerHTML = `
                    <div style="color: red; text-align: center;">
                        <p><strong>Error loading monster data:</strong></p>
                        <p>${error.message}</p>
                        <p>Please check your internet connection and try refreshing the page.</p>
                    </div>
                `;
            }
        }

        // Setup Story Grammar rules for D&D encounters
        function setupGrammarRules() {
            // Load built-in English modifiers using new API
            parser.loadModifier(StoryGrammar.EnglishArticleModifier);
            parser.loadModifier(StoryGrammar.EnglishPluralizationModifier);
            parser.loadModifier(StoryGrammar.EnglishOrdinalModifier);

            // Filter monsters by challenge rating for balanced encounters
            const easyMonsters = monsters.filter(m => getChallengeRatingValue(m.properties?.['Challenge Rating']) <= 2);
            const mediumMonsters = monsters.filter(m => {
                const cr = getChallengeRatingValue(m.properties?.['Challenge Rating']);
                return cr >= 3 && cr <= 6;
            });
            const hardMonsters = monsters.filter(m => {
                const cr = getChallengeRatingValue(m.properties?.['Challenge Rating']);
                return cr >= 7 && cr <= 12;
            });
            const deadlyMonsters = monsters.filter(m => getChallengeRatingValue(m.properties?.['Challenge Rating']) >= 13);

            // Monster names by difficulty
            parser.addRule('easy_monsters', easyMonsters.map(m => m.name));
            parser.addRule('medium_monsters', mediumMonsters.map(m => m.name));
            parser.addRule('hard_monsters', hardMonsters.map(m => m.name));
            parser.addRule('deadly_monsters', deadlyMonsters.map(m => m.name));

            // Encounter difficulties
            parser.addRule('difficulties', ['Easy', 'Medium', 'Hard', 'Deadly']);
            
            // Encounter locations
            parser.addRule('locations', [
                'an ancient dungeon', 'a dark forest', 'a mountain pass', 'a haunted cemetery',
                'a mysterious cave', 'an abandoned castle', 'a misty swamp', 'a crumbling tower',
                'a sacred temple', 'an underground cavern', 'a frozen wasteland', 'a burning desert',
                'a floating island', 'a sunken ship', 'an ethereal plane', 'a pocket dimension'
            ]);

            // Encounter reasons/motivations
            parser.addRule('motivations', [
                'protecting their territory', 'guarding ancient treasure', 'seeking revenge',
                'following dark orders', 'hunting for food', 'performing a ritual',
                'defending their young', 'corrupted by evil magic', 'driven mad by isolation',
                'searching for a lost artifact', 'obeying their master', 'fulfilling a curse'
            ]);

            // Encounter complications
            parser.addRule('complications', [
                'The area is shrouded in magical darkness',
                'Unstable magic causes wild surges',
                'The ground is treacherous and shifting',
                'Ancient traps are scattered throughout',
                'A mysterious fog limits visibility',
                'The air itself seems to drain energy',
                'Spectral voices whisper warnings',
                'Time moves strangely in this place',
                'The very walls seem to watch and judge',
                'Reality bends and warps unpredictably'
            ]);

            // Encounter rewards with dynamic values
            parser.addRule('rewards', [
                'a cache of %gold_amount% ancient coins', 'a mysterious magical item', 'a scroll with forbidden knowledge',
                'a key to a secret chamber', 'a map to hidden treasure', 'a rare gemstone worth %gem_value% gold',
                'an ornate weapon', 'a protective talisman', 'a potion of great power',
                'a book of forgotten lore', 'a crystal containing trapped magic', 'a crown of forgotten royalty'
            ]);

            // Add range rules for dynamic values
            parser.addRangeRule('gold_amount', { min: 10, max: 500, type: 'integer' }); // 10-500 gold pieces
            parser.addRangeRule('gem_value', { min: 50, max: 1000, type: 'integer' });  // 50-1000 gold value
            parser.addRangeRule('party_level', { min: 1, max: 10, type: 'integer' });   // Character levels 1-10

            // Sequential rule for encounter progression
            parser.addSequentialRule('encounter_number', ['First', 'Second', 'Third', 'Fourth', 'Fifth']);

            // Use weighted rules for balanced encounter difficulty
            parser.addWeightedRule('encounter_difficulty', 
                ['Easy', 'Medium', 'Hard', 'Deadly'], 
                [0.4, 0.3, 0.2, 0.1] // 40% easy, 30% medium, 20% hard, 10% deadly
            );

            // Conditional monster selection based on difficulty
            parser.addConditionalRule('selected_monster', (context) => {
                const difficulty = context.get('encounter_difficulty');
                switch(difficulty) {
                    case 'Easy': return easyMonsters[Math.floor(Math.random() * easyMonsters.length)].name;
                    case 'Medium': return mediumMonsters[Math.floor(Math.random() * mediumMonsters.length)].name;
                    case 'Hard': return hardMonsters[Math.floor(Math.random() * hardMonsters.length)].name;
                    case 'Deadly': return deadlyMonsters[Math.floor(Math.random() * deadlyMonsters.length)].name;
                    default: return easyMonsters[Math.floor(Math.random() * easyMonsters.length)].name;
                }
            });

            // Use template rule for structured encounter generation
            parser.addTemplateRule('encounter',
                'In {location}, the adventurers face a {difficulty} encounter with a {monster} {motivation}. {complication} Victory might yield {reward}.',
                ['location', 'difficulty', 'monster', 'motivation', 'complication', 'reward']
            );

                        // Note: Reference functionality is built-in - no explicit mapping needed\n            // Template slots will automatically reference existing rules by name
        }

        // Convert challenge rating string to numeric value
        function getChallengeRatingValue(cr) {
            if (!cr) return 0;
            const crStr = cr.toString().trim();
            
            // Handle fractions
            if (crStr.includes('/')) {
                const parts = crStr.split('/');
                return parseFloat(parts[0]) / parseFloat(parts[1]);
            }
            
            // Handle regular numbers
            const num = parseFloat(crStr);
            return isNaN(num) ? 0 : num;
        }

        // Get difficulty based on challenge rating
        function getDifficultyFromCR(cr) {
            const value = getChallengeRatingValue(cr);
            if (value <= 2) return 'Easy';
            if (value <= 6) return 'Medium';
            if (value <= 12) return 'Hard';
            return 'Deadly';
        }

        // Get monster details by name
        function getMonsterDetails(name) {
            return monsters.find(m => m.name === name);
        }

        // Generate a single encounter
        function generateEncounter() {
            const encounterText = parser.parse('%encounter%');
            
            // Extract monster name from the generated text (simple regex approach)
            const monsterNames = monsters.map(m => m.name);
            let usedMonster = null;
            
            for (const monsterName of monsterNames) {
                if (encounterText.includes(monsterName)) {
                    usedMonster = getMonsterDetails(monsterName);
                    break;
                }
            }

            const encounter = {
                id: encounters.length + 1,
                text: encounterText,
                monster: usedMonster,
                timestamp: new Date()
            };

            // Track monster usage
            if (usedMonster) {
                const count = monsterUsage.get(usedMonster.name) || 0;
                monsterUsage.set(usedMonster.name, count + 1);
            }

            encounters.push(encounter);
            return encounter;
        }

        // Render encounter to HTML
        function renderEncounter(encounter) {
            const monster = encounter.monster;
            const cr = monster?.properties?.['Challenge Rating'] || 'Unknown';
            const size = monster?.properties?.Size || 'Unknown';
            const type = monster?.properties?.Type || 'Unknown';
            const alignment = monster?.properties?.Alignment || 'Unknown';
            const difficulty = monster ? getDifficultyFromCR(cr) : 'Unknown';

            return `
                <div class="encounter">
                    <div class="encounter-title">Encounter #${encounter.id}</div>
                    <div class="encounter-description">${encounter.text}</div>
                    <div class="encounter-details">
                        <div class="detail-item">
                            <span class="detail-label">Monster</span>
                            ${monster?.name || 'Unknown'}
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Challenge Rating</span>
                            ${cr}
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Difficulty</span>
                            ${difficulty}
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Size</span>
                            ${size}
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Type</span>
                            ${type}
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">Alignment</span>
                            ${alignment}
                        </div>
                    </div>
                </div>
            `;
        }

        // Update statistics display
        function updateStats() {
            const totalEncounters = encounters.length;
            const uniqueMonsters = monsterUsage.size;
            
            // Calculate average challenge rating
            let totalCR = 0;
            let validCRCount = 0;
            encounters.forEach(encounter => {
                if (encounter.monster) {
                    const cr = getChallengeRatingValue(encounter.monster.properties?.['Challenge Rating']);
                    if (cr > 0) {
                        totalCR += cr;
                        validCRCount++;
                    }
                }
            });
            const avgCR = validCRCount > 0 ? (totalCR / validCRCount).toFixed(1) : 0;

            // Find most common difficulty
            const difficultyCount = {};
            encounters.forEach(encounter => {
                if (encounter.monster) {
                    const difficulty = getDifficultyFromCR(encounter.monster.properties?.['Challenge Rating']);
                    difficultyCount[difficulty] = (difficultyCount[difficulty] || 0) + 1;
                }
            });
            
            const favoriteDifficulty = Object.keys(difficultyCount).reduce((a, b) => 
                difficultyCount[a] > difficultyCount[b] ? a : b, '-'
            );

            // Update display
            document.getElementById('totalEncounters').textContent = totalEncounters;
            document.getElementById('uniqueMonsters').textContent = uniqueMonsters;
            document.getElementById('avgChallengeRating').textContent = avgCR;
            document.getElementById('favoriteDifficulty').textContent = totalEncounters > 0 ? favoriteDifficulty : '-';

            // Update monster usage list
            const monsterStatsContainer = document.getElementById('monsterStats');
            if (monsterUsage.size === 0) {
                monsterStatsContainer.innerHTML = '<p style="color: #666; text-align: center; font-style: italic;">Generate encounters to see monster statistics</p>';
            } else {
                const sortedMonsters = Array.from(monsterUsage.entries()).sort((a, b) => b[1] - a[1]);
                monsterStatsContainer.innerHTML = sortedMonsters.map(([name, count]) => {
                    const monster = getMonsterDetails(name);
                    const cr = monster?.properties?.['Challenge Rating'] || '?';
                    return `
                        <div class="monster-item">
                            <span>${name} (√ó${count})</span>
                            <span class="cr-badge">CR ${cr}</span>
                        </div>
                    `;
                }).join('');
            }
        }

        // Show loading indicator
        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'block';
        }

        // Hide loading indicator
        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        // Event listeners
        document.getElementById('generateOne').addEventListener('click', async () => {
            showLoading();
            await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for effect
            
            const encounter = generateEncounter();
            const container = document.getElementById('encountersContainer');
            
            if (encounters.length === 1) {
                container.innerHTML = ''; // Clear placeholder text
            }
            
            container.innerHTML += renderEncounter(encounter);
            container.scrollTop = container.scrollHeight; // Scroll to bottom
            
            updateStats();
            hideLoading();
        });

        document.getElementById('generateFive').addEventListener('click', async () => {
            showLoading();
            await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for effect
            
            const container = document.getElementById('encountersContainer');
            
            if (encounters.length === 0) {
                container.innerHTML = ''; // Clear placeholder text
            }
            
            for (let i = 0; i < 5; i++) {
                const encounter = generateEncounter();
                container.innerHTML += renderEncounter(encounter);
            }
            
            container.scrollTop = container.scrollHeight; // Scroll to bottom
            updateStats();
            hideLoading();
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            encounters = [];
            monsterUsage.clear();
            
            document.getElementById('encountersContainer').innerHTML = `
                <p style="color: #666; text-align: center; font-style: italic;">
                    Click "Generate One Encounter" or "Generate 5 Encounters" to create dynamic D&D encounters!
                </p>
            `;
            
            updateStats();
        });

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>